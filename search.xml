<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 SerializedLambda 替代字符串</title>
      <link href="java-serializedlambda/"/>
      <url>java-serializedlambda/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中使用 mongo，ORM 使用的是 spring-boot-starter-data-mongo。在使用过程中，对于数据库字段，每次都要写，觉得麻烦，然后想起以前使用 mybatis-plus，只需要使用 lambda 获取字段名称即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">getListByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  LambdaQueryWrapper&lt;UserInfo&gt; queryWrapper = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">  queryWrapper.eq(UserInfo::getName, name);</span><br><span class="line">  <span class="keyword">return</span> list(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Lambda"><a href="#使用-Lambda" class="headerlink" title="使用 Lambda"></a>使用 Lambda</h2><h3 id="定义函数接口"><a href="#定义函数接口" class="headerlink" title="定义函数接口"></a>定义函数接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func</span>&lt;<span class="title">E</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">E</span>, <span class="title">R</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数式接口继承 <code>Serializable</code> 接口，在 JDK 1.8 之后，JDK提供了一个新的类，凡是继承了 <code>Serializable</code> 的函数是接口的实例，都可以获取一个属于它的 <code>SerializedLambda</code> 实例，并通过他获取方法的名称。所以，我们就是通过上面的原理来想实现通过 Lambda 来获取 Java Bean 的属性名称。</p><h3 id="实现获取方法字段"><a href="#实现获取方法字段" class="headerlink" title="实现获取方法字段"></a>实现获取方法字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectLambdaUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReflectLambdaUtils.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据参数获取字段名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> func</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E, R&gt; <span class="function">String <span class="title">getFieldName</span><span class="params">(Func&lt;E, R&gt; func)</span> </span>&#123;</span><br><span class="line">        Field field = getField(func);</span><br><span class="line">        <span class="keyword">return</span> field.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取表达式的字段</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> func</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E, R&gt; <span class="function">Field <span class="title">getField</span><span class="params">(Func&lt;E, R&gt; func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = func.getClass().getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">            method.setAccessible(Boolean.TRUE);</span><br><span class="line">            <span class="comment">// 1.调用 writeReplace 方法，返回一个 writeReplace 对象</span></span><br><span class="line">            SerializedLambda serializedLambda = (SerializedLambda) method.invoke(func);</span><br><span class="line">            String getterMethod = serializedLambda.getImplMethodName();</span><br><span class="line">            String fieldName = Introspector.decapitalize(getterMethod.replace(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="comment">// 2. 获取的Class是字符串，并且包名是“/”分割，需要替换成“.”，才能获取到对应的Class对象</span></span><br><span class="line">            String declaredClass = serializedLambda.getImplClass().replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(declaredClass, <span class="keyword">false</span>, ClassUtils.getDefaultClassLoader());</span><br><span class="line">            <span class="comment">// 3.通过Spring 中的反射工具类获取Class中定义的Field</span></span><br><span class="line">            <span class="keyword">return</span> ReflectionUtils.findField(aClass, fieldName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;解析类字段出现异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MongoPlusException(<span class="string">&quot;解析字段时出现异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>writeReplace()</code> 这个方法，是虚拟机加上去的，虚拟机会自动实现 <code>Serializable</code> 接口的 Lambda 表达式生成 <code>writeReplace()</code> 方法。如果是被序列化后，实体对象就会有 <code>writeReplace()</code> 方法，调用该方法，会返回 <code>SerializedLambda</code> 对象去做序列化，即被序列化的对象被替换了。</p><p>这个时候，返回的 <code>SerializedLambda</code> 对象中包含了 Lambda 表达式中所有的信息，比如函数名<code>implMethodName</code>、函数签名 <code>implMethodSignature</code> 等等。我们就可以根据这些信息，获取我们所需要的属性字段了。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Field(value = &quot;user_age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, userId=&#x27;&quot;</span> + userId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFieldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.setAge(<span class="number">20</span>);</span><br><span class="line">        userInfo.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(ReflectLambdaUtils.getFieldName(UserInfo::getUserId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Guava 工具类的介绍和使用</title>
      <link href="java-google-guava/"/>
      <url>java-google-guava/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工具类就是封装平时常用的方法，不需要重复造轮子，今天介绍下谷歌的 guava。</p><p>guava 的优点：</p><ul><li>高效设计良好的API，被 Google 的开发者设计，实现和使用</li><li>遵循高效的Java的语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><p>Guava 工具包包含若干个 Google Java项目：</p><ul><li>集合</li><li>缓存</li><li>原生类型支持</li><li>并发库</li><li>通用注解</li><li>字符串处理</li><li>I/O 等</li></ul><p>在使用时，只需要在项目依赖中加入 Google Guava：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>31.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Google Guava 工具包提供了大量创建和使用集合的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通 Collection 创建</span></span><br><span class="line">    List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">    Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">    <span class="comment">// BiMap: 双向Map（Bidirectional Map）键和值不能重复</span></span><br><span class="line">    BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变 Collection创建</span></span><br><span class="line">    ImmutableList&lt;String&gt; iList = ImmutableList.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合和特定字符串转换"><a href="#集合和特定字符串转换" class="headerlink" title="集合和特定字符串转换"></a>集合和特定字符串转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通 Collection 创建</span></span><br><span class="line">    List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">    Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变 Collection创建</span></span><br><span class="line">    ImmutableList&lt;String&gt; iList = ImmutableList.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BiMap: 双向Map（Bidirectional Map）键和值不能重复</span></span><br><span class="line">    BiMap&lt;String, Integer&gt; biMap = HashBiMap.create();</span><br><span class="line">    biMap.put(<span class="string">&quot;张三&quot;</span>,<span class="number">54</span>);</span><br><span class="line">    biMap.put(<span class="string">&quot;李四&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    biMap.put(<span class="string">&quot;程思&quot;</span>,<span class="number">33</span>);</span><br><span class="line">    biMap.put(<span class="string">&quot;吴楠&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key相同value不同，后面的会覆盖前面的</span></span><br><span class="line">    biMap.put(<span class="string">&quot;吴楠&quot;</span>,<span class="number">46</span>);</span><br><span class="line">    <span class="comment">//启动程序会报错 java.lang.IllegalArgumentException: value already present: 23</span></span><br><span class="line">    <span class="comment">//biMap.put(&quot;张刚&quot;,23);</span></span><br><span class="line">    <span class="comment">//强行添加，会覆盖</span></span><br><span class="line">    <span class="comment">//biMap.forcePut(&quot;张刚&quot;,23);</span></span><br><span class="line">    System.out.println(biMap);</span><br><span class="line">    <span class="comment">//反转 key和value反转</span></span><br><span class="line">    BiMap&lt;Object, Object&gt; inverseMap = biMap.inverse();</span><br><span class="line">    System.out.println(inverseMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将集合转换成特定字符串，很多工具都支持这个功能。</p><h3 id="集合切割（Lists-partitions）"><a href="#集合切割（Lists-partitions）" class="headerlink" title="集合切割（Lists.partitions）"></a>集合切割（Lists.partitions）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Lists.partition(list, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]</span><br></pre></td></tr></table></figure><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//反转list</span></span><br><span class="line">    List&lt;String&gt; reverseList1 = Lists.reverse(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;反转：&quot;</span> + reverseList1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合过滤 [guava, Java]</span></span><br><span class="line">    ImmutableList&lt;String&gt; names = ImmutableList.of(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;guava&quot;</span>, <span class="string">&quot;google&quot;</span>, <span class="string">&quot;alibaba&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Go&quot;</span>);</span><br><span class="line">    Iterable&lt;String&gt; filterList = Iterables.filter(names, Predicates.or(</span><br><span class="line">            Predicates.equalTo(<span class="string">&quot;guava&quot;</span>), Predicates.equalTo(<span class="string">&quot;Java&quot;</span>)));</span><br><span class="line">    System.out.println(filterList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义过滤条件: &#123;a=12, b=15&#125;</span></span><br><span class="line">    ImmutableMap&lt;String, Integer&gt; m = ImmutableMap.of(<span class="string">&quot;a&quot;</span>, <span class="number">12</span>, <span class="string">&quot;b&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="comment">// Function&lt;F, T&gt; 中 F表示apply()方法input的类型，T表示apply()返回的类型</span></span><br><span class="line">    Map&lt;String, Integer&gt; m2 = Maps.transformValues(m, <span class="keyword">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Integer <span class="title">apply</span><span class="params">(<span class="meta">@Nullable</span> Integer input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (input &gt; <span class="number">12</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> input;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> input++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集、并集、差集</span></span><br><span class="line">    Set&lt;String&gt; set1 = Sets.newHashSet(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; set2 = Sets.newHashSet(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="comment">// 并集</span></span><br><span class="line">    Sets.SetView&lt;String&gt; union = Sets.union(set1, set2);</span><br><span class="line">    System.out.println(<span class="string">&quot;并集:&quot;</span> + union);</span><br><span class="line">    <span class="comment">// 差集</span></span><br><span class="line">    Sets.SetView&lt;String&gt; difference = Sets.difference(set1, set2);</span><br><span class="line">    System.out.println(<span class="string">&quot;差集&quot;</span> + difference);</span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    Sets.SetView&lt;String&gt; intersection = Sets.intersection(set1, set2);</span><br><span class="line">    System.out.println(<span class="string">&quot;交集:&quot;</span> + intersection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也支持很多Map的操作，现在列举一些基础使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**Map的常见用法*/</span></span><br><span class="line">    Map&lt;String, Object&gt; leftMap = ImmutableMap.of(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;汪&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;陕西&quot;</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;西安&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; rightMap = ImmutableMap.of(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">16</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;陕西&quot;</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;西安&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;美国&quot;</span>);</span><br><span class="line">    MapDifference&lt;String, Object&gt; deffMap = Maps.difference(leftMap, rightMap);</span><br><span class="line">    <span class="comment">//相同的</span></span><br><span class="line">    Map&lt;String, Object&gt; map = deffMap.entriesInCommon();</span><br><span class="line">    System.out.println(<span class="string">&quot;相同的:&quot;</span> + map);</span><br><span class="line">    <span class="comment">//同key不同value</span></span><br><span class="line">    Map&lt;String, MapDifference.ValueDifference&lt;Object&gt;&gt; stringValueDifferenceMap = deffMap.entriesDiffering();</span><br><span class="line">    System.out.println(<span class="string">&quot;同key不同value:&quot;</span> + stringValueDifferenceMap);</span><br><span class="line">    <span class="comment">//仅仅左边有的</span></span><br><span class="line">    Map&lt;String, Object&gt; onlyLeft = deffMap.entriesOnlyOnLeft();</span><br><span class="line">    System.out.println(<span class="string">&quot;仅仅左边有的:&quot;</span> + onlyLeft);</span><br><span class="line">    <span class="comment">//仅仅右边有的</span></span><br><span class="line">    Map&lt;String, Object&gt; onlyRight = deffMap.entriesOnlyOnRight();</span><br><span class="line">    System.out.println(<span class="string">&quot;仅仅右边有的:&quot;</span> + onlyRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除空格: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    String str = <span class="string">&quot;1-2-3-4-  5-   6     &quot;</span>;</span><br><span class="line">    List&lt;String&gt; trimList = Splitter.on(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            .omitEmptyStrings()</span><br><span class="line">            <span class="comment">// 可指定字符</span></span><br><span class="line">            .trimResults()</span><br><span class="line">            .splitToList(str);</span><br><span class="line">    System.out.println(trimList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String -&gt; Map</span></span><br><span class="line">    String mapStr = <span class="string">&quot;zhangsan=25,lisi=90&quot;</span>;</span><br><span class="line">    Map&lt;String, String&gt; splitMap = Splitter.on(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            .withKeyValueSeparator(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">            .split(mapStr);</span><br><span class="line">    System.out.println(splitMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guava 支持多字符或者正则切分:[aa, dd, ff]</span></span><br><span class="line">    String input = <span class="string">&quot;aa.dd,,ff,,.&quot;</span>;</span><br><span class="line">    List&lt;String&gt; result = Splitter.onPattern(<span class="string">&quot;[.|,]&quot;</span>)</span><br><span class="line">            .omitEmptyStrings()</span><br><span class="line">            .splitToList(input);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;==========CharMatcher===============&quot;</span>);</span><br><span class="line">    <span class="comment">// 匹配所有的</span></span><br><span class="line">    CharMatcher charMatcher1 = CharMatcher.any();</span><br><span class="line">    CharMatcher charMatcher2 = CharMatcher.anyOf(<span class="string">&quot;aef&quot;</span>);</span><br><span class="line">    <span class="comment">// 什么也不匹配的</span></span><br><span class="line">    CharMatcher charMatcher3 = CharMatcher.none();</span><br><span class="line">    <span class="comment">// 匹配空白字符的</span></span><br><span class="line">    CharMatcher charMatcher4 = CharMatcher.whitespace();</span><br><span class="line">    CharMatcher charMatcher4_1 = CharMatcher.breakingWhitespace();</span><br><span class="line">    <span class="comment">// 匹配单个字符</span></span><br><span class="line">    CharMatcher charMatcher5 = CharMatcher.is(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    CharMatcher charMatcher6 = CharMatcher.isNot(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// 匹配范围</span></span><br><span class="line">    CharMatcher charMatcher7 = CharMatcher.inRange(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    CharMatcher charMatcher8 = CharMatcher.inRange(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    CharMatcher charMatcher9 = CharMatcher.inRange(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;==========CaseFormat===============&quot;</span>);</span><br><span class="line">    <span class="comment">// 转驼峰：constantName</span></span><br><span class="line">    String lowerCamel = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, <span class="string">&quot;CONSTANT_NAME&quot;</span>);</span><br><span class="line">    System.out.println(lowerCamel);</span><br><span class="line">    <span class="comment">// 转驼峰：ConstantName</span></span><br><span class="line">    String upperCamel = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, <span class="string">&quot;CONSTANT_NAME&quot;</span>);</span><br><span class="line">    System.out.println(upperCamel);</span><br><span class="line">    <span class="comment">// 转小写：constant-name</span></span><br><span class="line">    String lowerHyphen = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_HYPHEN, <span class="string">&quot;CONSTANT_NAME&quot;</span>);</span><br><span class="line">    System.out.println(lowerHyphen);</span><br><span class="line">    <span class="comment">// 转小写：constant_name</span></span><br><span class="line">    String lowerUnderscore = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_UNDERSCORE, <span class="string">&quot;CONSTANT_NAME&quot;</span>);</span><br><span class="line">    System.out.println(lowerUnderscore);</span><br><span class="line">    <span class="comment">// CONSTANT_NAME</span></span><br><span class="line">    String upperUnderscore = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_UNDERSCORE, <span class="string">&quot;CONSTANT_NAME&quot;</span>);</span><br><span class="line">    System.out.println(upperUnderscore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发库"><a href="#并发库" class="headerlink" title="并发库"></a>并发库</h2><h3 id="ThreadFactoryBuilder"><a href="#ThreadFactoryBuilder" class="headerlink" title="ThreadFactoryBuilder"></a>ThreadFactoryBuilder</h3><h3 id="SettableFuture"><a href="#SettableFuture" class="headerlink" title="SettableFuture"></a>SettableFuture</h3><h3 id="ListenableFuture"><a href="#ListenableFuture" class="headerlink" title="ListenableFuture"></a>ListenableFuture</h3><p>Guava 定义了 ListenableFuture 接口并继承了JDK concurrent包下的Future 接口，扩展了一个addListener 监听方法，当任务执行完成，会主动回调该方法。主要也是弥补了JDK自带Future的不足，像Netty 也优雅的实现了异步回调机制，不需要手动通过 Future.get() 来获取结果。</p><h3 id="Futures-addCallback"><a href="#Futures-addCallback" class="headerlink" title="Futures.addCallback"></a>Futures.addCallback</h3><h3 id="AsyncFunction"><a href="#AsyncFunction" class="headerlink" title="AsyncFunction"></a>AsyncFunction</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Guava Cache 可以作为本地缓存，支持很多方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//google guava cache CacheBuilder的构造函数是私有的，在智能通过静态方法 newBuilder 来获取 CacheBuilder 实例</span></span><br><span class="line">    LoadingCache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">//设置并发级别为8，并发级别是指可以同时写缓存的线程数</span></span><br><span class="line">            .concurrencyLevel(<span class="number">8</span>)</span><br><span class="line">            <span class="comment">//设置写缓存后8秒过期</span></span><br><span class="line">            .expireAfterWrite(<span class="number">8</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//设置初始容量 10</span></span><br><span class="line">            .initialCapacity(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">//设置缓存最大容量为100，超过100之后就会按照 LRU 最近最少使用算法来移除缓存</span></span><br><span class="line">            .maximumSize(<span class="number">100</span>)</span><br><span class="line">            <span class="comment">//定时刷新数据</span></span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            <span class="comment">//设置要统计缓存的命中率</span></span><br><span class="line">            .recordStats()</span><br><span class="line">            <span class="comment">//设置缓存移除通知</span></span><br><span class="line">            .removalListener(<span class="keyword">new</span> RemovalListener&lt;Object, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Object, Object&gt; notification)</span> </span>&#123;</span><br><span class="line">                    System.out.println(notification.getKey() + <span class="string">&quot; was removed, cause is&quot;</span> + notification.getCause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build(</span><br><span class="line">                    <span class="comment">//build 方法可以指定CacheLoader，在缓存不存在是通过CacheLoader的实现自动加载缓存</span></span><br><span class="line">                    <span class="keyword">new</span> CacheLoader&lt;Integer, String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Integer key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;load data: &quot;</span> + key);</span><br><span class="line">                            String str = key + <span class="string">&quot;:cache-value&quot;</span>;</span><br><span class="line">                            <span class="keyword">return</span> str;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        String str = cache.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="comment">//休眠一秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;cache status:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(cache.stats().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Document\\temp\\test.txt&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = Files.readLines(file, Charsets.UTF_8);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件拷贝</span></span><br><span class="line">    Files.copy(form, to);</span><br><span class="line">    Files.move(File from, File to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 实现动态定时任务</title>
      <link href="springboot-dynamic-job/"/>
      <url>springboot-dynamic-job/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中碰到一些问题，一个定时任务在运行过程中崩溃，导致定时任务没有执行完成，业务那边想能够在不重启任务的情况下，重启任务继续跑，而且希望在不重启服务的情况下，能够动态的修改定时任务时间。所以有了这一篇文章。</p><p>一般情况下，在Spring Boot 项目中，想使用定时任务，只需要使用 <code>@EnableScheduling</code> 注解开启定时任务即可，然后在定时任务调度的任务上，添加<code>@Scheduled</code>，修改自己需要的任务周期。</p><h2 id="普通定时任务"><a href="#普通定时任务" class="headerlink" title="普通定时任务"></a>普通定时任务</h2><p>下面是一般情况下，在开启<code>@EnableScheduling</code>注解情况下，一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;* * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态修改定时任务"><a href="#动态修改定时任务" class="headerlink" title="动态修改定时任务"></a>动态修改定时任务</h2><h3 id="方法一：仅修改任务周期"><a href="#方法一：仅修改任务周期" class="headerlink" title="方法一：仅修改任务周期"></a>方法一：仅修改任务周期</h3><p>实现 <code>SchedulingConfigurer</code> 方法，重写 <code>configureTasks</code> 方法，重新制定 <code>Trigger</code>。下面上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicCronJob</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认定时任务执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String taskCron = GlobalConstants.TASK_DEFAULT_CRON;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> </span>&#123;</span><br><span class="line">        scheduledTaskRegistrar.addTriggerTask(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">&quot;执行任务，当前时间：&#123;&#125;&quot;</span>, time);</span><br><span class="line">        &#125;, triggerContext -&gt; &#123;</span><br><span class="line">            <span class="comment">// 刷新cron时间</span></span><br><span class="line">            CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(taskCron);</span><br><span class="line">            Date nextExecuteTime = cronTrigger.nextExecutionTime(triggerContext);</span><br><span class="line">            <span class="keyword">return</span> nextExecuteTime;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改默认的定时任务时间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskCron</span><span class="params">(String taskCron)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskCron = taskCron;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心方法是 <code>scheduledTaskRegistrar.addTriggerTask</code>，它只接收两个参数，分别是调度任务实例(Runable实例)，Trigger实例。如果想修改定时任务的时间，其实修改的就是这里的<code>nextExecutionTime</code>，返回下次执行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/dynamic/job&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicJobController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DynamicCronJob dynamicCronJob;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DynamicTimedTask dynamicTimedTask;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/execute&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> NewResponseModel&lt;?&gt; execute(<span class="meta">@RequestParam(value = &quot;cron&quot;, defaultValue = &quot;0/10 * * * * ?&quot;)</span> String cron) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;修改任务执行时间，cron=&#123;&#125;&quot;</span>, cron);</span><br><span class="line">        dynamicCronJob.setTaskCron(cron);</span><br><span class="line">        <span class="keyword">return</span> NewResponseModel.Success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们的一个测试类，是通过请求，修改定时任务时间。</p><p>下面是测试结果，一开始默认每个5秒打印一次任务，然后将任务周期改为10秒。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210724141728.png"></p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>这种方法存在一种缺陷，就是修改周期后，需要下一次执行后才能生效，比如一开始的定时任务是每隔5分钟执行一次，但是现在你想修改执行频率为10秒执行一次，修改后的执行频率，并不会马上生效，需要在最近一次执行后，才会生效。下面是我做的一个测试。我们可以看到，修改后的，是在下一次执行后才生效。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210724145505.png"></p><h3 id="方法二：动态提交任务并修改任务执行周期"><a href="#方法二：动态提交任务并修改任务执行周期" class="headerlink" title="方法二：动态提交任务并修改任务执行周期"></a>方法二：动态提交任务并修改任务执行周期</h3><p>使用 <code>ThreadPoolTaskScheduler</code> 可以实现动态添加删除功能，实现动态修改任务执行周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicTimedTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**表示是否存在上一次任务*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受任务的返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 执行任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cron 执行频率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startCron</span><span class="params">(Runnable task, String cron)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 停止上一次定时任务</span></span><br><span class="line">        stopCron();</span><br><span class="line">        <span class="comment">//从数据库动态获取执行周期</span></span><br><span class="line">        future = threadPoolTaskScheduler.schedule(task, <span class="keyword">new</span> CronTrigger(cron));</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;start cron task success&quot;</span>);</span><br><span class="line">            start = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;没有上一次任务&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> cancel = future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (cancel) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;start cron task success&quot;</span>);</span><br><span class="line">            start = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类主要通过 <code>startCron</code> 提交了一个新的任务。在开始任务之前，先停止执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSampleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SimpleSampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">threadPoolTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler executor = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        executor.setPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;taskExecutor-test-&quot;</span>);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类里，主要是开启 <code>@EnableScheduling</code> 定时任务，和自定义 <code>ThreadPoolTaskScheduler</code>。</p><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/dynamic/job&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicJobController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DynamicCronJob dynamicCronJob;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DynamicTimedTask dynamicTimedTask;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/execute/task&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> NewResponseModel&lt;?&gt; executeTask(<span class="meta">@RequestParam(value = &quot;cron&quot;, defaultValue = &quot;0/10 * * * * ?&quot;)</span> String cron) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;修改执行任务，并执行时间，cron=&#123;&#125;&quot;</span>, cron);</span><br><span class="line">        dynamicTimedTask.startCron(() -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;模拟执行任务，cron=&#123;&#125;&quot;</span>, cron);</span><br><span class="line">                &#125;,</span><br><span class="line">                cron);</span><br><span class="line">        <span class="keyword">return</span> NewResponseModel.Success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210724143429.png"></p><p>进一步优化，比如我们把所有的任务，存储到 <code>ConcurrentHashMap&lt;String, ScheduledFuture&gt;</code>，我们只需要调用对应的key，然后通过map去除对应的定时任务，取消任务。</p><p>这种方法，并不存在方法一所存在的问题。在修改cron后，在最近的一次就立刻生效了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210724150248.png"></p><p>从上图中可以看到，一开始是每个10秒一次执行，然后修改成每个3秒执行一次，cron 直接生效了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程 —— 线程池源码解析</title>
      <link href="java-thread-pool-source/"/>
      <url>java-thread-pool-source/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇线程池，可以大致了解关于线程池的概念以及运行过程。 <a href="https://jlj98.top/java-thread-pool/">Java 线程池</a></p><h2 id="线程池常量"><a href="#线程池常量" class="headerlink" title="线程池常量"></a>线程池常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记线程池昨天，默认RUNNING</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 线程个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 线程最大个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor-execute"><a href="#ThreadPoolExecutor-execute" class="headerlink" title="ThreadPoolExecutor#execute"></a>ThreadPoolExecutor#execute</h2><p>execute（Runnable command） 方法是提交任务到线程池执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取当前线程池的状态+线程个数遍历组合值</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程池小于核心线程池，开启新线程执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池处于RUNNING，将任务添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了，创建非核心线程执行任务，如果失败，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这块代码的逻辑就是线程池如何处理新任务的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 循环CAS 增加线程数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 调用 w.run，实际调用 runWorker方法</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>addWorker() 方法中参数 core 表明当前任务是绑定核心线程还是非核心线程。</p><h2 id="非核心线程池回收"><a href="#非核心线程池回收" class="headerlink" title="非核心线程池回收"></a>非核心线程池回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 判断当前活跃线程数是否大于最大线程数 || 允许超时 || 上次超时获取到的线程为null，接着判断 如果 wc &gt;1 或队列为空，则将线程数减1，并且返回一个null的task</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>timed = true</code> 时，会执行 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 方法。而 timed 的判断是在 <code> boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</code>，<code>allowCoreThreadTimeOut</code> 默认 false，所以看 <code>wc &gt; corePoolSize</code> 条件了，wc 是活跃线程数，表达式的意思是判断活跃线程数&gt;核心线程数。</p><p>如果当前活跃线程数大于核心线程数，给定 <code>keepAliveTime</code> 时间等待获取队列任务，如果获取不到，返回null；否则直接从队列中获取任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取task,在这里调用 getTask 方法，获取任务，如果获取不到任务，则执行 processWorkerExit 方法处理线程退出</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当获取不到任务的时候，执行</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线程获取不到 tasks，就调用 processWorkerExit 方法，处理线程退出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 执行remove操作，线程回收</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于线程池中的线程，是没有核心线程和非核心线程的区别，只有当前工作线程。线程池对于非核心线程的回收，只是判断当前工作线程是否大于核心线程。所以，当工作线程大于核心线程数之后，所以的线程都是 poll，也就是说，所以线程都可能被回收。</p><p>总结：在 runWorker 执行任务时，会循环从队列中获取任务（getTask），当活跃线程大于核心线程时，就会设置过期超时时间获取队列任务，否则会直接获取队列任务。当获取不到任务时，就会执行线程退出任务，这时候，就会把多余的线程删除。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/huangjuncong/p/10031525.html">线程池源码分析</a></li><li><a href="https://mp.weixin.qq.com/s/1-h5AHhJYin9c9G_ozdJqQ">线程池非核心线程回收</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 自动装配</title>
      <link href="spring-boot-auto-configuration/"/>
      <url>spring-boot-auto-configuration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>spring boot 源码版本 2.0.9.RELEASE。spring boot 高版本，没有走AutoConfigurationImportSelector#selectImports方法。</p></blockquote><h2 id="Spring-Boot-自动装配"><a href="#Spring-Boot-自动装配" class="headerlink" title="Spring Boot 自动装配"></a>Spring Boot 自动装配</h2><p>先看下Spring Boot 启动类注释 @SpringBootApplication。在这些注解中，重要的就是两个 <code>@SpringBootConfiguration</code> 和 <code>@EnableAutoConfiguration</code>。从下图可以看到该注解是个组合注解，本文关于自动装配，用了到里面的 <code>@EnableAutoConfiguration</code> 里面的 <code>@Import(AutoConfigurationImportSelector.class)</code>。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410191336.png"></p><p><code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code> 主要功能就是自动配置导入选择器。</p><h3 id="AutoConfigurationImportSelector-selectImports"><a href="#AutoConfigurationImportSelector-selectImports" class="headerlink" title="AutoConfigurationImportSelector#selectImports"></a>AutoConfigurationImportSelector#selectImports</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">// 所以的配置存放在configuration中，获取所有依赖的配置</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>AnnotationMetadata：SpringBoot启动类上的注释的全限定名，比如 <code>@com.springboot.sample.starter.annotation.EnableSampleServer()</code></li><li>AutoConfigurationMetadata：依赖的AutoConfiguration类的元数据</li></ul><h3 id="AutoConfigurationImportSelector-getCandidateConfigurations"><a href="#AutoConfigurationImportSelector-getCandidateConfigurations" class="headerlink" title="AutoConfigurationImportSelector#getCandidateConfigurations"></a>AutoConfigurationImportSelector#getCandidateConfigurations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，<code>SpringFactoriesLoader.loadFactoryNames()</code> 传入的参数有个 <code>getSpringFactoriesLoaderFactoryClass</code>，其实技术我们熟悉的 <code>EnableAutoConfiguration</code> 注释。</p><p>这里的逻辑就是通过 <code>SpringFactoriesLoader.loadFactoryNames()</code> 查询 configurations，如果没有查到，就打印日志。从日志中可以看出，实际需要需要加载的 Configuration 就是从 <code>META-INF/spring.factories</code> 中去加载的。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410194352.png"></p><h3 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader#loadFactoryNames()"></a>SpringFactoriesLoader#loadFactoryNames()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 从 META-INF/spring.factories 中加载 Conguration</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line"><span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryClassName, factoryName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410194522.png"></p><p>从断点出可以看出，实际加载的就是 <code>EnableAutoConfiguration</code>的值。然后通过 <code>Properties properties = PropertiesLoaderUtils.loadProperties(resource);</code> 将文件内的内容封装成 <code>Properties</code> 对象。下图所加载的类就是一个自制的 spring boot starter 启动类。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410195139.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 启动会加载大量的启动类，会去搜索 <code>META-INF/spring.factories</code> 中的 <code>EnableAutoConfiguration</code> 的启动配置。</p><h2 id="如何自己自作-Spring-Boot-Starter-依赖"><a href="#如何自己自作-Spring-Boot-Starter-依赖" class="headerlink" title="如何自己自作 Spring Boot Starter 依赖"></a>如何自己自作 Spring Boot Starter 依赖</h2><p>先看下项目结构：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410195707.png"></p><h3 id="MonitorProperties"><a href="#MonitorProperties" class="headerlink" title="MonitorProperties"></a>MonitorProperties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;demo.monitor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loginUrl;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String serverUrl;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就是我们在使用这个starter类，需要在配置文件中配置的参数</p><h3 id="MonitorAutoConfiguration"><a href="#MonitorAutoConfiguration" class="headerlink" title="MonitorAutoConfiguration"></a>MonitorAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(SampleMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MonitorProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MonitorProperties monitorProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MonitorService <span class="title">monitorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MonitorService(monitorProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己制作 Configuration。@ConditionalOnBean 的含义是只有当 <code>SampleMarkerConfiguration.Marker</code> 这个 Bean 存在的时候，才会实现这个 Configuration，不然是不会初始化的。<code> @ConditionalOnMissingBean</code> 注解的含义是当不存在 <code>MonitorService</code> 这个Bean 的时候，进行创建Bean。</p><h3 id="SampleMarkerConfiguration"><a href="#SampleMarkerConfiguration" class="headerlink" title="SampleMarkerConfiguration"></a>SampleMarkerConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleMarkerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Marker <span class="title">sampleServerMarkerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类其实就是一个激活 <code>MonitorAutoConfiguration</code> 的类。</p><h3 id="EnableSampleServer"><a href="#EnableSampleServer" class="headerlink" title="EnableSampleServer"></a>EnableSampleServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(SampleMarkerConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableSampleServer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注释就是放在SpringBoot上，作为启动的激活的一个标识。</p><h3 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210410200533.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在需要的项目中引入starter依赖，在 Spring Boot 上加上 <code>@EnableSampleServer</code> 初始化类，这样就可以使用了。</p><blockquote><p>starter中的具体业务逻辑或者功能，可以自己根据实际需求自己添加。</p></blockquote><p><a href="https://github.com/tedburner/spring-boot-examples">Spring Boot Starter Demo</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.yuque.com/zzuli-tree/my6a8r/lkk3a0">Springboot 的自动装配原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 自动装配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码分析之服务导出</title>
      <link href="dubbo-export-service/"/>
      <url>dubbo-export-service/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码版本是 2.7.8</p></blockquote><p>Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析。</p><p>在 2.7.8 版本中，服务导出的入口已经在 <code>DubboBootstrapApplicationListener</code> <code>onApplicationContextEvent</code>方法是在 <code>onApplicationEvent</code>中引用的，onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷事件后执行服务导出操作。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201122133305.png"></p><p>在DubboBootstrap.start调用中，会调用一个exportServices方法，这个方法中，会调用 export 方法，这是就开始服务导出流程了。</p><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init serviceMetadata 初始化服务元数据</span></span><br><span class="line">    serviceMetadata.setVersion(getVersion());</span><br><span class="line">    serviceMetadata.setGroup(getGroup());</span><br><span class="line">    serviceMetadata.setDefaultGroup(getGroup());</span><br><span class="line">    serviceMetadata.setServiceType(getInterfaceClass());</span><br><span class="line">    serviceMetadata.setServiceInterfaceName(getInterface());</span><br><span class="line">    serviceMetadata.setTarget(getRef());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不允许暴露，直接放过 &lt;dubbo:provider export=&quot;false&quot; /&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要延迟，则延迟暴露</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">        DELAY_EXPORT_EXECUTOR.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接暴露</span></span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">    exported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceConfig.export是继承重写了父类ServiceConfigBase.export方法。在export方法中，主要是以下逻辑：</p><ul><li>检测 <a href="dubbo:service">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li><li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。</li><li>检测并处理泛化服务和普通服务类</li><li>检测本地存根配置，并进行相应的处理</li><li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常</li><li>主要是初始化服务元数据</li><li>对export配置项进行检查，判断是否需要导出服务</li><li>如果需要延迟，则延迟导出，否则直接导出服务</li></ul><h3 id="doExport"><a href="#doExport" class="headerlink" title="doExport"></a>doExport</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; has already unexported!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exported = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点关注</span></span><br><span class="line">    doExportUrls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法没啥逻辑，前面是一些校验，重点关注doExportUrls方法。</p><h3 id="doExportUrls"><a href="#doExportUrls" class="headerlink" title="doExportUrls"></a>doExportUrls</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">    ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">    repository.registerProvider(</span><br><span class="line">            getUniqueServiceName(),</span><br><span class="line">            ref,</span><br><span class="line">            serviceDescriptor,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            serviceMetadata</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 获取当前服务的注册中心，可以有多个服务中心</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// // 遍历 protocols，并在每个协议下导出服务</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        <span class="comment">// 凭借key，全限定名+group+version。类似 com.dubbo.api.service.AsyncService:1.0.0</span></span><br><span class="line">        String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                .map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">                .orElse(path), group, version);</span><br><span class="line">        <span class="comment">// In case user specified path, register service one more time to map it to path.</span></span><br><span class="line">        repository.registerService(pathKey, interfaceClass);</span><br><span class="line">        <span class="comment">// TODO, uncomment this line once service key is unified</span></span><br><span class="line">        serviceMetadata.setServiceKey(pathKey);</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持。从上面的代码中，可以知道，通过 loadRegistries 加载注册中心链接，然后再遍历 ProtocolConfig 集合导出每个服务。并在导出服务的过程中，将服务注册到注册中心。</p><p><code>ConfigValidationUtils.loadRegistries</code> 方法主要功能：</p><ul><li>检测是否存在注册中心配置类，不存在则抛出异常</li><li>构建参数映射集合，也就是 map</li><li>构建注册中心链接列表</li><li>遍历链接列表，并根据条件决定是否将其添加到 registryList 中</li></ul><h3 id="组装URL"><a href="#组装URL" class="headerlink" title="组装URL"></a>组装URL</h3><p>这个方法主要的功能是组装 URL。URL 是 Dubbo 配置的载体，通过 URL 可让 Dubbo 的各种配置在各个模块之间传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        name = DUBBO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据配置往map中塞值，构建URL</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line"></span><br><span class="line">    ServiceConfig.appendRuntimeParameters(map);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    <span class="comment">// remove &#x27;default.&#x27; prefix for configs from ProviderConfig</span></span><br><span class="line">    <span class="comment">// appendParameters(map, provider, Constants.DEFAULT_KEY);</span></span><br><span class="line">    AbstractConfig.appendParameters(map, provider);</span><br><span class="line">    AbstractConfig.appendParameters(map, protocolConfig);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    MetadataReportConfig metadataReportConfig = getMetadataReportConfig();</span><br><span class="line">    <span class="keyword">if</span> (metadataReportConfig != <span class="keyword">null</span> &amp;&amp; metadataReportConfig.isValid()) &#123;</span><br><span class="line">        map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(GENERIC_KEY, generic);</span><br><span class="line">        map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Here the token value configured by the provider is used to assign the value to ServiceConfig#token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.isEmpty(token) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        token = provider.getToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init serviceMetadata attachments</span></span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service</span></span><br><span class="line">    String host = findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    <span class="comment">// 构建URL</span></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。</p><p>上面在if判断中省略了一段代码。这段代码用于检测 <a href="dubbo:method">dubbo:method</a> 标签中的配置信息，并将相关配置添加到 map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (MethodConfig method : getMethods()) &#123;</span><br><span class="line">    AbstractConfig.appendParameters(map, method, method.getName());</span><br><span class="line">    String retryKey = method.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">        String retryValue = map.remove(retryKey);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(retryValue)) &#123;</span><br><span class="line">            map.put(method.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(arguments)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">            <span class="comment">// convert argument type</span></span><br><span class="line">            <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                <span class="comment">// visit all methods</span></span><br><span class="line">                <span class="keyword">if</span> (methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                        String methodName = methods[i].getName();</span><br><span class="line">                        <span class="comment">// target the method, and get its signature</span></span><br><span class="line">                        <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                            Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                            <span class="comment">// one callback in the method</span></span><br><span class="line">                            <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                    AbstractConfig.appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// multiple callbacks in the method</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                    Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                    <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                        AbstractConfig.appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + j);</span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                AbstractConfig.appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config must set index or type attribute.eg: &lt;dubbo:argument index=&#x27;0&#x27; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// end of methods for</span></span><br></pre></td></tr></table></figure><h2 id="导出服务"><a href="#导出服务" class="headerlink" title="导出服务"></a>导出服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码 ...</span></span><br><span class="line">    <span class="comment">// You can customize Configurator to append extra parameters</span></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">    <span class="comment">// don&#x27;t export when none is configured 当scope=none时，不进行服务暴露</span></span><br><span class="line">    <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">        <span class="comment">// 如果不是远程暴露，进行本地暴露。如果scope是null，则会进入分支，进行本地暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是本地暴露，进行远程暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="comment">// 如果有注册中心，进行远程暴露</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="comment">// 判断协议是否是 injvm，是的话，不进行注册了</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">// 如果有监控中心，则会添加之后向其汇报</span></span><br><span class="line">                    URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将具体实现类封装成 invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">// 包装转换成 exporter</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">            MetadataUtils.publishServiceDefinition(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码根据 url 中的 scope 参数决定服务导出方式，分别如下：</p><ul><li>scope = none，不导出服务</li><li>scope != remote，导出到本地</li><li>scope != local，导出到远程</li></ul><h3 id="Invoker-创建过程"><a href="#Invoker-创建过程" class="headerlink" title="Invoker 创建过程"></a>Invoker 创建过程</h3><h3 id="导出服务到本地"><a href="#导出服务到本地" class="headerlink" title="导出服务到本地"></a>导出服务到本地</h3><h3 id="导出服务到远程"><a href="#导出服务到远程" class="headerlink" title="导出服务到远程"></a>导出服务到远程</h3><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/export-service/">Apache Dubbo 服务导出</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码分析之 SPI 机制</title>
      <link href="dubbo-spi/"/>
      <url>dubbo-spi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码版本是 2.7.8</p></blockquote><p>在以前的文章中，介绍过 <a href="https://jlj98.top/java-spi/">Java SPI机制</a>，想了解的可以进去了解下。今天我们要讲的是 Dubbo SPI机制。</p><h2 id="Dubbo-SPI-实例"><a href="#Dubbo-SPI-实例" class="headerlink" title="Dubbo SPI 实例"></a>Dubbo SPI 实例</h2><p>本实例参考的是dubbo官方给的官方实例。</p><p>首先定义一个接口，名称Robot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个实现类，分别是 OptimusPrime 和 Bumblebee。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimusPrime</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bumblebee</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在<code>META-INF/dubbo</code>文件夹下创建一个文件，名称为Robot 的全限定名 <code>com.dubbo.provider.demo.Robot</code> (根据项目实际的全限定名)，文件配置内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure><p>接下来进入测试，在测试 Dubbo SPI时，需要在Robot接口上标注@SPI注解。下面是测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSpiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader =</span><br><span class="line">                ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201111221412.png"></p><h2 id="Dubbo-SPI-源码分析"><a href="#Dubbo-SPI-源码分析" class="headerlink" title="Dubbo SPI  源码分析"></a>Dubbo SPI  源码分析</h2><p>通过上面的简单实例演示，Dubbo 是通过 ExtensionLoader 的getExtensionLoader方法获取一个ExtensionLoader实例，然后再通过ExtensionLoader的getExtension方法获取扩展类对象。</p><h3 id="ExtensionLoader-属性"><a href="#ExtensionLoader-属性" class="headerlink" title="ExtensionLoader 属性"></a>ExtensionLoader 属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name参数分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NAME_SEPARATOR = Pattern.compile(<span class="string">&quot;\\s*[,]+\\s*&quot;</span>);</span><br><span class="line"><span class="comment">// 扩展类加载缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"><span class="comment">// 扩展类实例缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"><span class="comment">// type 变量是在调用 getExtensionLoader 方法时传入的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line"><span class="comment">// 存储Class-名称的映射关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 缓存已加载的扩展类，key为配置文件中=前面部分，value是=后面类的实例化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LoadingStrategy[] strategies = loadLoadingStrategies();</span><br></pre></td></tr></table></figure><h3 id="getExtensionLoader"><a href="#getExtensionLoader" class="headerlink" title="getExtensionLoader"></a>getExtensionLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略... 参数校验，校验参数非空，以及是接口类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验接口是否携带SPI注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// EXTENSION_LOADERS是一个Map&lt;class, ExtensionLoader&gt;，从缓存中获取ExtensionLoader，如果获取不到，则穿件一个新的实例</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExtensionLoader.getExtensionLoader</code> 用于从缓存中获取与扩展类对应的ExtensionLoader，若缓存没命中，则创建一个新的实例。</p><h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getExtension(name, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**name就是配置文件中的key，wrap标识是否包装*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略校验...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Holder，用于持有目标对象。获取一个默认的Holder，如果缓存中存在，直接获取，否则添加一个缓存</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="comment">//双重检测实现单例</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建扩展实例</span></span><br><span class="line">                instance = createExtension(name, wrap);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getDefaultExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cachedDefaultName) || <span class="string">&quot;true&quot;</span>.equals(cachedDefaultName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getExtension(cachedDefaultName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑比较清晰，首先检测缓存，如果缓存未命中则创建扩展类对象。</p><h3 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中加载所需的扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取实例</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过反射创建实例</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">                        <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化扩展类</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension 的逻辑步骤如下：</p><ul><li>通过 getExtensionClasses 获取所有扩展类</li><li>通过反射创建扩展对象</li><li>Wrapper 对象中</li><li>将扩展对象包裹在相应的 Wrapper 对象中</li></ul><p>后面两步，是dubbo ioc 和 aop 的具体实现。</p><h3 id="getExtensionClasses"><a href="#getExtensionClasses" class="headerlink" title="getExtensionClasses"></a>getExtensionClasses</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从配置文件中加载所需的扩展类，可得到 Map&lt;配置项名称, 配置类的映射&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 先从缓存中拿去配置，如果没有，单例实现从加载配置文件获取所需的扩展类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从配置文件中加载所需扩展</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadExtensionClasses"><a href="#loadExtensionClasses" class="headerlink" title="loadExtensionClasses"></a>loadExtensionClasses</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 设置默认扩展名称</span></span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从下面的文件中加载指定的配置文件</span></span><br><span class="line">    <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取SPI注解，这里的type变量是在调用 getExtensionLoader 方法时传入的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheDefaultExtensionName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String value = defaultAnnotation.value();</span><br><span class="line">    <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 对 SPI 注解的内容进行切分</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">        <span class="comment">// 检测 SPI 注解内容是否合法，不合法抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;More than 1 default extension name on extension &quot;</span> + type.getName()</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + Arrays.toString(names));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置默认名称，参考 getDefaultExtension 方法</span></span><br><span class="line">        <span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">            cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadDirectory"><a href="#loadDirectory" class="headerlink" title="loadDirectory"></a>loadDirectory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> extensionLoaderClassLoaderFirst, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fileName = 文件路径+type 全限定名</span></span><br><span class="line">    String fileName = dir + type;</span><br><span class="line">    Enumeration&lt;java.net.URL&gt; urls = <span class="keyword">null</span>;</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to load from ExtensionLoader&#x27;s ClassLoader first</span></span><br><span class="line">    <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">        ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">            urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (urls == <span class="keyword">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">        <span class="comment">// 根据文件名架子啊所以的同名文件</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">            <span class="comment">// 加载资源</span></span><br><span class="line">            loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadResource"><a href="#loadResource" class="headerlink" title="loadResource"></a>loadResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          java.net.URL resourceURL, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位 # 字符</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以等于号 = 为界，截取键与值</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span> &amp;&amp; !isExcluded(line, excludedPackages)) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name, overridden);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadResource 方法主要用于读取和解析配置文件，并通过反射架子啊类，最后调用 loadClass 方法进行其他操作。</p><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于读取和解析配置文件，并通过反射加载类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测目标类上是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">        <span class="comment">// 程序进入此分支，表明 clazz 是一个普通的拓展类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为 name</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切分 name</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadClass 方法操作了不同的缓存，比如 cachedAdaptiveClass、cachedWrapperClasses 和 cachedNames 等等</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://dubbo.apache.org/zh-cn/docs/2.7/source_code_guide/dubbo-spi/">Apace Dubbo Dubbo SPI</a></li><li>《深入理解Apace Dubbo 实战》</li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> spi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码分析之Registry注册中心</title>
      <link href="dubbo-registry/"/>
      <url>dubbo-registry/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码版本是 2.7.8</p></blockquote><h2 id="什么是注册中心？"><a href="#什么是注册中心？" class="headerlink" title="什么是注册中心？"></a>什么是注册中心？</h2><p>服务治理框架中大致分为服务通信和服务管理两部分，服务管理可以分为服务注册、服务发现以及服务被热加工介入，服务提供者Provider会往注册中心注册服务，而消费者Consumer会从注册中心订阅相关服务，并不会订阅全部的服务。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201106135956.png"></p><h2 id="dubbo-registry-模块"><a href="#dubbo-registry-模块" class="headerlink" title="dubbo-registry 模块"></a>dubbo-registry 模块</h2><p>在dubbo中，注册中心相关的代码在<code>dubbo-registry</code>模块下，子模块<code>dubbo-registry-api</code>中定义了注册中心相关的基础代码，而在<code>dubbo-registry-xxx</code>模块中则定义了具体的注册中心类型实现代码，例如<code>dubbo-registry-zookeeper</code>模块则存放了zookeeper注册中心的实现代码。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201106135758.png"></p><p>类关系图：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201106140026.png"></p><h3 id="dubbo-registry-api-相关实现"><a href="#dubbo-registry-api-相关实现" class="headerlink" title="dubbo-registry-api 相关实现"></a>dubbo-registry-api 相关实现</h3><p>通过Registry的实现管理，分析下面各个接口类：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201106140115.png"></p><h4 id="RegistryService"><a href="#RegistryService" class="headerlink" title="RegistryService"></a>RegistryService</h4><p>注册中心模块的服务接口，提供注册、取消注册、订阅、取消订阅、查询符合条件的已注册数据。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201107151010.png"></p><p>下面的注释，是官方的解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *注册服务</span></span><br><span class="line"><span class="comment">    * 注册需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 当URL设置了check=false时，注册失败后不报错，在后台定时重试，否则抛出异常。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 当URL设置了dynamic=false参数，则需持久存储，否则，当注册者出现断电等情况异常退出时，需自动删除。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 当URL设置了category=overrides时，表示分类存储，缺省类别为providers，可按分类部分通知数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 当注册中心重启，网络抖动，不能丢失数据，包括断线自动删除数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册服务.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 取消注册需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 如果是dynamic=false的持久存储数据，找不到注册数据，则抛IllegalStateException，否则忽略。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 按全URL匹配取消注册。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅服务.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 订阅需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 当URL设置了check=false时，订阅失败后不报错，在后台定时重试。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 当URL设置了category=overrides，只通知指定分类的数据，多个分类用逗号分隔，并允许星号通配，表示订阅所有分类数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 允许以interface,group,version,classifier作为条件查询，如：interface=com.alibaba.foo.BarService&amp;version=1.0.0&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 并且查询条件允许星号通配，订阅所有接口的所有分组的所有版本，或：interface=*&amp;group=*&amp;version=*&amp;classifier=*&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 当注册中心重启，网络抖动，需自动恢复订阅请求。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 6. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 7. 必须阻塞订阅过程，等第一次通知完后再返回。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅服务.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 取消订阅需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 如果没有订阅，直接忽略。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 按全URL匹配取消订阅。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询注册列表，与订阅的推模式相对应，这里为拉模式，只返回一次结果。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.registry.NotifyListener#notify(List)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 已注册信息列表，可能为空，含义同&#123;<span class="doctag">@link</span> org.apache.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;的参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node 接口不是registry中，而是在common模块中的一个接口。Node 接口中主要声明了一些节点的操作方法，获取节点Url、是否可用、销毁节点。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201107151739.png"></p><h4 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h4><p>Registry 接口主要是继承了 Node 接口和 RegistryService 接口，将这两个接口的内容都统一在一起。同时 Registry 接口也提供了两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span> <span class="keyword">extends</span> <span class="title">Node</span>, <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**再次暴露注册*/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">reExportRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        register(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**再次取消注册*/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">reExportUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        unregister(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractRegistry"><a href="#AbstractRegistry" class="headerlink" title="AbstractRegistry"></a>AbstractRegistry</h4><p>AbstractRegistry 实现 Registry 接口，实现了接口中定义的注册、订阅等方法。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201107152931.png"></p><h5 id="抽象类的属性"><a href="#抽象类的属性" class="headerlink" title="抽象类的属性"></a>抽象类的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 地址分隔符，用于文件缓存，服务提供成功url分隔</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> URL_SEPARATOR = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// URL 地址分隔的正则表达式，用于分析文件缓存中的服务提供程序URL列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_SPLIT = <span class="string">&quot;\\s+&quot;</span>;</span><br><span class="line"><span class="comment">// Max times to retry to save properties to local cache file</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRY_TIMES_SAVE_PROPERTIES = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Log output</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="comment">// 本地磁盘缓存，其中的特殊key为registies是记录注册表中心列表，其他是已通知服务提供商的列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 文件缓存写入执行器 提供一个线程的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;DubboSaveRegistryCache&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line"><span class="comment">// 是否同步保存文件标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> syncSaveFile;</span><br><span class="line"><span class="comment">// 缓存的版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastCacheChanged = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger savePropertiesRetryTimes = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 已经注册的URL集合，不仅仅服务提供者，也注册服务消费者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; registered = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 已订阅 URL，value是监听器集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 消费者或者服务治理服务获取注册信息后的缓存对象。内存中服务器缓存的notified对象是ConcurrentHashMap里面嵌套了一个Map，</span></span><br><span class="line"><span class="comment">// 外层Map的Key是消费者的URL，内层的Map的key是分类，包括provider，consumer，routes，configurators四种，value则对应服务列表，没有服务提供者提供服务的URL，会以一个特别的empty://前缀开头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 注册中心的URL</span></span><br><span class="line"><span class="keyword">private</span> URL registryUrl;</span><br><span class="line"><span class="comment">// 本地磁盘缓存文件保存的是注册中心的数据</span></span><br><span class="line"><span class="keyword">private</span> File file;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这只注册中心的地址URL</span></span><br><span class="line">    setUrl(url);</span><br><span class="line">    <span class="comment">// 当file.cache参数为true时，即开启本地文件缓存，加载本地文件中的参数</span></span><br><span class="line">    <span class="keyword">if</span> (url.getParameter(REGISTRY__LOCAL_FILE_CACHE_ENABLED, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        syncSaveFile = url.getParameter(REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);</span><br><span class="line">        String defaultFilename = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/.dubbo/dubbo-registry-&quot;</span> + url.getParameter(APPLICATION_KEY) + <span class="string">&quot;-&quot;</span> + url.getAddress().replaceAll(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;-&quot;</span>) + <span class="string">&quot;.cache&quot;</span>;</span><br><span class="line">        String filename = url.getParameter(FILE_KEY, defaultFilename);</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid registry cache file &quot;</span> + file + <span class="string">&quot;, cause: Failed to create directory &quot;</span> + file.getParentFile() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">        <span class="comment">// 加载文件中的参数放到Properties，Properties继承HashTable。</span></span><br><span class="line">        loadProperties();</span><br><span class="line">        <span class="comment">// 通知监视器URL变化</span></span><br><span class="line">        notify(url.getBackupUrls());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.exists()) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Load registry cache file &quot;</span> + file + <span class="string">&quot;, data: &quot;</span> + properties);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failed to load registry cache file &quot;</span> + file, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h5><p>获取消费者URL订阅的服务URL列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取注册信息中分类服务列表信息</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; notifiedUrls = getNotified().get(url);</span><br><span class="line">    <span class="comment">// 如果该服务订阅了服务</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(notifiedUrls)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;URL&gt; urls : notifiedUrls.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!EMPTY_PROTOCOL.equals(u.getProtocol())) &#123;</span><br><span class="line">                    result.add(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有订阅服务，获取注册中心的最新的注册服务URL</span></span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;List&lt;URL&gt;&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">// 通知监听器，当收到服务变更时触发</span></span><br><span class="line">        NotifyListener listener = reference::set;</span><br><span class="line">        <span class="comment">// 添加服务的监听器</span></span><br><span class="line">        subscribe(url, listener);</span><br><span class="line">        List&lt;URL&gt; urls = reference.get();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(urls)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!EMPTY_PROTOCOL.equals(u.getProtocol())) &#123;</span><br><span class="line">                    result.add(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="register-and-unregister"><a href="#register-and-unregister" class="headerlink" title="register and unregister"></a>register and unregister</h5><p>URL 注册和取消注册，代码的主要逻辑就是从registered的内存缓存中添加或者删除URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;register url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Register: &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    registered.add(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;unregister url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Unregister: &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    registered.remove(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(urls)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历已订阅URL匹配当前URL</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : getSubscribed().entrySet()) &#123;</span><br><span class="line">        URL url = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span> (!UrlUtils.isMatch(url, urls.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notify(url, listener, filterEmpty(url, urls));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Failed to notify registry event, urls: &quot;</span> + urls + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Notify changes from the Provider side.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url      consumer side url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener listener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> urls     provider latest urls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify listener == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((CollectionUtils.isEmpty(urls))</span><br><span class="line">            &amp;&amp; !ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Ignore empty notify urls for subscribe url &quot;</span> + url);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Notify urls for subscribe url &quot;</span> + url + <span class="string">&quot;, urls: &quot;</span> + urls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个服务提供URL进行分类</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">            String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);</span><br><span class="line">            List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category = entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        <span class="comment">// 通知监听器</span></span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">        <span class="comment">// 保存一份到文件缓存中</span></span><br><span class="line">        saveProperties(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FailbackRegistry"><a href="#FailbackRegistry" class="headerlink" title="FailbackRegistry"></a>FailbackRegistry</h4><p>FailbackRegistry 是继承AbstractRegistry，增加了失败重试的机制作为抽象能力，后面不同的注册中心具体实现继承了这个类，就可以直接使用这个能力。</p><h5 id="抽象类的属性-1"><a href="#抽象类的属性-1" class="headerlink" title="抽象类的属性"></a>抽象类的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册失败集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, FailedRegisteredTask&gt; failedRegistered = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, FailedRegisteredTask&gt;();</span><br><span class="line"><span class="comment">// 取消注册失败集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, FailedUnregisteredTask&gt; failedUnregistered = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, FailedUnregisteredTask&gt;();</span><br><span class="line"><span class="comment">// 订阅失败集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Holder, FailedSubscribedTask&gt; failedSubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;Holder, FailedSubscribedTask&gt;();</span><br><span class="line"><span class="comment">// 取消订阅集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Holder, FailedUnsubscribedTask&gt; failedUnsubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;Holder, FailedUnsubscribedTask&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The time in milliseconds the retryExecutor will wait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retryPeriod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer for failure retry, regular check if there is a request for failure, and if there is, an unlimited retry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer retryTimer;</span><br></pre></td></tr></table></figure><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FailbackRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">this</span>.retryPeriod = url.getParameter(REGISTRY_RETRY_PERIOD_KEY, DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since the retry task will not be very much. 128 ticks is enough.</span></span><br><span class="line">    retryTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;DubboRegistryRetryTimer&quot;</span>, <span class="keyword">true</span>), retryPeriod, TimeUnit.MILLISECONDS, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="register"><a href="#register" class="headerlink" title="register"></a>register</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!acceptable(url)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;URL &quot;</span> + url + <span class="string">&quot; will not be registered to Registry. Registry &quot;</span> + url + <span class="string">&quot; does not accept service of this protocol type.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        removeFailedRegistered(url);</span><br><span class="line">        removeFailedUnregistered(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用具体的注册中心，比如Zookeeper</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + getUrl().getAddress() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot;, waiting for retry, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存注册失败的URL</span></span><br><span class="line">            addFailedRegistered(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另外的几个方法，unregister、subscribe、unsubscribe都类似，里面会调用一个doxxx方法，底层就是不同的注册中心具体实现方法。</p><h5 id="notify-1"><a href="#notify-1" class="headerlink" title="notify"></a>notify</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;notify listener == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doNotify(url, listener, urls);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">        <span class="comment">// Record a failed registration request to a failed list</span></span><br><span class="line">        logger.error(<span class="string">&quot;Failed to notify addresses for subscribe &quot;</span> + url + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的notify方法</span></span><br><span class="line">    <span class="keyword">super</span>.notify(url, listener, urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RegistryFactory"><a href="#RegistryFactory" class="headerlink" title="RegistryFactory"></a>RegistryFactory</h4><p>RegistryFactory 接口定义只有一个getRegistry方法。URL 为dubbo封装的统一资源定位符，其中定义了协议protocol、用户名username、密码password、host主机、path路径等等属性。</p><p>RegistryFactory 是一个工厂方法，根据具体的注册协议，比如zookeeper，获取具体的注册中心实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接注册中心.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 连接注册中心需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 支持URL上的username:password权限认证。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 支持backup=10.20.153.10备选注册中心集群地址。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 支持file=registry.cache本地磁盘文件缓存。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 支持timeout=1000请求超时设置。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 6. 支持session=60000会话超时或过期设置。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址，不允许为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注册中心引用，总不返回空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;&quot;protocol&quot;&#125;)</span></span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NotifyListener"><a href="#NotifyListener" class="headerlink" title="NotifyListener"></a>NotifyListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当收到服务变更通知时触发。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 通知需处理契约：&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 1. 总是以服务接口和数据类型为维度全量通知，即不会通知一个服务的同类型的部分数据，用户不需要对比上一次通知结果。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 2. 订阅时的第一次通知，必须是一个服务的所有类型数据的全量通知。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 3. 中途变更时，允许不同类型的数据分开通知，比如：providers, consumers, routes, overrides，允许只通知其中一种类型，但该类型的数据必须是全量的，不是增量的。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 4. 如果一种类型的数据为空，需通知一个empty协议并带category参数的标识性URL数据。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 5. 通知者(即注册中心实现)需保证通知的顺序，比如：单线程推送，队列串行化，带版本对比。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls 已注册信息列表，总不为空，含义同&#123;<span class="doctag">@link</span> org.apache.dubbo.registry.RegistryService#lookup(URL)&#125;的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addServiceListener</span><span class="params">(ServiceInstancesChangedListener instanceListener)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dubbo-registry-zookeeper"><a href="#dubbo-registry-zookeeper" class="headerlink" title="dubbo-registry-zookeeper"></a>dubbo-registry-zookeeper</h3><p>对于dubbo的注册中心，这里只介绍下zookeeper，这个也是dubbo默认的注册中心。</p><h4 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dubbo 在zookeeper注册中默认的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">&quot;dubbo&quot;</span>;</span><br><span class="line"><span class="comment">// 组的名称 或者说是 根节点的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br><span class="line"><span class="comment">// 服务集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; anyServices = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// zk 的监听器，&lt;URL，Map&lt;监听器，&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// zk 客户端</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ZookeeperClient zkClient;</span><br></pre></td></tr></table></figure><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类FailbackRegistry的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registry address == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取组名称并赋值给root</span></span><br><span class="line">    String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    <span class="keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;</span><br><span class="line">        group = PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">// 连接 Zookeeper</span></span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">//添加连接状态监听器</span></span><br><span class="line">    zkClient.addStateListener((state) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Trying to fetch the latest urls, in case there&#x27;re provider changes during connection loss.\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; Since ephemeral ZNode will not get deleted for a connection lose, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;there&#x27;s no need to re-register url of this instance.&quot;</span>);</span><br><span class="line">            ZookeeperRegistry.<span class="keyword">this</span>.fetchLatestAddresses();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == StateListener.NEW_SESSION_CREATED) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Trying to re-register urls and re-subscribe listeners of this instance to registry...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ZookeeperRegistry.<span class="keyword">this</span>.recover();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == StateListener.SESSION_LOST) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Url of this instance will be deleted from registry soon. &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Dubbo client will try to re-register once a new session is created.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == StateListener.SUSPENDED) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == StateListener.CONNECTED) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="服务注册发布和下线取消注册"><a href="#服务注册发布和下线取消注册" class="headerlink" title="服务注册发布和下线取消注册"></a>服务注册发布和下线取消注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// zk生成一个节点</span></span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除zk节点</span></span><br><span class="line">        zkClient.delete(toUrlPath(url));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to unregister &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://dubbo.apache.org/zh-cn/docs/2.7/dev/impls/registry/">Apache Dubbo 注册中心扩展</a></li><li>《深入理解Apace Dubbo 实战》</li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码分析之负载均衡</title>
      <link href="dubbo-loadbalance/"/>
      <url>dubbo-loadbalance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码版本是 2.7.8</p></blockquote><p>Dubbo 提供一下几种负载均衡</p><ul><li>RandomLoadBalance：加权随机算法</li><li>RoundRobinLoadBalance：加权轮询负载均衡</li><li>LeastActiveLoadBalance：最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。</li><li>ConsistentHashLoadBalance：一致性Hash负载均衡</li><li>ShortestResponseLoadBalance：最短响应负载均衡</li></ul><p>Dubbo 的负载均衡代码位于 <code>dubbo-cluster</code> 目录下。抽象类 <code>AbstractLoadBalance</code> 实现了 <code>LoadBalance</code>，然后dubbo提供的几种负载均衡方法，实现了<code>AbstractLoadBalance#doSelect</code></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201025215509.png"></p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(RandomLoadBalance.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive(&quot;loadbalance&quot;)</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡主要是从服务提供者列表中，选择一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) uptime / ((<span class="keyword">float</span>) warmup / (<span class="keyword">float</span>) weight));</span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;<span class="comment">//当只有一个提供者时，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择一个服务</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//具体的负载均衡策略由子类来实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权重方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> uptime = (<span class="keyword">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">                <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class="line">                <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weight &gt;= <span class="number">0</span> ? weight : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomLoadBalance-随机选择算法"><a href="#RandomLoadBalance-随机选择算法" class="headerlink" title="RandomLoadBalance (随机选择算法)"></a>RandomLoadBalance (随机选择算法)</h2><p>随机，按权重设置随机概率。在一个节点上碰撞的概率高，但是条用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者的权重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机返回一个权重</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">    <span class="comment">// 获取调用者数</span></span><br><span class="line">    <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">    <span class="comment">// 判断所有服务提供者地址权重是否一致</span></span><br><span class="line">    <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// the weight of every invokers</span></span><br><span class="line">    <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// the first invoker&#x27;s weight</span></span><br><span class="line">    <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">    weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">    <span class="comment">// The sum of weights</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">        <span class="comment">//数组保存服务提供者的权重，方便后续使用</span></span><br><span class="line">        weights[i] = weight;</span><br><span class="line">        totalWeight += weight;</span><br><span class="line">        <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">            sameWeight = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断总权重是否大于0以及是否所有权重一致</span></span><br><span class="line">    <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">         <span class="comment">//根据总权重生成一个随机数</span></span><br><span class="line">        <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">        <span class="comment">//随机数减去权重，当随机数小于0，返回当前权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            offset -= weights[i];</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机返回一个权重</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>通过累加计算总的权重，并判断所有的权重是否相等</li><li>如果总权重是0，或者所有的权重相等，则随机生成一个随机数，返回提供者</li><li>如果权重大于0且权重不相同，则在总权重范围内，随机生成一个随机数，循环减去之前保存的每个服务权重，当随机数小于0时，返回当前的服务提供者。</li></ul><h2 id="RoundRobinLoadBalance-加权轮询策略"><a href="#RoundRobinLoadBalance-加权轮询策略" class="headerlink" title="RoundRobinLoadBalance (加权轮询策略)"></a>RoundRobinLoadBalance (加权轮询策略)</h2><p>轮询，按公约后的权重设置轮询比例。所谓的轮询就是将请求轮流分配给每台服务器。轮询是一种无状态的负载均衡。通过对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。</p><p>轮询存在慢的提供者积累请求的问题，比如：第二台机器很慢，但是没挂掉，当请求调到第二台时，就卡在哪里，久而久之，所以请求都卡在调用的第二台上。<br>轮询，按公约后的权重设置轮询比例。存在慢的提供者积累请求的问题，比如：第二台机器很慢，但是没挂掉，当请求调到第二台时，就卡在哪里，久而久之，所以请求都卡在调用的第二台上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;roundrobin&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Collection&lt;String&gt; <span class="title">getInvokerAddrList</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        Map&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//value-&gt;map&#123;key:invoker的唯一标志 value:轮询权重相关类WeightedRoundRobin&#125;</span></span><br><span class="line">        <span class="comment">//methodWeightMap的value就是不同的invokers，如果为空则创建一个空的map</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">//总权重</span></span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE; <span class="comment">//当期最大权重</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;<span class="comment">//被选中的调用者</span></span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;<span class="comment">//被选中调用者所对应的权值类</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 如果换成中没有则进行创建</span></span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -&gt; &#123;</span><br><span class="line">                WeightedRoundRobin wrr = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                wrr.setWeight(weight);</span><br><span class="line">                <span class="keyword">return</span> wrr;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 如果url权重更新，则更新缓存中的权重值</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                <span class="comment">//weight changed</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前权值=当前权值+设置的权值</span></span><br><span class="line">            <span class="comment">//目的是获取最大的当前权值的提供者 作为调用使用</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">//获取全部中invoker中有效权值最大的那个提供者</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算总权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一段时间内没有访问，则去掉缓存中的记录重新计算</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() != map.size()) &#123;</span><br><span class="line">            map.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>循环遍历invokers，初始化对应invoker的缓存，更新weight和current</li><li>每次 current += weight，然后判断哪个invoker的current的权重最大</li><li>在 selectedInvoker不为null的情况下，最大权重的current减去总权重，返回selectedInvoker</li></ul><h2 id="LeastActiveLoadBalance-最少活跃调用数"><a href="#LeastActiveLoadBalance-最少活跃调用数" class="headerlink" title="LeastActiveLoadBalance(最少活跃调用数)"></a>LeastActiveLoadBalance(最少活跃调用数)</h2><p>活跃调用数越小，表明该服务提供者效率高，单位时间内可以处理更多的请求。在具体实现中，每个服务提供对应一个活跃数 active，初始情况下，所以服务提供者活跃为0，每收到一个请求，活跃数+1，完成请求+1。在运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;leastactive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;<span class="comment">//最小活跃数</span></span><br><span class="line">        <span class="comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];<span class="comment">//权重数组</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;<span class="comment">//总权重</span></span><br><span class="line">        <span class="comment">// 第一个最小活跃数的权重，用于与其他具有相同最小活跃数的 Invoker 的权重进行对比，</span></span><br><span class="line">        <span class="comment">// 以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;<span class="comment">// 所以最小活跃数的权重是否一样</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 invokers 列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取 Invoker 对应的活跃数</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="comment">// 获取invoke配置的权重值，默认100</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 数组保存权重，方便后面随机选择权重</span></span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// 发现最小活跃数，如果最小活跃数-1(第一个服务提供者)或者当前最小活跃小于最小活跃数</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 重置最小活跃数，设置为当前 Invoker 的最小活跃数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// 更新 leastCount 为 1</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录当前下标值到 leastIndexs 中</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="comment">// 更新总权重</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// Record the weight the first least active invoker</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// Each invoke has the same weight (only one invoker here)</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 Invoker 的活跃数 active 与最小活跃数 leastActive 相同</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加权重</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="comment">// 检测当前 Invoker 的权重与 firstWeight 是否相等，</span></span><br><span class="line">                <span class="comment">// 不相等则将 sameWeight 置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有多个Invoker具有相同的最小活跃数，但它们的权重不同</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据总权重随机生成一个[0, totalWeight)的数字</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让随机数减去具有最小活跃数的 Invoker，当offset小于0，返回相应的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果权重相同或者权重为0，随机返回一个 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>循环遍历 invokers 列表，寻找活跃数最小的 Invoker</li><li>如果多个 Invoker 具有相同的最小活跃数，此时记录下这些Invoker在invokers中的下标，并累加他们的权重，比较它们的权重值是否相同</li><li>如果只有一个Invoker具有最小活跃数，直接返回这个Invoker</li><li>如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 RandomLoadBalance 一致</li><li>如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可</li></ul><h2 id="ConsistentHashLoadBalance-一致性Hash算法"><a href="#ConsistentHashLoadBalance-一致性Hash算法" class="headerlink" title="ConsistentHashLoadBalance (一致性Hash算法)"></a>ConsistentHashLoadBalance (一致性Hash算法)</h2><p>相同参数请求总是落在同一台机器上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;consistenthash&quot;</span>;</span><br><span class="line"><span class="comment">//一个方法对应一个一个hash选择器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取调用方法名，一致性Hash选择器的key</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        <span class="comment">//基于invokers集合，根据对象内存地址来定义hash值</span></span><br><span class="line">        <span class="keyword">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class="line">        <span class="comment">//获取 ConsistentHashSelector</span></span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            <span class="comment">//初始化创建再缓存</span></span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//hash选择器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicaNumber;<span class="comment">//每个invoker对应的虚拟节点数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode; <span class="comment">//定义hash值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] argumentIndex;<span class="comment">//参数位置数组（缺省是第一个参数）</span></span><br><span class="line"></span><br><span class="line">        ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">            <span class="comment">//获取配置的节点数，默认160</span></span><br><span class="line">            <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class="string">&quot;hash.nodes&quot;</span>, <span class="number">160</span>);</span><br><span class="line">            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class="string">&quot;hash.arguments&quot;</span>, <span class="string">&quot;0&quot;</span>));<span class="comment">//获取需要进行hash的参数数组索引，默认对第一个参数进行hash</span></span><br><span class="line">            argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建虚拟节点，对每个invoker生成replicaNumber个虚拟节点，并放入到TreeMap中</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                String address = invoker.getUrl().getAddress();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">//根据MD5算法为每4个节点生成一个消息摘要，长为16字节128位</span></span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line">                    <span class="comment">//随机讲128位分成4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0</span></span><br><span class="line">                    <span class="comment">// 并作为虚拟结点的key。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                        virtualInvokers.put(m, invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//选择节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//根据调用参数来生成key</span></span><br><span class="line">            String key = toKey(invocation.getArguments());</span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);<span class="comment">//根据key生成消息摘要</span></span><br><span class="line">            <span class="comment">//调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode</span></span><br><span class="line">            <span class="comment">//调用sekectForKey方法选择结点</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                    buf.append(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//根据hashCode选择节点</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                    | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                    &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">            MessageDigest md5;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            md5.reset();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md5.update(bytes);</span><br><span class="line">            <span class="keyword">return</span> md5.digest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShortestResponseLoadBalance-最短响应负载均衡"><a href="#ShortestResponseLoadBalance-最短响应负载均衡" class="headerlink" title="ShortestResponseLoadBalance (最短响应负载均衡)"></a>ShortestResponseLoadBalance (最短响应负载均衡)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestResponseLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;shortestresponse&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of invokers</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// Estimated shortest response time of all invokers</span></span><br><span class="line">        <span class="keyword">long</span> shortestResponse = Long.MAX_VALUE;</span><br><span class="line">        <span class="comment">// The number of invokers having the same estimated shortest response time</span></span><br><span class="line">        <span class="keyword">int</span> shortestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The index of invokers having the same estimated shortest response time</span></span><br><span class="line">        <span class="keyword">int</span>[] shortestIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// the weight of every invokers</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// The sum of the warmup weights of all the shortest response  invokers</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The weight of the first shortest response invokers</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Every shortest response invoker has the same weight value?</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filter out all the shortest response invokers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line">            <span class="comment">// Calculate the estimated response time from the product of active connections and succeeded average elapsed time.</span></span><br><span class="line">            <span class="keyword">long</span> succeededAverageElapsed = rpcStatus.getSucceededAverageElapsed();</span><br><span class="line">            <span class="keyword">int</span> active = rpcStatus.getActive();</span><br><span class="line">            <span class="keyword">long</span> estimateResponse = succeededAverageElapsed * active;</span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// Same as LeastActiveLoadBalance</span></span><br><span class="line">            <span class="keyword">if</span> (estimateResponse &lt; shortestResponse) &#123;</span><br><span class="line">                shortestResponse = estimateResponse;</span><br><span class="line">                shortestCount = <span class="number">1</span>;</span><br><span class="line">                shortestIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (estimateResponse == shortestResponse) &#123;</span><br><span class="line">                shortestIndexes[shortestCount++] = i;</span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shortestCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(shortestIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortestCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> shortestIndex = shortestIndexes[i];</span><br><span class="line">                offsetWeight -= weights[shortestIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(shortestIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(shortestIndexes[ThreadLocalRandom.current().nextInt(shortestCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">Apache Dubbo 负载均衡</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> loadbalance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码分析开篇介绍</title>
      <link href="dubbo-need-to-know/"/>
      <url>dubbo-need-to-know/</url>
      
        <content type="html"><![CDATA[<blockquote><p>源码版本是 2.7.8</p></blockquote><p>Dubbo 是一款高性能、轻量级基于 Java 开发的 RPC 开源框架，是阿里 SOA 服务化治理方案的核心框架。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201030221757.png"></p><h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC ?"></a>什么是 RPC ?</h2><p>PC英文全名为Remote Procedure Call，也叫远程过程调用，其实就是一个计算机通信协议，它是一种通过网络从远程计算机程序上请求服务,而不需要了解底层网络技术的协议。计算机通信协议有很多种，对于开发来说，很多熟悉的是HTTP协议，我这里就做个简单的比较，HTTP协议是属于应用层的，而RPC跨越了传输层和应用层。HTTP本身的三次握手协议，每发送一次请求，都会有一次建立连接的过程，就会带来一定的延迟，并且HTTP本身的报文庞大，而RPC可以按需连接，调用结束后就断掉，也可以是长链接，多个远程过程调用共享同一个链接，可以看出来RPC的效率要高于HTTP，但是相对于开发简单快速的HTTP服务,RPC服务就会显得复杂一些。</p><h2 id="Dubbo-框架设计"><a href="#Dubbo-框架设计" class="headerlink" title="Dubbo 框架设计"></a>Dubbo 框架设计</h2><p>先介绍下Dubbo框架的各个模块</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201030222206.png"></p><h3 id="dubbo-registry-注册中心模块"><a href="#dubbo-registry-注册中心模块" class="headerlink" title="dubbo-registry 注册中心模块"></a>dubbo-registry 注册中心模块</h3><p>基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</p><p>Dubbo 的注册中心实现了多种方式，有 Zookeepr、Redis、Multicast、nacos等。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20201030222739.png"></p><p>dubbo-registry-api 抽象了注册中心的注册和发现，实现了一些公关的方法，让子类只关注部分关键方法。而剩下的模块，则是针对具体的注册中心具体的实现方法。</p><h3 id="dubbo-cluster-集群模块"><a href="#dubbo-cluster-集群模块" class="headerlink" title="dubbo-cluster 集群模块"></a>dubbo-cluster 集群模块</h3><p>官方解释：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</p><h3 id="dubbo-common-公共逻辑模块"><a href="#dubbo-common-公共逻辑模块" class="headerlink" title="dubbo-common 公共逻辑模块"></a>dubbo-common 公共逻辑模块</h3><p>官方解释：包括 Util 类和通用模型。</p><p>这个模块封装了dubbo框架的一些共用方法，以及一些贯穿整个项目的统一格式模型，比如 URL。</p><h3 id="dubbo-config-配置模块"><a href="#dubbo-config-配置模块" class="headerlink" title="dubbo-config 配置模块"></a>dubbo-config 配置模块</h3><p>是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。</p><h3 id="dubbo-container-容器模块"><a href="#dubbo-container-容器模块" class="headerlink" title="dubbo-container 容器模块"></a>dubbo-container 容器模块</h3><p>官方解释：官方解释：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</p><h3 id="dubbo-remoting-远程通讯模块"><a href="#dubbo-remoting-远程通讯模块" class="headerlink" title="dubbo-remoting 远程通讯模块"></a>dubbo-remoting 远程通讯模块</h3><p>官方解释：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。</p><p>Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。在 dubbo-remoting-api 中定义该模块的抽象概念，在其他子模块中依赖别的开源组件进行实现，比如，依赖 netty4 实现远程通信。</p><h3 id="dubbo-rpc-远程调用模块"><a href="#dubbo-rpc-远程调用模块" class="headerlink" title="dubbo-rpc 远程调用模块"></a>dubbo-rpc 远程调用模块</h3><p>官方解释：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</p><p>Dubbo 中对远程调用协议进行抽象的模块，其中包括各种协议，依赖于dubbo-remoting 模块的远程调用功能。dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现，例如，dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。 dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。</p><h3 id="dubbo-monitor-监控模块"><a href="#dubbo-monitor-监控模块" class="headerlink" title="dubbo-monitor 监控模块"></a>dubbo-monitor 监控模块</h3><p>官方解释：统计服务调用次数，调用时间的，调用链跟踪的服务。</p><h3 id="dubbo-metadata"><a href="#dubbo-metadata" class="headerlink" title="dubbo-metadata"></a>dubbo-metadata</h3><p>Dubbo 的元数据模块。dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。</p><h3 id="dubbo-serialization"><a href="#dubbo-serialization" class="headerlink" title="dubbo-serialization"></a>dubbo-serialization</h3><p>序列化层。如果数据要通过网络进行传送，则需要先做序列化，变成二进制流，在网络接收方，需要将二进制流重新转化成原始数据。序列化负责管理整个框架网络传输时的序列化和反序列化工作。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://dubbo.apache.org/zh/docs/v2.7/dev/">Apache Dubbo</a></li><li>《深入理解 Apace Dubbo 与实践》</li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程之 ReentrantLock 详解</title>
      <link href="java-reentrantlock/"/>
      <url>java-reentrantlock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>ReentrantLock 位于 <code>java.util.concurrent.locks</code> 包下，它实现了 Lock 接口和 Serializable 接口。</p><p>ReentrantLock 默认非公平，但可实现公平的(构造器传true)，悲观，独享，互斥，可重入，重量级锁。ReentrantLock 就是一个普通的类，它是基于 AQS(AbstractQueuedSynchronizer)来实现的。</p><h2 id="ReetrantLock-基本用法"><a href="#ReetrantLock-基本用法" class="headerlink" title="ReetrantLock 基本用法"></a>ReetrantLock 基本用法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否开启公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 提供公平锁和非公平锁的构造方法，默认构造方法是非公平锁。</p><p>NonfairSync 和 FairSync 都是 ReentrantLock 的内部类，继承 Sync 类。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200727143935.png"></p><p>关于公平锁和非公平锁的区别，主要是在多线程情况下，获取锁的机会是否相同。</p><h3 id="几种获取锁的方法"><a href="#几种获取锁的方法" class="headerlink" title="几种获取锁的方法"></a>几种获取锁的方法</h3><p>获取 ReentrantLock 的几种方式：</p><ul><li>lock()： 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li><li>tryLock()：如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false</li><li>tryLock(long timeout,TimeUnit unit)：如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li><li>lockInterruptibly()：如果获取了锁定立即返回，如果没有获取锁，当前线程处于休眠状态，直到获取锁定，或者当前线程被别的线程中断</li></ul><h2 id="公平锁加锁的流程-lock"><a href="#公平锁加锁的流程-lock" class="headerlink" title="公平锁加锁的流程(lock)"></a>公平锁加锁的流程(lock)</h2><p>在我们使用lock的时候，由于 FairSync 继承 Sync，并重新实现了lock()方法，在源码中:</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200727145927.png"></p><p>从上面的加锁流程，可以看出，不管是公平锁，还是非公平锁，最后都调用了 acquire(int arg) 方法。acquire() 方法是 AQS 中的方法，下面来看下acquire的主要流程</p><h3 id="tryAcquire-int-arg"><a href="#tryAcquire-int-arg" class="headerlink" title="tryAcquire(int arg)"></a>tryAcquire(int arg)</h3><p>AQS 中的 tryAcquire 方法，具体实现交给了 FairSync 实现，这一步主要是尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果无锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断AQS的队列中是否还有其他线程等待，并且通过CAS尝试修改state的值</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//将当前线程设置为独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//重入锁，获取锁的次数+1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去队列中判断是否有比当前线程等待时间更长的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// 队列尾部</span></span><br><span class="line">    Node h = head; <span class="comment">//队列头部</span></span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 getState() 是获取AQS 中的state值，这个值是volatile关键字修饰的，这个字段是一个同步锁的状态，框架通过 CAS 来原子操作这个值的变化。</p><p>利用hasQueuedPredecessors()方法来判断队列中是否有其他线程，如果有，则不会尝试获取锁。如果没有，利用CAS将AQS中的state修改为1，也就是获取锁，并将当前线程设置为获取锁的独占线程。</p><p>如果state&gt;0了，表示锁已经被获取了，这时就需要判断获取锁的线程是否为当前线程，是的话，state+1。</p><p>tryAcquire()会查看同步状态是否获取成功，如果成功，返回true，结束返回，如果!tryAcquire()==false，则调用addWaiter()方法。</p><h3 id="addWaiter-Node-mode"><a href="#addWaiter-Node-mode" class="headerlink" title="addWaiter(Node mode)"></a>addWaiter(Node mode)</h3><p>如果前面的<code>tryAcquire(int acquires)</code>方法获取锁失败，则需要 <code>addWaiter(Node.EXCLUSIVE)</code>将当前线程写入AQS队列中。</p><p>将当前线程和Node节点进行封装，AQS中节点类型有两种：<code>SHARED</code> 和 <code>EXCLUSIVE</code>，前者是共享模式，后者是独占模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前线程封装成EXCLUSIVE类型的Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//判断是否有尾节点，如果有尾节点，将封装好Node利用CAS写入对尾，否则执行enq()</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS操作</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前节点插入到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enq 入队操作，利用自旋+CAS保证一定能写入队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h3><p>写入队列后，需要将当前线程挂起，利用 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//判断前置节点是否为头结点，并尝试获取独占式锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//将队列头指针用指向当前节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//Node.SIGNAL 表示当前线程阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会进行无限循环中，循环中每次都会判断给定当前节点的前置节点，如果没有前置节点会直接抛出空指针异常，直到返回 true。</p><p>首先判断当前节点的前置节点是否是头结点，并尝试获取独占锁，如果成功，则将头结点指向当前节点，然后释放前置节点。如果没成功，则进入下一个判断条件。</p><p>根据上一个节点的 <code>waitStatus</code> 状态来处理 <code>shouldParkAfterFailedAcquire()</code>。<code>waitStatus</code> 用于记录当前节点的状态，如节点取消、节点等待等。</p><p>shouldParkAfterFailedAcquire() 循环尝试修改 compareAndSetWaitStatus(pred, ws, Node.SIGNAL)。parkAndCheckInterrupt 该方法的关键是会调用 LookSupport.park 方法，该方法是用来阻塞当前线程。</p><h3 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h3><p>中断当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁加锁模式"><a href="#非公平锁加锁模式" class="headerlink" title="非公平锁加锁模式"></a>非公平锁加锁模式</h2><p>非公平锁的的加锁步骤和公平锁大致相同，只有两处不同(不同点在代码中标注)，一处是在尝试获取锁前，直接通过CAS设置同步状态，如果成功，就将当前线程设置为偏向锁的线程；另外一处是在tryAcquire获取失败后，不需要去执行hasQueuedPredecessors方法，判断等待队列中是否还有等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//①</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>公平锁和非公平锁的释放流程是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//唤醒被挂起的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 <code>state</code> 减到 0 才认为完全释放锁。</p><p>释放之后需要调用 unparkSuccessor(h) 来唤醒被挂起的线程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> lock </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Kubeadm 安装 Kubernetes 集群</title>
      <link href="kubernetes-install-with-kubeadm/"/>
      <url>kubernetes-install-with-kubeadm/</url>
      
        <content type="html"><![CDATA[<p>kubernetes 是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful），Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>Kubernetes 有多种安装方式，比如麻烦无比的二进制安装方式，本篇文章主要讲解如何使用 Kubeadm 来安装 Kubernetes 集群。</p><h2 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h2><table><thead><tr><th>系统</th><th>角色</th><th>IP</th><th>主机名</th><th>内存(2G以上)</th></tr></thead><tbody><tr><td>Centos 7</td><td>master</td><td>192.168.60.11</td><td>k8s-master-11.cn</td><td>2G</td></tr><tr><td>Centos 7</td><td>node</td><td>192.168.60.16</td><td>k8s-node-16.cn</td><td>2G</td></tr><tr><td>Centos 7</td><td>node</td><td>192.168.60.170</td><td>k8s-node-170.cn</td><td>2G</td></tr></tbody></table><p>本文搭建的只是 Kubernetes 集群，而不是 Kubernetes 高可用集群，高可用集群需要多台 master 节点来避免 master 节点中某台服务可能宕机。下面这些前期准备，需要在所以服务器上执行一遍。由于本文使用的操作系统是 Centos，其中你是 Ubuntu 用户，请查看<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">官方具体的操作</a>。</p><p>根据表格中的信息修改服务器主机名的，具体的主机名请根据自己实际命名修改。需要注意的是，必须保证每台服务器的主机名唯一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master-11.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主机名</span></span><br><span class="line">hostname</span><br></pre></td></tr></table></figure><p>向每台服务器上的 <code>/etc/hosts</code> 文件添加一下配置。因为只有三台服务器，我们直接修改 hosts 文件来指定，如果是很大的集群，每次添加一个节点，都要修改每台服务器的 hosts 文件，这样会很麻烦，所以可以选择使用dns去解析，但是我们这里只有几台服务器，就直接修改 hosts 文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.60. k8s-master-252.cn</span><br><span class="line">192.168.60.227 k8s-node-227.cn</span><br><span class="line">192.168.60.15 k8s-node-15.cn</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 禁用</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>关闭服务器的 swap 交换空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i <span class="string">&#x27;/swap/s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab</span><br><span class="line"><span class="comment"># 查看交换free</span></span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><p>安装 Docker， <a href="https://kubernetes.io/zh/docs/setup/production-environment/#docker">Kubernetes 官网的安装 Docker 教程</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果已经安装，需要卸载的话，使用以下命令</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置稳定的仓库</span></span><br><span class="line">yum-config-manager --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Docker CE.</span></span><br><span class="line">yum update &amp;&amp; yum install \</span><br><span class="line">  containerd.io-1.2.10 \</span><br><span class="line">  docker-ce-19.03.4 \</span><br><span class="line">  docker-ce-cli-19.03.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置docker 加速器：</span></span><br><span class="line">mkdir /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment">## 粘贴内容</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker </span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 修改配置文件后，记得重启 Docker。</p><p>关闭 SElinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure><p>同步服务器时间，并把时区设置为上海时区，如果是 Ubuntu 用户，请自行百度查询如何设置更新服务器时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步时间</span></span><br><span class="line">yum install -y ntpdate</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查服务器时间是否同步</span></span><br><span class="line">date</span><br></pre></td></tr></table></figure><p>Centos7 用户还需要设置路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bridge-utils.x86_64</span><br><span class="line">modprobe  br_netfilter</span><br></pre></td></tr></table></figure><p>将桥接的IPV4流量传递到iptables 的链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.d&#x2F;kubernetes.conf</span><br><span class="line"></span><br><span class="line"># 粘贴内容</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line"></span><br><span class="line"># 刷新</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>设置 kubeadm 下载地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 粘贴内容</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure><p>下载 kubelet kubeadm kubectl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure><p>到此，每台服务器上的准备工作基本准备完成了。下面一节，将会讲解如何使用 kubeadm 初始化 kubernetes 集群。</p><h2 id="Kubeadm-初始化-Kubernetes-集群"><a href="#Kubeadm-初始化-Kubernetes-集群" class="headerlink" title="Kubeadm 初始化 Kubernetes 集群"></a>Kubeadm 初始化 Kubernetes 集群</h2><p>注意：在我们选定的 Master 节点的服务器上操作以下命令。</p><p>这里我使用的是配置文件初始化集群，如果你想直接使用命令，请查看官网的具体参数文档，<a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init 参数官网地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产配置文件</span></span><br><span class="line">kubeadm config <span class="built_in">print</span> init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml</span><br></pre></td></tr></table></figure><p>查看 kubeadm.yml 文件，并修改下面几个有备注的地方。其中主要修改的是主节点IP；镜像地址，这里我们使用的是阿里云镜像仓库；以及Pod 所在网段，如果你服务器所在的集群网段不和 <code>192.168.0.0/16</code> 冲突，可以不修改这个网段地址，使用默认即可。注意：如果修改了网段地址，需要在网络插件 calico 中修改 <code>CALICO_IPV4POOL_CIDR</code> 的默认值，改为你修改后的网段值。这里我就碰到一个坑，我的服务器网段是在 192.169.0.0 网段的，一开始，没修改默认时，安装 calico 时，一直出问题。后来查看 calico 官网文档，发现需要修改 kubernetes 默认网段，但是忘记修改 calico 中的默认值，然后又出现 Pod 中无法 PING 通集群服务器的IP 的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  <span class="comment">#修改为主节点IP</span></span><br><span class="line">  advertiseAddress: 192.168.60.11</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: k8s-master-1</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  <span class="built_in">type</span>: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  <span class="built_in">local</span>:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line"><span class="comment">#修改镜像仓库 </span></span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.17.0</span><br><span class="line">networking:</span><br><span class="line">  <span class="comment"># 配置 pod 所在网段和虚拟机所在网段不重复（这里用的是Flannel 默认网段），如果宿主机已经使用该网段，则必须更改网段</span></span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看需要下载镜像</span></span><br><span class="line">kubeadm config images list --config kubeadm.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：初始化k8s</span></span><br><span class="line">kubeadm init --config=kubeadm.yml --upload-certs | tee kubeadm-init.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用参数直接初始化master节点</span></span><br><span class="line">kubeadm init --image-repository=registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.60.237 </span><br><span class="line">--upload-certs</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200318111050.png"></p><p>执行成功后，会出现上面图中的信息，你需要在 master 节点执行第一个圈出的命令，这样你可以在master节点上使用 kubectl 命令；第二个圈出的命令，需要你在node节点上执行操作，将 node 节点加入 master 节点。</p><p>将node节点加入master节点后，使用kubectl get nodes 查看节点，你会发现这里有三台服务器，如下图所示，但是这时候，status状态不是下面显示的 Ready，而是 NotReady (PS：因为我这个截图是按照好后的截图)，这表示集群之间网络时不互通的，需要安装网络插件，安装好网络插件后就会出现下面的信息了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200318111319.png"></p><p><strong>注意：</strong> Kubernetes 所以执行操作都是在master节点操作的，node节点主要是启动各种 Pod 的。</p><h2 id="安装网络插件-Calico"><a href="#安装网络插件-Calico" class="headerlink" title="安装网络插件 Calico"></a>安装网络插件 Calico</h2><p><a href="https://docs.projectcalico.org/v3.11/getting-started/kubernetes/">Calico 官方地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Calico</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装完成</span></span><br><span class="line">watch kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果默认的宿主机的默认网段是192.168.0.0/16，则需要修改该网段，详情请看kubeadm master节点初始化步骤。如果修改了Kubernetes Pod 的网段地址，需要在 calico.yaml 中修改 <code>CALICO_IPV4POOL_CIDR</code> 对应的值，这个值的默认值为 <code>192.168.0.0/16</code>，然后修改为kubeadm 中修改后的值。如下图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200318111659.png"></p><h2 id="新增-node-节点"><a href="#新增-node-节点" class="headerlink" title="新增 node 节点"></a>新增 node 节点</h2><p>如果需要新增新的node节点，你需要执行上面的前期准备工作，然后使用下面的命令，获取 token 和 SHA256，然后在新的节点上，执行 kubeadm join 命令，将新节点加入集群，具体命令请看下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Token</span></span><br><span class="line">kubeadm token list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的token</span></span><br><span class="line">kubeadm token create</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Kubernetes认证的SHA256加密字符串</span></span><br><span class="line">openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新Node节点使用命令加入，根据得到的token和SHA256替换</span></span><br><span class="line">kubeadm join 192.168.60.252:6443 --token bq9xsp.bpf3zfl7mndpl9h2 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:937e143e3bd79a24f1cdefd2693072484757beeb06869af07ba4962a78b4544d</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看工作节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印kubeadm join 命令</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— 容器的隔离与限制</title>
      <link href="docker-container-namespace-cgroups/"/>
      <url>docker-container-namespace-cgroups/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是读《深入剖析 Kubernetes》的笔记</p></blockquote><p>在很久之前写过几篇关于 Docker 的文章，当时也正处于自己接触 Docker 不久，后来一直没在实际环境中使用过。最近公司要搞一套服务，需要使用 Kubernetes 来编排所以的容器。然后就重新拾起 Docker 的内容，最近也在学习 Kubernetes，最近在看极客时间的《深入剖析Kubernetes》，感兴趣的可以从下面地址购买。</p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200114194452.jpg" width = "200" height = "300" alt="极客时间-Kubernetes" /><p>在之前知道 Docker 容器使用了 Namespace 和 Ggroups 技术，但是对于这两个东西具体是什么，还真没搞清楚过。真心推荐极客时间的这么课，还是非常不错的。</p><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造一个”边界“。</p><p>对于Docker等大多数Linux容器来说，<strong>Cgroups是用来制造约束的主要手段，Namespace则是用来修改进程试图的主要方法</strong>。</p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。</p><p>Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p><p>使用过 Docker 的应该知道，如果我们使用 <code>docker exec -it</code> 进入容器，然后使用<code>ps</code>命令，你会看到以下信息：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200115214028.png"></p><p>我们可以看到这个容器内部的第一号进程，容器已经被 Docker 隔离了。那docker是如何在Linux宿主机上实现这个的呢？这个使用的就Linux的Namespace技术，而且启动的并没有重新创建一个进程，只是使用了一个障眼法。</p><p>在我们启动容器的时候，Linux系统会创建一个进程，比如 PID = 100，使用 Namespace 技术后，会对这个 PID 进行掩饰，编程 PID = 1。</p><p>Namespace 技术知识 Linux 创建新进程的一个可选参数。在 Linux 系统中创建线程的系统调用的是 clone()：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pid = <span class="built_in">clone</span>(main_function, stack_size, SIGCHLD, NULL); </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定参数 CLONE_NEWPID，在创建新进程的时候，返回一个重新计算的进程编号</span></span><br><span class="line">int pid = <span class="built_in">clone</span>(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </span><br></pre></td></tr></table></figure><p>Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p><p>这就是Linux容器最基本的实现原理。所以从这里看出，<strong>容器其实就是一个使用宿主机资源的进程而已</strong>。</p><p>通过上面的简单介绍，我们知道，容器只是运行在宿主机上的一种特殊进程，那么多个容器之间使用的还是宿主机的操作系统内核。这就导致你不能在Windows宿主机上运行Linux内核，或者在低版本Linux上运行高版本Linux内核。</p><h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>Linux Cgroups 的全称是 Linux Control Group，它最主要的作用就是限制一个进程组能够使用资源的上限，包括CPU、内存、磁盘、网络带宽等等。</p><p>我们可以使用 <code>mount -t cgroup</code> 来查看linux 系统的文件系统，这些在系统<code>/sys/fs/cgroup</code> 下的资源，都是可以被 Cgroups 进行限制的资源种类。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200114202633.png"></p><p>在Docker 中，可以在启动的时候带上参数，这样来限制容器的资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>然后我们可以在宿主机上查看这些资源文件的参数，这样一位这只能使用20%的CPU。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200114204021.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Namespace </tag>
            
            <tag> Cgroups </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次 PageHelper 分页引发的血案</title>
      <link href="problem-pagehelper-limit/"/>
      <url>problem-pagehelper-limit/</url>
      
        <content type="html"><![CDATA[<p>最近在测试环境登录的时候，突然出现了下面的异常。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204094316.png"></p><p>本来这条SQL只查询一条数据的，但是在错误日志中，发现后面莫名其妙的多了一个LIMIT。第一个反应是不是这个查询的前面用错了PageHelper的分页功能，但是查看了项目中的这处查询，发现LIMIT只是在SQL里面写死了LIMIT 1。我就懵逼了，问了下同事，同事说以前项目也出现过这种<strong>抽风的现象</strong>，然后我一脸黑人问号。</p><p>最近几天大致的看了下PageHelper(文章后面给了源码地址)这个分页工具的源码。在项目中，根据PageHelper的文档，一般会使用以下前两种分页方法(官方文档也推荐这样使用，其实我本人使用最多的是第三种)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; list = userMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">PageHelper.offsetPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;User&gt; list = userMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk8 lambda用法</span></span><br><span class="line">Page&lt;User&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPage(()-&gt; userMapper.selectGroupBy());</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，分页的数据和SQL查询是分开的，那么PageHelper是如何做到把分页数据准确的拼接到SQL后面呢？如果你在源码中点开 <code>PageHelper</code> 这个类，你会发现这个类是继承 <code>PageMethod</code> 以及实现 <code>Dialect</code> 接口的。在 <code>PageMethod</code> 中，定义了一个 <code>protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal&lt;Page&gt;();</code> 的全局常量，然后在源码中，你会发现PageHelper只是把你的分页数据，放到了ThreadLocal LOCAL_PAGE中了，然后就没然后了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204204237.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204204255.png"></p><p>虽然PageHelper还有别的一些设置，比如数据库方言的选择等，但是我们今天不讨论这些，如果自己感兴趣的话，可以去翻翻源码。如果仔细的看下源码，会发现一个 <code>PageInterceptor</code> 类，这个类实现的是 <code>ibatis</code> 的 <code>Interceptor</code>。在拦截器中，<code>PageHelper</code> 判断是查询语句是否需要分页，是否需要count查询，分页数据拼接查询等操作。下面三个截图大致的说明了一些拦截器中的一些原理(作者源码注释还是挺好理解的)。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204211337.png"><br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204211412.png"><br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204212155.png"></p><p>从上面的源码解读中，我们知道，<code>PageHelper</code> 的分页数据是存储在ThreadLocal中的，在实现mybatis的拦截器中处理SQL的拼接查询以及count查询，最后在结束的时候，清理ThreadLocal中的数据。所以当我们在 <code>PageHelper</code> 使用不当的时候，只设置<code>PageHelper.startPage(1, 10);</code>了，但是后面的SQL没执行，那么这个 ThreadLocal 中保存的分页等数据，就会留给另外一个复用该线程的请求，当它执行SQL查询的时候，就会把上一次请求中存储 ThreadLocal 中的分页数据拼接到这次请求的SQL上。</p><p>说到这里，我们就得聊下关于 Tomcat 中的线程了，使用过 Tomcat 的，应该都知道它是有个线程池，我们不去深入了解线程池的如何使用。在这里，由于 Tomcat 使用了线程池，那么就存在线程复用的问题，这就导致了我们上面出现的问题。如果想尝试Tomcat线程池，spring boot的配置文件中把 <code>server.tomcat.max-threads</code> 参数调小，甚至直接设置为1，那么Tomcat就只有一个线程，这时候尝试ThreadLocal，就会出现不同请求，但是能在第二次中访问到上一次的请求插入到ThreadLocal中的值，这说明2次请求使用的是同一个线程。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191204213959.png"></p><p>项目中全局搜索使用<code>PageHelper.startPage</code>的地方，发现一个地方，在<code>PageHelper.startPage</code>之后的查询SQL是包在一个if语句中的，当不满足查询条件的时候，就不会走查询，然后就把分页数据留给了下一个复用该线程的请求。</p><p><strong>解决方法：</strong> </p><ul><li><code>PageHelper.startPage</code>后面直接跟上SQL查询语句</li><li>在每次请求完成后，调用pagehelper提供的清理ThreadLocal方法，或者在每次请求进来的时候，在拦截器中清理掉线程缓存数据。</li></ul><p><strong>Reference：</strong></p><ul><li><a href="https://github.com/pagehelper/Mybatis-PageHelper">PageHelper 源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PageHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 零拷贝</title>
      <link href="java-zero-copy/"/>
      <url>java-zero-copy/</url>
      
        <content type="html"><![CDATA[<p>Linux 传统的数据传输，一般需要涉及到数据的4次copy。这4次copy，分别是两次用户态和内核态之间Copy需要CPU参与，两次内核态和IO设备间的copy为DMA方式不需要CPU的参与。零拷贝技术主要就是减少用户态和内核态间copy数据次数。</p><p>比如我们现在需要把实现一个场景：从一个文件中读取数据并将数据发送到另一台服务器上。从上图中看出：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191105210233.png"></p><ul><li>应用程序调用 read 方法，这里会涉及到一次上下文切换（用户态-&gt;内核态），底层采用DMA 读取磁盘文件数据，并把内容存储到内核地址空间的读取缓存。</li><li>由于应用程序无法读取内核地址空间的数据，如果需要程序操作这些数据，必须把数据从读取缓冲区拷贝到用户缓冲区。这时，read()调用返回，引发一次上下文切换（内核态-&gt;用户态），这样就把数据拷贝到用户地址空间缓冲区了。这样应用程序就可以操作这些数据了。</li><li>我们的目的是需要把数据发送到另外一个服务器，调用Socket的send()方法，这时候又涉及到一次上下文的切换(用户态-&gt;内核态)，同时文件数据被进行第三次拷贝，再次从用户地址空间拷贝到内核地址空间缓冲区。</li><li>send() 调用返回，引发第四次上下文切换，同时进行第四次的数据拷贝，通过DMA把数据从目标套接字相关的缓存区传输到协议引擎进行发送。</li></ul><p>在上面的图中，1和4是有DMA负责，不需要CPU参与，但是过程2和3需要CPU的参与。从这样流程中，我们会发现，如果不需要再应用程序中操作文件数据，其中2和3的步骤是多余的，直接把内核态数据读取后直接拷贝到套接字相关的缓冲区，就能提升性能。这就是零拷贝技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率。零拷贝技术减少了用户应用程序地址空间和操作系统内核地址空间之间因为上下文切换而带来的开销。</p><h2 id="Java-层实现零拷贝"><a href="#Java-层实现零拷贝" class="headerlink" title="Java 层实现零拷贝"></a>Java 层实现零拷贝</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之RabbitMQ初识</title>
      <link href="mq-rabbitmq-introduction/"/>
      <url>mq-rabbitmq-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ-相关概念介绍"><a href="#RabbitMQ-相关概念介绍" class="headerlink" title="RabbitMQ 相关概念介绍"></a>RabbitMQ 相关概念介绍</h2><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、储存和转发消息。下面的图是RabbitMQ 的整体模型架构图：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190828141523.png"></p><h3 id="RabbitMQ-的一些角色"><a href="#RabbitMQ-的一些角色" class="headerlink" title="RabbitMQ 的一些角色"></a>RabbitMQ 的一些角色</h3><ul><li>Producer：生产者，就是投递消息的一方；</li><li>Consumer：消费者，接收消息的一方；</li><li>Broker：消息中间件的服务节点；</li><li>队列：是 RabbitMQ的内部对象，用于储存消息。RabbitMQ 的生产者生产的消息并最终投递到队列中，消费者可以从队列中获取消息并消费。多个消费者可以订阅同一队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）。</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190828141828.png"></p><h3 id="交换器、路由键和绑定"><a href="#交换器、路由键和绑定" class="headerlink" title="交换器、路由键和绑定"></a>交换器、路由键和绑定</h3><h4 id="交换器（Exchange）"><a href="#交换器（Exchange）" class="headerlink" title="交换器（Exchange）"></a>交换器（Exchange）</h4><p>交换器：在RabbitMQ 中，生产者实际把消息发送个 Exchange，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返给生产者，或许直接丢弃。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190828143529.png"></p><p>RabbitMQ 中的交换器有四种，下面分别简单介绍下：</p><ul><li><p>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</p></li><li><p>direct：direct 类型的交换器路由规则也很简单，它会把消息路由到那些 BindingKey RoutingKey完全匹配的队列中。</p></li><li><p>topic：不同于direct交换器的严格，topic的匹配规则可以模糊匹配。RabbitMQ定义了一下规则：</p><ul><li><p>RoutingKey 为一个点号”.”分隔的字符串(被点号”.”分隔开的每一段独立的字符串称为个单词 )；</p></li><li><p>BindingKey RoutingKey 样也是点号”.”分隔的字符串；</p></li><li><p>BindingKey 中可以存在两种特殊字符串”*“和”#”，用于做模糊匹配，其中”*”用于匹配一个单词，”#”用于匹配多规格单词(可以是零个)。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190925143433.png"></p></li></ul></li><li><p>headers：根据发送的消息内容中的 headers 属性进行匹配。</p></li></ul><h4 id="路由键（RoutingKey）"><a href="#路由键（RoutingKey）" class="headerlink" title="路由键（RoutingKey）"></a>路由键（RoutingKey）</h4><p>生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效</p><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>RabbitMQ 通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个BindingKey，这样消息就能准确发送到队列了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190828143944.png"></p><h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>在使用消息中间件，我们需要注意消息是否发送成功，以及消息是否消费成功。</p><ul><li>保证消息的成功发送</li><li>保障MQ节点的成功接收</li><li>发送端收到MQ节点(Broker)确认应答</li><li>完善的消息进行补偿机制</li></ul><h3 id="confirm-消息确认机制"><a href="#confirm-消息确认机制" class="headerlink" title="confirm 消息确认机制"></a>confirm 消息确认机制</h3><p>消息的确认是指生产者投递消息后，如果 Broker 接收到消息，则会给生产者一个应答。生产者进行接收应答，用来确认这条消息是否正常的发送到 Broker，这种方式也是消息可靠性投递的核心保障。</p><ul><li>在channel上启动确认模式：channel.confirmSelect()</li><li>在channel上添加监听：addConfirmListener，监听成功和失败的返回结果，根据具体的结果对消息进行重新发送、或记录日志等后续处理</li></ul><h3 id="return-消息机制"><a href="#return-消息机制" class="headerlink" title="return 消息机制"></a>return 消息机制</h3><p>生产者通过指定一个 exchange 和 routingkey 把消息送达到某个队列中去，然后消费者监听队列，进行消费处理。但是在某些情况下，如果我们在发送消息时，当前的 exchange 不存在或者指定的 routingkey 路由不到，这个时候如果要监听这种不可达的消息，就要使用 ReturnListener。</p><p>如果生产端发送的消息，通过Return机制，讲这些不可达的消息发送给生产端，这时候生产端就需要设置 Return Listener去接收这些不可达的消息，然后及时记录日志，去处理这些消息。</p><h4 id="mandatory-参数"><a href="#mandatory-参数" class="headerlink" title="mandatory 参数"></a>mandatory 参数</h4><p>当 mandatory 参数设置为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Returen 命令将消息返回给生产者。当 mandatory 参数设置为flase时，出现上述情况，则消息直接丢弃。</p><p>在设置 mandatory 的情况下，不想复杂化生产者代码逻辑，可以使用备份交换器，可以将未被路由的消息存储在RabbitMQ中，再在需要的时候去处理这些消息。可以通过在声明交换器(调用 channel.exchangeDeclare 方法)的时候添加 <code>alternate-exchange</code> 参数来实现，</p><h4 id="immediate-参数"><a href="#immediate-参数" class="headerlink" title="immediate 参数"></a>immediate 参数</h4><p>当 immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配所有队列都没有消费者时，该消息会通过 Basic Return 返回至生产者。</p><p><strong>RabbitMQ 3.0 版本开始已经去掉了对 immediate 参数的支持</strong>。</p><h3 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h3><p>为了保证RabbitMQ在重启、奔溃等异常情况下数据没有丢失，需要持久化。RabbitMQ 的持久化分为三部分：交换器的持久化、队列的持久化和消息的持久化。</p><p><strong>注意：</strong> 如果将所有的消息都设置持久化，这样会严重影响RabbitMQ的性能。在选择是否要将消息持久化时，需要在可靠性和吞吐量之间做一个权衡。</p><h3 id="消费端的确认和拒绝"><a href="#消费端的确认和拒绝" class="headerlink" title="消费端的确认和拒绝"></a>消费端的确认和拒绝</h3><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了消息确认机制( message acknowledgement) 消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除) 。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而 ，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。 如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><h2 id="关于延迟队列"><a href="#关于延迟队列" class="headerlink" title="关于延迟队列"></a>关于延迟队列</h2><p>在RabbitMQ中，可以设置2种延迟队列，一种是对队列设置过期时间；另外一种是对消息设置过期时间</p><h3 id="Per-Queue-Message-TTL"><a href="#Per-Queue-Message-TTL" class="headerlink" title="Per-Queue Message TTL"></a>Per-Queue Message TTL</h3><p>通过在 queue.declare 中设置 x-message-ttl 参数，可以控制被 publish 到 queue 中的 message 被丢弃前能够存活的时间。当某个 message 在 queue 留存的时间超过了配置的 TTL 值时，我们说该 message “已死”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h3 id="Per-Message-TTL"><a href="#Per-Message-TTL" class="headerlink" title="Per-Message TTL"></a>Per-Message TTL</h3><p>TTL 设置可以具体到每一条 message 本身，只要在通过 basic.publish 命令发送 message 时设置 expiration 字段。消息过期，不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。</p><p>这种消息过期存在一定的问题，比如连续发送2条消息，第一条设置过期时间1分钟，第二条设置时间30秒，最终消费的时候，第二条会被第一条阻塞，最终和第一条一起消费。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>DLX，全称 Dead-letter-Exchange，当消息在一个队列中变成死信（dead message）之后，它能被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190903152307.png"></p><p>通过上述的死信队列，我们可以利用这一特性，实现延迟队列的操作。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先队列，具有高优先级的队列具有高的优先权，优先权高的消息具备优先被消费的特权。可以通过设置<code>x-max-priority</code>参数来实现。默认最低为0，最大为队列设置的最大优先级。</p><p><strong>注意：</strong> 如果消费者的消费速度大于生产者的速度，且Broker中没有消息堆积的情况下，对发送的消息设置优先级也没有实际意义。</p><h2 id="RabbitMQ-进阶"><a href="#RabbitMQ-进阶" class="headerlink" title="RabbitMQ 进阶"></a>RabbitMQ 进阶</h2><h3 id="消息的分发"><a href="#消息的分发" class="headerlink" title="消息的分发"></a>消息的分发</h3><p>当 RabbitMQ 队列有多个消费者时，队列收到的消息将以轮询的分发方式发送给消费者。每条消息都会发给订阅列表中的一个消费者。但是当某个消费者任务繁忙时，来不及消费消息的时候，RabbitMQ 还是会把消息分发给这个消费者，而别的消费者有很空闲，这样就会造成整体应用吞吐量的下降。</p><p>消费端提供<code>channel.basicQos(int prefetchCount)</code>方法，该方法允许限制信道上的消费者所能保持的最大为确认消息的数量。比如该数字设置为5，如果达到上限，那么 RabbitMQ 就不会向这个消费者发送任何消息，等消费者确认某条消息之后，RabbitMQ将对应的技术减一，之后消费者可以继续接收消息了。</p><p><strong>注意：</strong> Basic.Qos的使用对拉模式的消费方法无效。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《RabbitMQ 实战指南》</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件之从零开始</title>
      <link href="mq-what-the-different/"/>
      <url>mq-what-the-different/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件的作用"><a href="#消息中间件的作用" class="headerlink" title="消息中间件的作用"></a>消息中间件的作用</h2><p>消息中间件的作用可以概括如下：</p><ul><li>解耦：消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要事先这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保他们遵守同样的接口约束即可。</li><li>冗余（储存）：有些情况下，处理数据的过程会失败。消息中间件可以把数据持久化直到它们已经完全处理，通过这一范式规避了数据丢失风险。</li><li>扩展性：因为消息中间件解耦了应用的处理过程，所以提高了消息入队和处理的效率和容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</li><li>消峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。</li><li>可恢复性：即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</li><li>顺序保证：消息中间件支持一定程度上的顺序性</li><li>缓冲：消息中间件通过一个缓冲层来帮助任务最高效率的执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</li><li>异步通信：消息中间件提供了异步处理机制。</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP，即 Advanced Message Queuing Protocol，一种提供统一消息服务的应用层标准高级<br>消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端和消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开放语言等条件的限制。基于此协议的消息中间件有RabbitMQ。</p><h2 id="各种MQ的比较"><a href="#各种MQ的比较" class="headerlink" title="各种MQ的比较"></a>各种MQ的比较</h2><p>目前业界有很多MQ产品，比如 RabbitMQ、RocketMQ、Kafka、ActivceMQ等。其中ActiceMQ现在社区活跃度不是很高，已经被很多人弃用了。其中RabbitMQ 是基于erlang语言的，虽然其实开源的，但是如果需要定制化的话，维护是一件很麻烦的事情。Kafka 和 RocketMQ ，前者是Scala，后者是阿里出品的，基于Java开发的。所以，我们一般选择MQ的时候，主要从RabbitMQ、Kafka、RocketMQ这几个主流MQ中选择一个适合的。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190828152900.png"></p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka 主要定位在日志等方面，因为Kafka 设计的初衷就是为了处理日志。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。</li><li>时效性：ms级</li><li>可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li><li>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;</li><li>有优秀的第三方Kafka Web管理界面Kafka-Manager；</li><li>在日志领域比较成熟，被多家公司和多个开源项目使用；</li><li>功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</li><li>使用短轮询方式，实时性取决于轮询间隔时间；</li><li>消费失败不支持重试；</li><li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 结合 erlang 语言本身的性质，高并发，高可用等特性。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>由于erlang语言的特性，mq 性能较好，高并发</li><li>吞吐量到万级，MQ功能比较完备 </li><li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>erlang 语言开放，比较难维护</li><li>RabbitMQ的吞吐量相对另外两个MQ低很多</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ 适合互联网金融领域，支持可靠性要求高的场景。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li><li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>支持的客户端少</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计之从零开始</title>
      <link href="ddd-thought/"/>
      <url>ddd-thought/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间在了解领域模型，之前拜读了下《领域驱动设计——软件核心复杂性应对之道》，结果看的云里雾里，晦涩的语句，不明所以的专业术语，加上翻译导致的语句流畅性，可以说观看体验并不是很好。然后同事推荐我先看《实现领域驱动设计》这本书，但是对于这种软件设计的书，稍微之前那本好点了。以前都是“talk is cheap, show me the code”，加上自己在这方面没啥经验积累，看的过程中，没啥共鸣。</p><p>接下来主要是自己在看的过程中的一些笔记和理解。</p><h2 id="领域模型之贫血模型和充血模型"><a href="#领域模型之贫血模型和充血模型" class="headerlink" title="领域模型之贫血模型和充血模型"></a>领域模型之贫血模型和充血模型</h2><p>贫血模型：Model中，仅包含状态属性，不包含个行为，采用这种设计时，需要分离出DB曾，左门用语数据库操作。现在的web软件开发主要使用的就是贫血模式。<br>优点：系统层次结构清楚，各层之间单向依赖，缺点是不够面向对象</p><p>充血模型：Model中即包含状态，也包含行为，是最符合面向对象的设计方式。<br>优点面向对象，缺点比较复杂，对技术要求更高。<br>Spring data 的 Repository 是对充血模型的最佳实践</p><h2 id="领域、子域和限界上下文"><a href="#领域、子域和限界上下文" class="headerlink" title="领域、子域和限界上下文"></a>领域、子域和限界上下文</h2><p>在DDD领域中，一个领域被分为若干个子域，领域模型在界限上下文中进行开发。</p><p>限界上下文是一个显示边界，灵越模型便存在边界之内。在边界内，通用语言中的所有术语和词组都有特定的含义，而模型需要准确的反映通用语言。</p><h2 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h2><p>在选择使用框架时，需要明确其使用目的：建立一种可以表达领域模型的实现并且用它来解决重要问题。</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>分层架构主要是给复杂的应用程序划分诚实。在每一层内分别进行设计，使其具有内聚性并且只依赖于它的下层。这种架构模式类似于MVC框架。</p><ul><li>用户界面层：负责向用户显示信息和解释用户指令。比如在MVC框架中，这一层主要指的是Controller层。</li><li>应用层：定义要完成的任务，并指挥表达领域概念的对象解决问题。对应MVC中service。</li><li>领域层：负责处理基本业务规则，比如事物回滚，业务逻辑等。</li><li>基础设施层：为上层提供通用的技术能力，个人理解这一层在MVC中指的是比如数据库操作等这些基础功能。</li></ul><h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h3><h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><h3 id="CQSR"><a href="#CQSR" class="headerlink" title="CQSR"></a>CQSR</h3><p>CQRS 就是平常大家在 讲的读写分离，通常读写分离的目的是为了提高查询性能，同时达到读/写的解耦。让DDD和CQRS结合，我们可以分别对读和写建模，查询模型通常是一种非规范化数据模型，它并不反映领域行为，只是用于数据显示；命令模型执行领域行为，且在领域行为执行完成后，想办法通知到查询模型。</p><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>RESTful风格的架构将‘资源’放在第一位，每个‘资源’都有一个URI与之对应，可以将‘资源’看着是ddd中的实体；RESTful采用具有自描述功能的消息实现无状态通信，提高系统的可用性；至于‘资源’的哪些属性可以公开出去，针对‘资源’的操作，RESTful使用HTTP协议的已有方法来实现：GET、PUT、POST和DELETE。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合就是指一组相关对象的集合，我们把它作为数据修改的单元。每个聚合都有一个聚合根(root)和一个边界(boundary)。边界定义了聚合内部有什么，而根则是一个特定的entity，两个聚合之间，只能通过根引用去向深入引用其他引用变量。</p><p>例子还是沿用电商系统中的订单和商品模块。在聚合模式中，订单不能够直接关联到商品的规格信息，如果一定要查询，则应该通过订单关联到的商品，由商品去访问商品规格。在这个例子中，订单和商品分别是两个边界，而订单模块中的订单entity和商品模块中的商品entity就是分别是各自模块的root。遵循这个原则，可以使我们模块关系不那么的盘根错节，这也是众多领域驱动文章中不断强调的划分限界上下文是第一要义。</p><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p>严格来说，只有聚合才拥有资源库。</p><h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><p>对于事务的管理绝对不能放在领域模型和领域层中。通常来说，与领域模型相关的操作都是非常细粒度的，以致于无法用于事务管理。</p><p>一般来说，事务的管理应该放在应用层。</p>]]></content>
      
      
      <categories>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 数据库锁机制</title>
      <link href="mysql-locks/"/>
      <url>mysql-locks/</url>
      
        <content type="html"><![CDATA[<p>数据库是一个多用户共享的资源，这样的话对于多个用户在存取同一数据的时候，就会出现问题，举个最经典的问题—-票务系统，如何保证数据的正确性。当只剩下最后1张票的时候，两个用户同时取到数据并更新，那么最后是谁买到票了呢？</p><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库事务是指单个逻辑工作单元执行一系列操作，要么完成执行，要么完成不执行。数据库事务必须满足ACID(原子性、一致性、隔离性、持久性)。</p><ul><li>原子性：对于其数据的修改，要么全部执行，要么完全不执行。原子性消除了系统处理操作子集的可能。</li><li>一致性：事务完成时，必须是所有的数据都保持一致</li><li>隔离性：由并发事务所做的修改必须与任何其他事务并发事务所做的修改隔离</li><li>持久性:完成事务后，对系统的修改时永久性的</li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/b00b75a1a8a7269cd68335b55f8c2e49.jpg"></p><ul><li>未提交读：当前事务未提交、其他事务也能读到</li><li>提交读：当前事务提交之后，其他事务才能看到</li><li>可重复读：该级别解决了同一事务多次读取同样记录的结果是一致的。但是理论上，还是无法解决另一个幻读问题。幻读 是指当前事务读取某个范围内的记录时，其他事务在该范围又加入新的纪录，之前的事务再次从该范围读取数据时，会产生幻行。这个的换行是对于 insert 操作来说的，对于 update 操作能保证没有幻行问题。</li><li>可串行化：最高的事务隔离级别。强制事务串行化执行，避免了幻读问题，这种级别会在数据的每一行都加锁，会产生大量的超时和锁竞争，实际中很少用到，除非要确保数据的一致性且没有并发问题</li></ul><h3 id="怎么理解脏读、不可重复读和幻读"><a href="#怎么理解脏读、不可重复读和幻读" class="headerlink" title="怎么理解脏读、不可重复读和幻读"></a>怎么理解脏读、不可重复读和幻读</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读是读到了未提交事务的数据。只有在读未提交隔离级别下，才会出现脏读。</p><p>解决脏读的办法就是升级事务隔离级别，比如读已提交。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>事务A 先读取一条数据，然后执行逻辑的过程中，事务B更新了这条数据，事务A在读取时，发现数据不一致了，这种现象就是不可重复读。</p><ul><li>简单理解就是两次读取的数据中间被修改，对应的隔离级别是读未提交或读已提交</li><li>不可重复读的解决方法就是升级事务隔离级别，比如可重复读</li></ul><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>在一个事物内，同一条查询语句在不同时间段内，得到不同的结果集。幻读和不可重复读的区别，简单理解，不可重复读发送在update，幻读发生在insert或delete。</p><ul><li>想解决幻读不能升级事务隔离级别到可串行化，这种级别下数据库也是去了并发处理能力</li><li>行锁解决不了幻读，因为即使锁住所有记录，还是阻止不了插入新数据</li><li>解决幻读的办法是锁住记录之间的间隙，MySQL InnoDB 引入了间隙锁（Gap Lock）。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>今天我们所讲的数据库是MySQL。InnoDB支持行/表级锁，默认行级锁。</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>又称读锁（S锁），是读取操作创建的锁，其他用户可以并发的读取数据，但任何事务都不能对数据修改，直至释放所有的共享锁。</p><p> <strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>又称写锁（X锁），如果事务A对某数据加上了排他锁后，别的事物不能对该数据加任何类型的锁</p><p> <strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>1、在同一资源上面，不能共同存在共享和排他<br>2、可以共同存在共享锁<br>3、不能共同存在排他锁</p><h3 id="行级锁和表锁"><a href="#行级锁和表锁" class="headerlink" title="行级锁和表锁"></a>行级锁和表锁</h3><p>行级锁：一种X锁，防止其他事务修改加锁的这行数据<br>        如果被锁定的字段不是主键，也没有针对它建立索引，数据库会锁住扫过的所有数据。<br>表级锁：对当前整张表进行加锁</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是基于一种具有“乐观”的思想，假设数据库操作的并发非常少，多数情况下是没有并发的，更新是按照顺序执行的，少有的一些并发通过版本控制来防止脏数据的产生。事务每次操作的时候，别的事务都不会修改这些数据。所以在访问之前不要求上锁，只是在更新修改操邹的时候判断一下在访问期间有没有别的事务对数据修改，判断是否冲突。这种适合多读的应用类型。<br>通常可以在数据表中加一个version字段，每次操作，version加1。更新是判断version的值是否和之前相等；或者判断时间戳来控制版本。<br>乐观锁在同一时刻，只有一个请求会成功，适用并发不高的场景。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>事务提交操作的时候，别的事务也对该数据块进行了修改，所以访问之前都需要上锁。这个需要数据库自己实现，我们直接调用数据库相关语句就可以了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> id <span class="operator">=</span> $id <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>悲观锁是在数据库引擎层次实现的，它能够阻止所有的数据库操作。但是为了更新一条数据，需要提前对这条数据上锁，直到这条数据处理完成，事务提交，别的请求才能更新数据，因此，悲观锁的性能比较低下，但是由于它能够保证更新数据的强一致性，是最安全的处理数据库的方式，因此，有些账户、资金处理系统仍然使用这种方式，牺牲了性能，但是获得了安全，规避了资金风险。 </p><h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>间隙锁是InnoDB 在可重复度隔离级别下解决幻读问题引入的锁机制。在可重复度隔离级别下，数据库通过行锁和间隙锁共同组成的（next-key lock）来实现。</p><p>产生间隙锁条件（PR 隔离级别下）:</p><ul><li>使用普通索引锁定</li><li>使用多列唯一索引</li><li>使用唯一索引锁定多行记录</li></ul><p>如果想打开MySQL间隙锁，使用命令 <code>show variables like &#39;innodb_locks_unsafe_for_binlog&#39;;</code> 查询 <code>innodb_locks_unsafe_for_binlog</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/%E9%94%81%E6%9C%BA%E5%88%B6.md">数据库并发锁机制</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Sharding-Sphere 实现的分库分表</title>
      <link href="sharding-sphere-sharding-databases-tables/"/>
      <url>sharding-sphere-sharding-databases-tables/</url>
      
        <content type="html"><![CDATA[<p>现在国内对于数据库分库分表的开源方案，主要是mycat和sharding-sphere，本文主要是自己对于sharding-sphere使用的一些记录。</p><h1 id="sharding-sphere简单介绍"><a href="#sharding-sphere简单介绍" class="headerlink" title="sharding-sphere简单介绍"></a>sharding-sphere简单介绍</h1><p>Sharding-JDBC 采用在 JDBC 层扩展分库分表，支持读写分离，是一个以 jar 形式提供服务的轻量级组件，其核心思路是小而美地完成最核心的事情，基于 JDBC 层进行分片的好处是轻量、简单、兼容性好以及无需额外的运维工作。缺点是无法跨语言，目前仅支持 Java。</p><p>Sharding-Sphere的3个产品的数据分片主要流程是一致的。核心思想是：SQL解析 =&gt; 执行器优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并的流程组成。(详情查看官网文档)</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190610143517.png"></p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><strong>开发环境：</strong> 项目搭建使用的是 Spring Boot + Sharding-Sphere + MyBatis。</p><p>注意：Sharding-Sphere 对于Spring-Boot 好像还不支持2.x版本以上，请选择1.x版本，详细源码，请查看相应的demo。</p><p>分别创建2个数据库，然后创建相应的表，创建数据库DDL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order` (</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">344805296301932545</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order_item` (</span><br><span class="line">  `order_item_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`order_item_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心Maven依赖(版本：4.0.0-RC1)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">for</span> spring boot --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="variable">$&#123;sharding-sphere.version&#125;</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">for</span> spring namespace --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-namespace&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="variable">$&#123;sharding-sphere.version&#125;</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>集成sharding-sphere的核心配置文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring.shardingsphere.datasource.names=ds0,ds1</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.ds0.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.ds0.jdbcUrl=jdbc:mysql://localhost:3306/ds0?serverTimezone=UTC&amp;useSSL=<span class="literal">false</span>&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.ds0.username=root</span><br><span class="line">spring.shardingsphere.datasource.ds0.password=</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.ds1.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.shardingsphere.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.ds1.jdbcUrl=jdbc:mysql://localhost:3306/ds1?serverTimezone=UTC&amp;useSSL=<span class="literal">false</span>&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=UTF-8</span><br><span class="line">spring.shardingsphere.datasource.ds1.username=root</span><br><span class="line">spring.shardingsphere.datasource.ds1.password=</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column=user_id</span><br><span class="line">spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression=ds$-&gt;&#123;user_id % 2&#125;</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.key-generator.column=order_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.key-generator.type=SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order_item.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order_item</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order_item.key-generator.column=order_item_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order_item.key-generator.type=SNOWFLAKE</span><br></pre></td></tr></table></figure><p>下面就是和平时一样搭建MyBatis部分了，这部分就不详细介绍了。</p><p>本人写了插入和查询测试样例，实现了数据库的分库分表功能。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/tedburner/sharding-sphere">本文源码GitHub地址</a></li><li><a href="https://github.com/apache/incubator-shardingsphere-example">当当Sharding-Shere源码例子</a></li><li><a href="https://shardingsphere.apache.org/document/current/cn/quick-start/">当当Sharding-Shere 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分库分表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sharding-sphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SPI 机制</title>
      <link href="java-spi/"/>
      <url>java-spi/</url>
      
        <content type="html"><![CDATA[<p>今天在看dubbo源码的时候，看到大量的SPI，对于SPI不是很明白，于是网上看资料和例子，有了这篇文章。</p><p>SPI（Service Provider Interface），是Java提供的一套用来被第三方实现或者扩展的API，可以用来启动框架扩展和替换组件。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190509153958.png"></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>数据库驱动加载</li><li>dubbo</li><li>日志门面模式实现不同日志</li></ul><h1 id="SPI-的使用"><a href="#SPI-的使用" class="headerlink" title="SPI 的使用"></a>SPI 的使用</h1><h2 id="定义接口并实现接口"><a href="#定义接口并实现接口" class="headerlink" title="定义接口并实现接口"></a>定义接口并实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spi接口</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Spi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World! This is a Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Spi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World! This is a Dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="src-main-resources-创建文件"><a href="#src-main-resources-创建文件" class="headerlink" title="src/main/resources/ 创建文件"></a>src/main/resources/ 创建文件</h2><p>在src/main/resources/ 目录下创建 /META-INF/services文件（关于services文件夹，如果使用Java自带的需要使用这个名字，如果自己实现可以自定义），并在文件夹中<strong>创建与接口同名的文件</strong>——<code>com.example.spi.Spi</code>：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190509194417.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ServiceLoader&lt;Spi&gt; services = ServiceLoader.load(Spi.class);</span><br><span class="line">    Iterator&lt;Spi&gt; iterator = services.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        iterator.next().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World! This is a Cat</span><br><span class="line">Hello World! This is a Dog</span><br></pre></td></tr></table></figure><h1 id="SPI-原理解析"><a href="#SPI-原理解析" class="headerlink" title="SPI 原理解析"></a>SPI 原理解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//被加载的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModuleLayer layer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于定位、加载和初始化providers的加载类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ServiceLoader是用于上下文切换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存providers，按实例化的顺序排列</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;S&gt; instantiatedProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lazy-lookup iterator for stream operations</span></span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Provider&lt;S&gt;&gt; loadedProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> loadedAllProviders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li><p>用ServiceLoader.load方法ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：</p><ul><li>loader(ClassLoader类型，类加载器)</li><li>  acc(AccessControlContext类型，访问控制器)</li><li>  providers(LinkedHashMap&lt;String,S&gt;类型，用于缓存加载成功的类)</li><li>lookupIterator(实现迭代器功能)</li></ul></li><li><p>应用程序通过迭代器接口获取对象实例</p></li><li><p>读取配置文件</p></li><li><p>通过反射Class.forName()加载类对象，并初始化</p></li><li><p>把实例化后的类缓存到providers对象中，然后返回实例对象</p></li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul><li><a href="https://github.com/tedburner/JavaExample/tree/master/src/main/java/com/example/spi">Demo源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC系列之基于ZooKeeper实现服务注册中心</title>
      <link href="rpc-zk-registry-discovery/"/>
      <url>rpc-zk-registry-discovery/</url>
      
        <content type="html"><![CDATA[<p>最近在看与RPC相关的东西，在GitHub上看到一个使用Java实现的简单RPC框架，于是自己也想用Java实现一个简单的RPC，以便加深对于RPC框架的理解。本篇文章主要是记录如何使用ZooKeeper作为RPC框架的注册中心，实现服务的注册和发现。</p><h1 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h1><p>RPC，即 Remote Procedure Call（远程过程调用），说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><h1 id="基于ZooKeeper实现的服务注册中心"><a href="#基于ZooKeeper实现的服务注册中心" class="headerlink" title="基于ZooKeeper实现的服务注册中心"></a>基于ZooKeeper实现的服务注册中心</h1><p>如果对于dubbo这款国产RPC框架有一定的了解，就知道最开始它是基于ZooKeeper实现服务的注册和发现的。关于服务的注册和发现，主要是把服务名以及服务相关的服务器IP地址注册到注册中心，在使用服务的时候，只需要根据服务名，就可以得到所有服务地址IP，然后根据一定的负载均衡策略来选择IP地址。</p><p>下图是服务的注册和发现接口：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190504154853.png"></p><h2 id="服务的注册"><a href="#服务的注册" class="headerlink" title="服务的注册"></a>服务的注册</h2><p>在ZooKeeper的节点概念中，Znode有四种类型，PERSISTENT（持久节点）、PERSISTENT_SEQUENTIAL（持久的连续节点）、EPHEMERAL（临时节点）、EPHEMERAL_SEQUENTIAL（临时的连续节点）。Znode的类型在创建时确定并且之后不能再修改。</p><p>关于服务的注册，其实就是把服务和IP注册到ZooKeeper的节点中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperServiceRegistry</span><span class="params">(String zkAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 ZooKeeper 客户端</span></span><br><span class="line">    zkClient = <span class="keyword">new</span> ZkClient(zkAddress, ZkConstants.SESSION_TIMEOUT, ZkConstants.CONNECTION_TIMEOUT);</span><br><span class="line">    log.info(<span class="string">&quot;connect zookeeper&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, String serviceAddress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String registryPath = ZkConstants.REGISTRY_PATH;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(registryPath)) &#123;</span><br><span class="line">            zkClient.createPersistent(registryPath);</span><br><span class="line">            log.info(<span class="string">&quot;zk create registry node: &#123;&#125;&quot;</span>, registryPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建服务节点（持久化）</span></span><br><span class="line">        String servicePath = registryPath + <span class="string">&quot;/&quot;</span> + serviceName;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(servicePath)) &#123;</span><br><span class="line">            zkClient.createPersistent(servicePath);</span><br><span class="line">            log.info(<span class="string">&quot;zk create service node: &#123;&#125;&quot;</span>, servicePath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 address 节点（临时）</span></span><br><span class="line">        String addressPath = servicePath + <span class="string">&quot;/address-&quot;</span>;</span><br><span class="line">        String addressNode = zkClient.createEphemeralSequential(addressPath, serviceAddress);</span><br><span class="line">        log.info(<span class="string">&quot;zk create ip address node: &#123;&#125;&quot;</span>,addressNode);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;zk create error: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务的发现"><a href="#服务的发现" class="headerlink" title="服务的发现"></a>服务的发现</h2><p>通过ZooKeeper的节点把服务名和IP写入其节点中，这样就实现了最简单的服务注册，下面来看下服务的发现。</p><p>服务的发现就是根据服务名来获取ZooKeeper节点中的IP地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String zkAddress;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperServiceDiscovery</span><span class="params">(String zkAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.zkAddress = zkAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">discover</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">    ZkClient zkClient = <span class="keyword">new</span> ZkClient(zkAddress, ZkConstants.SESSION_TIMEOUT, ZkConstants.CONNECTION_TIMEOUT);</span><br><span class="line">    log.info(<span class="string">&quot;connect zookeeper....&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String servicePath = ZkConstants.REGISTRY_PATH + <span class="string">&quot;/&quot;</span> + serviceName;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(servicePath)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(String.format(<span class="string">&quot;can not find any service node on path: %s&quot;</span>, servicePath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取路径的子节点</span></span><br><span class="line">        List&lt;String&gt; addressList = zkClient.getChildren(servicePath);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(addressList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(String.format(<span class="string">&quot;can not find any address node on path: %s&quot;</span>, servicePath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取 address 节点</span></span><br><span class="line">        String address;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(addressList.size(), <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果只有一个地址，则获取地址</span></span><br><span class="line">            address = addressList.get(<span class="number">0</span>);</span><br><span class="line">            log.info(<span class="string">&quot;get only address node: &#123;&#125;&quot;</span>, address);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果有多个ip，随机选择一个</span></span><br><span class="line">            address = addressList.get(ThreadLocalRandom.current().nextInt(addressList.size()));</span><br><span class="line">            log.info(<span class="string">&quot;get random address node:&#123;&#125;&quot;</span>, address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取 address 节点的值</span></span><br><span class="line">        String addressPath = servicePath + <span class="string">&quot;/&quot;</span> + address;</span><br><span class="line">        <span class="keyword">return</span> zkClient.readData(addressPath);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zkClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过测试样例，实现了最简单的服务注册和发现功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ServiceRegistry registry = <span class="keyword">new</span> ZooKeeperServiceRegistry(<span class="string">&quot;127.0.0.1:2181&quot;</span>);</span><br><span class="line">    registry.register(<span class="string">&quot;rpc&quot;</span>, <span class="string">&quot;192.168.20.49:8080&quot;</span>);</span><br><span class="line">    ServiceDiscovery discovery = <span class="keyword">new</span> ZooKeeperServiceDiscovery(<span class="string">&quot;127.0.0.1:2181&quot;</span>);</span><br><span class="line">    String address = discovery.discover(<span class="string">&quot;rpc&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务RPC的地址是：&quot;</span> + address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务RPC的地址是：192.168.20.49:8080</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://my.oschina.net/huangyong/blog/361751">轻量级分布式 RPC 框架</a></li><li><a href="https://github.com/tedburner/Simple-Rpc">GitHub源码地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> rpc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用队列 ReferenceQueue</title>
      <link href="java-reference-queue/"/>
      <url>java-reference-queue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有什么错误的地方，希望指出。</p></blockquote><p>前几天有个面试，在面试最后的时候，面试官说问个比较偏僻的知识点，问了关于Java引用的。于是我就把<a href="https://jlj98.top/jvm-gc/#%E5%BC%95%E7%94%A8">四种引用</a>说了下。然后又问，你知道引用队列嘛？然后我懵逼了，只能说我不知道。</p><p>关于Java中的引用，可以看上面的链接，引用主要用于GC中的。</p><p>引用队列 ReferenceQueue 是用来配合引用工作的，没有 ReferenceQueue 一样可以运行。创建引用的时候可以指定关联的队列，<strong>当GC释放对象内存的时候，会将引用加入到引用队列的队列末尾，这相当于是一种通知机制</strong>。当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。JVM提供了一个ReferenceHandler线程，将引用加入到注册的引用队列中。</p><p>关于引用队列，其类位于ref中，如图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190218110328.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用队列</span></span><br><span class="line">ReferenceQueue&lt;String&gt; rq = newReferenceQueue&lt;String&gt;();</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; sr = newSoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Soft&quot;</span>),rq);</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; wr = newWeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Weak&quot;</span>),rq);</span><br><span class="line"><span class="comment">// 幽灵引用</span></span><br><span class="line">PhantomReference&lt;String&gt; pr = newPhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Phantom&quot;</span>),rq);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从引用队列中弹出一个对象引用</span></span><br><span class="line">Reference&lt;? extends String&gt; ref = rq.poll();</span><br></pre></td></tr></table></figure><p>ReferenceQueue 提供了三种方法来移除队列：</p><ul><li>poll()：用于移除并返回该队列中的下一个引用对象，如果队列为空，则返回null</li><li>remove()：用于移除并返回该队列中的下一个引用对象，该方法会在队列返回可用引用对象之前一直阻塞</li><li>remove (long timeout)：用于移除并返回队列中的下一个引用对象。该方法会在队列返回可用引用对象之前一直阻塞，或者在超出指定超时后结束。如果超出指定超时，则返回null。如果指定超时为0，意味着将无限期地等待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                WeakReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span> ((k = (WeakReference) referenceQueue.remove()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">&quot;回收了:&quot;</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(bytes, referenceQueue);</span><br><span class="line">            map.put(weakReference, object);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;map.size-&gt;&quot;</span> + map.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为map的key是WeakReference，所以在内存不足的时候，weakReference所指向的对象就会被GC，在对象被GC的同时，会把该对象的包装类即weakReference放入到ReferenceQueue里面。但是这个map的大小是10000。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询和更新原理</title>
      <link href="mysql-execute-process/"/>
      <url>mysql-execute-process/</url>
      
        <content type="html"><![CDATA[<p>在对于MySQL的优化，网上有很多小技巧，比如加<a href="https://jlj98.top/mysql-index/">索引</a>。不过前几天在极客时间上买了门《MySQL实战45讲》。这篇文章主要是在学习过程中关于MySQL原理的一些笔记。</p><p>在学习如何优化的过程中，最好对于MySQL查询的过程有一定的理解，这样有利于如何进行优化。下面这张图片是MySQL的逻辑框架：</p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200423095355.png" width="50%" height="50%"><p>MySQL从图中可以看出，一般分为三部分：客户端、核心服务、存储引擎。客户端这个就不说了，主要是Java这些客户端；而关于存储引擎的，在之前整理的一篇文章有简绍——<a href="https://jlj98.top/mysql-innodb-myisam/">MySQL的存储引擎 —— InnoDB和MyIsAM</a>。所以今天主要是讲解下关于核心服务。</p><h1 id="MySQL优化原理"><a href="#MySQL优化原理" class="headerlink" title="MySQL优化原理"></a>MySQL优化原理</h1><h2 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h2><blockquote><p>mysql&gt; select * from T where ID=10；</p></blockquote><p>当我们输入上面这一条SQL查询语句的时候，发生了什么？</p><p>这里面主要涉及的是核心服务中的模块：连接器、查询缓存、分析器、优化器、执行器等，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要的功能是跟客户端建立连接，获取权限，维持和管理连接。一般的命令：</p><blockquote><p>mysql -h$ip -P$port -u$user -p</p></blockquote><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>当MySQL获取到一个查询SQL的时候，会查看缓存，判断这条SQL是否已经执行过了。之前的执行结果会已key-value保存，key是查询SQL，value是查询结果。</p><p>之前看网上说，在MySQL8里面，已经去掉了缓存模块。从这里可以看出，在工作中，不建议使用MySQL的缓存。主要是当一个表更新数据的时候，这张表的缓存数据都会被清空，所以缓存适合哪种表内数据变化不大的表。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果上面没有命中缓存，就开始真正的执行SQL了。在这一步，MySQL对SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。</p><p><code>Unknown column ‘k’ in ‘where clause</code> 这种错误也是在这一层中出现的。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>这一步需要对解析后的SQL进行优化，比如使用什么索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>这一步主要先获取是否对该表有权限操作，然后就是从存储引擎中获取数据。</p><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>更新SQL执行和上面的过程大致相同。分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>更新模块主要在涉及了两个日志模块：redo log（重做日志） 和 binlog（归档日志）。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <code>redo log</code> 里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>在InnoDB中，redo log 日志是固定大小的，比如分配4个文件，每个文件1G，这样就有4G。在写的时候，就会从头开始写，写到末尾又从新开始循环写。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log 是位于InnoDB存储引擎中的，而binlog 则是位于server层的。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>redo log</code> 是 InnoDB 引擎特有的；<code>binlog</code> 是 MySQL 的 Server层实现的，所有引擎都可<br>以使用。</li><li><code>redo log</code> 是物理日志，记录的是“在某个数据页上做了什么修改”；<code>binlog</code> 是逻辑日志，记录的是这个语句的原始逻辑，比如“给=2这一行的c字段加1”。</li><li><code>redo log</code> 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 <code>binlog</code> 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</li></ul><h2 id="UPDATE-语句更新流程"><a href="#UPDATE-语句更新流程" class="headerlink" title="UPDATE 语句更新流程"></a>UPDATE 语句更新流程</h2><ul><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为了保证两份日志中的逻辑的完整性和正确性，MySQL使用的是两阶段提交来保证数据的完整性。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《高性能MySQL》</li><li>极客时间《MySQL实战45讲》</li><li><a href="https://mp.weixin.qq.com/s/n1qGSYnVn3Rg2LoC2zzU6g">我必须得告诉大家的MySQL优化原理</a></li></ul><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190216152529.png" width = "200" height = "200" div align=center />]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future 模式搭配线程池更配哦</title>
      <link href="java-future-callback/"/>
      <url>java-future-callback/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错，希望在下面的留言区指正。</p></blockquote><p>在开篇，先提出一个问题，在Java中，通过继承 Thread 或者实现 Runable 创建一个线程的时候，如何获取该线程的返回结果呢？</p><p>在并发编程中，使用非阻塞模式的时候，就是出现上面的问题。这个时候就需要用到这次所讲的内容了——Future。</p><h1 id="Future-主要功能"><a href="#Future-主要功能" class="headerlink" title="Future 主要功能"></a>Future 主要功能</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用该方法来取消一个任务，若取消成功，则返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断任务是否已经取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断任务是否已经完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当任务结束返回一个结果，如果调用时，为返回结果，则阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定时间内获取指定结果，如果没有获取，则返回null</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Future-例子"><a href="#Future-例子" class="headerlink" title="Future 例子"></a>Future 例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程在执行任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task运行结果&quot;</span> + result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子线程在进行计算&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Future-适用场景"><a href="#Future-适用场景" class="headerlink" title="Future 适用场景"></a>Future 适用场景</h1><p>在之前的一篇关于<a href="https://jlj98.top/java-thread-pool">线程池</a>中，详细介绍了Java的一些线程池知识点。那么对于使用线程池，除了管理线程资源外，如何能够实现节约时间呢？</p><p>比如现在一个请求中，给前端的返回结果，需要通过查询A、B、C，最后返回给前端，这三个查询分别耗时 10ms、20ms、10ms。如果正常的查询需要耗时40ms（忽略别的影响查询时间的因素）。但是如果把这三个查询交给线程池进行异步查询，那么，它的最终耗时是由最大耗时的那个查询决定的，这时就会发现查询变快了，只耗时20ms。</p><p>但是使用线程池的时候，这就和上面一开始的问题类似了，如何去获取线程池返回的结果。<a href="https://github.com/tedburner/spring-boot-examples/tree/master/common-kit/src/main/java/com/kit/common/util/thread">线程池代码Reference</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Future </tag>
            
            <tag> CallBack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 调优参数总结记录</title>
      <link href="jvm-parameter-configuration/"/>
      <url>jvm-parameter-configuration/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有错希望指出。本文是在看到一些关于JVM参数调优文章后的一些内容摘要。</p></blockquote><h2 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h2><h3 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h3><p>设置JVM 初始内存，即JVM启动时分配的内存。此值可以设置与 -Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存。</p><h3 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h3><p>设置JVM 运行过程中分配的最大可用内存。</p><h3 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h3><p>-Xss128k：设置每个线程的堆栈大小。</p><h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>设置年轻代大小。</p><h2 id="打印-GC"><a href="#打印-GC" class="headerlink" title="打印 GC"></a>打印 GC</h2><ul><li>-XX:+PrintGC：打印 GC 信息</li><li>-XX:+PrintGCDetails</li><li>-XX:PrintHeapAtGC：打印GC前后的详细堆栈信息</li></ul><h2 id="XX-AlwaysPreTouch"><a href="#XX-AlwaysPreTouch" class="headerlink" title="-XX:+AlwaysPreTouch"></a>-XX:+AlwaysPreTouch</h2><p>JAVA进程启动的时候，虽然我们可以为JVM指定合适的内存大小，但是这些内存操作系统并没有真正的分配给JVM，而是等JVM访问这些内存的时候，才真正分配，这样会造成以下问题：</p><ul><li>第1次YGC之前Eden区分配对象的速度较慢;</li><li>YGC的时候，Young区的对象要晋升到Old区的时候，这个时候需要操作系统真正分配内存，这样就会加大YGC的停顿时间;</li></ul><p><code>AlwaysPreTouch</code> 参数可以优化上面的问题，但是它的副作用会导致 JVM 进程启动时间变长。</p><h2 id="启动时间变长原因"><a href="#启动时间变长原因" class="headerlink" title="启动时间变长原因"></a>启动时间变长原因</h2><p>在没有配置-XX:+AlwaysPreTouch参数即默认情况下，JVM参数-Xms申明的堆只是在虚拟内存中分配，而不是在物理内存中分配：它被以一种内部数据结构的形式记录，从而避免被其他进程使用这些内存。这些内存页直到被访问时，才会在物理内存中分配。当JVM需要内存的时候，操作系统将根据需要分配内存页。</p><p>配置-XX:+AlwaysPreTouch参数后，JVM将-Xms指定的堆内存中每个字节都写入’0’，这样的话，除了在虚拟内存中以内部数据结构保留之外，还会在物理内存中分配。并且由于touch这个行为是单线程的，因此它将会让JVM进程启动变慢。所以，要么选择减少接下来对每个缓存页的第一次访问时间，要么选择减少JVM进程启动时间，这是一种trade-off。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程——IO、NIO、Netty</title>
      <link href="net-io-nio-netty/"/>
      <url>net-io-nio-netty/</url>
      
        <content type="html"><![CDATA[<p>IO 最早指的是文件的Input/Output，之后 IO 也包括网络 IO。</p><h1 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h1><p>网络 IO 编程只要一个线程过来就需要创建一个线程，这样会导致资源不够用，很浪费资源。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起</li><li>线程切换效率低下：单机 CPU 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li><li>除了以上两个问题，IO 编程中，我们看到数据读写是以字节流为单位。</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190113093511.png"></p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO 模型中，它把这么多 while 死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个 while 死循环就能监测1w个连接是否有数据可读的。这就是 NIO 模型中 selector 的作用，一条连接来了之后，现在不创建一个 while 死循环去监听是否有数据可读了，而是直接把这条连接注册到 selector 上，然后，通过检查这个 selector，就可以批量监测出有数据可读的连接，进而读取数据。</p><p>NIO 主要有三大核心部分：Channel(通道)、Buffer(缓冲区)、Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道中。Selector 用于监听多个通道的时间。因此，单个线程可以监听多个数据通道。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的通道，但是读取或写入的数据必须经由 Buffer。</p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。</p><h1 id="IO-和-NIO-的区别"><a href="#IO-和-NIO-的区别" class="headerlink" title="IO 和 NIO 的区别"></a>IO 和 NIO 的区别</h1><h2 id="读写方式"><a href="#读写方式" class="headerlink" title="读写方式"></a>读写方式</h2><p>IO 读写是面向<strong>流</strong>的，一次性只能从流中读取一个或者多个字节，并且读完之后流无法再读取，你需要自己缓存数据。</p><p>Java NIO 的读写是面向 <strong>Buffer</strong> 的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><h2 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h2><p><strong>Java IO 的各种流是阻塞的</strong>。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p><p><strong>Java NIO 的非阻塞模式</strong>，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h2 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h2><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p><h1 id="网络-IO-模型"><a href="#网络-IO-模型" class="headerlink" title="网络 IO 模型"></a>网络 IO 模型</h1><ul><li>同步</li><li>异步</li><li>阻塞式 IO</li><li>非阻塞式 IO</li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步关注的是消息通信机制(谓同步,就是在发出一个<em>调用时,在没有得到结果之前,该</em>调用就不返回。但是一旦调用主动等待这个调用*的结果</p><p>而异步则是相反,<em>调用在发出之后,这个调用就直接返回了,所以没有返回结果。换句话说,当<br>用者不会立刻得到结果。而是在</em>调用*发出后,<em>被调用者</em>通过状知来通知调用者,或通过回调函数处理这个调用</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>塞和非阻塞关注的是程序在等待调用结果(消息，返回值)时的状态。</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p>Nety是一款高性能、异步事件驱动的 NIO 框架，基于 Java NIO 提供的 API 实现。它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有IO操作都是异步非阻塞的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://pan.baidu.com/s/1WRBQ8OjklntV14r0j02MsA">Netty实战</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> NIO </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— Docker 网络通信</title>
      <link href="docker-network/"/>
      <url>docker-network/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有什么错误的地方，希望指出。本文是本人对 Docker 网络通信学习的笔记。</p></blockquote><p>Docker容器和服务如此强大的原因之一是您可以将它们连接在一起，或者将它们连接到非Docker工作负载。Docker容器和服务甚至不需要知道它们部署在Docker上，或者它们的对等体是否也是Docker工作负载。无论您的Docker主机是运行Linux，Windows还是两者兼而有之，您都可以使用Docker以与平台无关的方式管理它们。（PS：官网翻译）</p><h1 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h1><ul><li>bridge：默认网络驱动程序。如果未指定驱动程序，则这是您要创建的网络类型。当您的应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。</li><li>host：对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。host 仅适用于Docker 17.06及更高版本上的群集服务。</li><li>none：对于此容器，禁用所有网络。通常与自定义网络驱动程序一起使用。none不适用于群组服务</li><li>overlay：Macvlan网络允许您为容器分配MAC地址，使其显示为网络上的物理设备。Docker守护程序通过其MAC地址将流量路由到容器。macvlan 在处理期望直接连接到物理网络的传统应用程序时，使用驱动程序有时是最佳选择，而不是通过Docker主机的网络堆栈进行路由。</li><li>Network plugins：您可以使用Docker安装和使用第三方网络插件。</li></ul><h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>在网络方面，桥接网络是链路层设备，它在网络段之间转发流量。网桥可以是硬件设备或在主机内核中运行的软件设备。</p><p>Docker 的桥接网络使用软件桥接器，改桥接器允许连接到同一网桥的容器进行通信，同时提供与未连接到该网桥的容器的隔离。</p><p>桥接网络适用于在同一个 Docker守护程序主机上运行的容器。对于在不同Docker守护程序主机上运行的容器之间的通信，您可以在操作系统级别管理路由，也可以使用覆盖网络。</p><p>启动Docker时，会自动创建默认桥接网络（也称为bridge），并且除非另行指定，否则新启动的容器将连接到该网络。您还可以创建用户定义的自定义网桥。用户定义的网桥优于默认bridge 网络。</p><p>在Docker进行启动时，会在主机上创建一个名为 docker0 的虚拟网桥，在主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器通过交换机连载了一个二层网络中。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20190104153031.png"></p><h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>如果host对容器使用网络驱动程序，则该容器的网络堆栈不会与Docker主机隔离。例如，如果您运行绑定到端口80 host的容器并使用网络，则容器的应用程序将在主机IP地址的端口80上可用。</p><p>主机网络驱动程序仅适用于Linux主机。</p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p>该overlay网络驱动程序会创建多个码头工人守护主机之间的分布式网络。该网络位于（覆盖）特定于主机的网络之上，允许连接到它的容器（包括群集服务容器）安全地进行通信。Docker透明地处理每个数据包与正确的Docker守护程序主机和正确的目标容器的路由。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.docker.com/network/">Docker NetWork 官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程——CAS</title>
      <link href="java-cas/"/>
      <url>java-cas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错，希望在下面的留言区指正。</p></blockquote><p>在之前的一些源码分析中，为了实现并发，Doug Lea 大佬在Java8及以上，大量使用了 CAS 操作。JDK 提供的关于 CAS 原子操作的类在下面工具包里面：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181227151546.png"></p><p>JDK为Java基本类型都提供了CAS工具类。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>以 <code>AtomicInteger</code> 为例，进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的源码，对于 CAS 操作，这里会出现3个值，expect、update、value。只有当expect和内存中的value相同时，才把value更新为update。</p><h1 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h1><p>假设如下事件序列：</p><blockquote><p>线程 1 从内存位置V中取出A。<br>线程 2 从位置V中取出A。<br>线程 2 进行了一些操作，将B写入位置V。<br>线程 2 将A再次写入位置V。<br>线程 1 进行CAS操作，发现位置V中仍然是A，操作成功。</p></blockquote><p>尽管上面的CAS操作成功了，数据也没有问题，但是程序失去了对数据变换的敏感性，不知道数据的变换。</p><blockquote><p>比如发生扣款/收款行为时，应当收到短信通知这个场景，<br>1、时刻1 : 500元<br>2、时刻2：转给了 A 10 元 490 元<br>3、时刻3：B 转入 10 元 500 元<br>应当收到两条短信，而不是最后我的账户余额没有变化，就一条短信都收不到</p></blockquote><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181227152525.png"></p><p>上面的图片来源不知道是谁的，只是在一个技术群里和别人聊CAS时别人发的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>JDK 为了解决 ABA 问题，提供了一些方法，如 <code>AtomicStampedReference</code>，在版本的更新过程中，添加了一个 <code>stamp</code> 邮戳来标记数据的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference, V newReference, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获得当前对象引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//获得当前时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置当前对象引用和时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure><p>具体关于 CAS 操作源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面所示，在更新的过程中，除了比较内存中value的预期值，还比较了 stamp 的预期值，只有两者都相同的时候，才会把内存中的值更新掉。</p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p><code>AtomicMarkableReference</code> 和 <code>AtomicStampedReference</code> 功能相似，但<code>AtomicMarkableReference</code> 描述更加简单的是与否的关系。它的定义就是将状态戳简化为true|false。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V       expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V       newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> expectedMark,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> newMark)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedMark == current.mark &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newMark == current.mark) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newMark)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能队列 —— Disruptor</title>
      <link href="disruptor/"/>
      <url>disruptor/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>LMAX Disruptor是一个高性能的线程间消息传递库。它源于LMAX对并发性，性能和非阻塞算法的研究，如今构成了其Exchange基础架构的核心部分。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://tech.meituan.com/disruptor.html">高性能队列——Disruptor</a></li><li><a href="https://github.com/LMAX-Exchange/disruptor">GitHub地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Disruptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BloomFilter 概念和原理</title>
      <link href="java-BloomFilter/"/>
      <url>java-BloomFilter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错，希望在下面的留言区指正。</p></blockquote><p>最近在看书的时候，看到说使用 BloomFilter 来进行判断一个元素是否<strong>最有可能</strong>属于一个集合，或者它是<strong>绝对不属于</strong>这个集合。BloomFilter 不适合“零错误”的场合，只能在能容忍地错误率的场合下使用，BloomFilter 通过极少的错误换取了存储空间的极大节省。</p><p>在Java中并不提供 BloomFilter  集合框架，使用者需要导入google guava jar包，提供了 BloomFilter。</p><p>BloomFilter 是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>BloomFilter 的数据结构是由两部分构成：</p><ul><li>一堆散列函数</li><li>一个位数组</li></ul><p>如下所示，定义一个10位的数组：<br>[0,0,0,0,0,0,0,0,0,0]</p><p>在添加元素，先对添加的元素使用 k 个hash函数，来计算出 k 个在数组中的位置，然后，将这些位置的 bit 置为 1。</p><p>例如，把输入的x经过两次hash，给出的位置分别是0和4，将这两个位置bit置为1。</p><p>[1, 0, 0, 0, 1, 0, 0, 0, 0, 0]</p><h2 id="为什么会出现可能出错"><a href="#为什么会出现可能出错" class="headerlink" title="为什么会出现可能出错"></a>为什么会出现可能出错</h2><p>如下图所示，现在输入 x 和 y 两个数，分别把相应的位置置为1，当我们输入下一个元素 a 是，经过 hash 函数，得出的位置 3 和 13（下标从0开始），在数组中，其实不存在 a，但是这两个位置分别是 x和y的某个hash位置，所以就会出现开始所说的，某个元素可能存在集合中。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181218151909.png"></p><h2 id="删除不可取"><a href="#删除不可取" class="headerlink" title="删除不可取"></a>删除不可取</h2><p>在 Bloomfilter 中不可删除元素，如果删除元素，会导致其他的一些元素不能被找到，当这些元素的某些下标和被删元素相同。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://juejin.im/post/5842e0b361ff4b006c2b3c9b">BloomFilter 原理，实现及优化</a></li><li><a href="https://juejin.im/post/5bfc90be5188254e2a04374b">如何判断一个元素在亿级数据中是否存在？</a></li><li><a href="https://sc5.io/posts/what-are-bloom-filters-and-why-are-they-useful/">What are Bloom filters, and why are they useful?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BloomFilter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议 —— TCP 和 UDP</title>
      <link href="net-tcp-udp/"/>
      <url>net-tcp-udp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错，希望在下面的留言区指正。</p></blockquote><p>TCP/IP 五层模型如图所示：</p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181216154911.png" width = "200" height = "200" div align=center /><h1 id="面向连接的-TCP"><a href="#面向连接的-TCP" class="headerlink" title="面向连接的 TCP"></a>面向连接的 TCP</h1><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次”对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181216155235.png"></p><p>TCP 建立连接如下图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181216155425.png"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181216160124.png"></p><p>先由客户端向服务器端发送一个FIN，请求关闭数据传输。</p><p>当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ</p><p>然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。</p><p>当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ</p><h1 id="面向非连接-UDP"><a href="#面向非连接-UDP" class="headerlink" title="面向非连接 UDP"></a>面向非连接 UDP</h1><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>TCP 面向连接；UDP 是无连接，即发送数据前不需要建立连接</li><li>TCP 提供可靠的服务，即通过 TCP 连接传送的数据，无差错，不丢失，不重复，且有序到达；UDP 尽最大努力交付，但不保证可靠交付。</li><li>UDP 具有较好的实时性，工作效率比 TCP 高，适用于高速传输和实时性较高的通信或者广播通信。</li><li>每一条 TCP 连接只能点到点的；UDP 支持一对一、一对多、多对一和多对多通信。</li><li>TCO 对系统资源需求比较多；UDP 对系统资源需求比较少。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://www.cnblogs.com/lms0755/p/9053119.html">图片来源</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多态</title>
      <link href="java-polymorphic/"/>
      <url>java-polymorphic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>虽然学习和使用 Java 好多年了，但是对于多态的整体概念还是有点模糊。今天在看之前写的关于<a href="https://jlj98.top/java-reflect/">反射</a>博文时，突然想到了 Java 的三大特性——多态。其他两个分别是**<a href="https://github.com/tedburner/JavaGuide/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81">封装、继承</a>**。只是想起多态的继承、重写，对于别的有点模糊了，于是就像自己整理下。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态指的是对象的多种形态。继承是多态的实现基础。当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>多态的分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show(<span class="keyword">new</span> Cat());</span><br><span class="line">        show(<span class="keyword">new</span> Dog());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上转型</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();<span class="comment">//调用的是Cat的 eat</span></span><br><span class="line">        <span class="comment">//当使用多态方式调用方法时，首先检查父类中是否有该方法，</span></span><br><span class="line">        <span class="comment">// 如果没有，则编译错误；如果有，再去调用子类的同名方法</span></span><br><span class="line">        animal.work();<span class="comment">//编译报错</span></span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">        cat.work();<span class="comment">//调用的是Cat的work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.work();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;look door....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p><code>Animal animal = new Cat();</code> 对于这个对象的创建，就是体现了向上转型。</p><p>子类引用的对象转换为父类类型成为向上转型。通俗的说就是将子类对象转化为父类对象，此处对象可以是接口。</p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p><code>Cat cat = (Cat) animal;</code> 这里就是向下转型。与向上转型相对应的就是向下转型了。向下转型是把父类对象转为子类对象。</p><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><ul><li>重写</li><li>接口</li><li>抽象类和抽象方法</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ul><li>消除类型的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul><li>继承</li><li>重写</li><li>父类引用子类对象</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://www.runoob.com/java/java-polymorphism.html">Java 多态 | 菜鸟教程</a></li><li><a href="https://blog.csdn.net/qq_31655965/article/details/54746235">重新认识java（五） —- 面向对象之多态（向上转型与向下转型）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 泛型中 ? super T 和 ? extends T 的区别</title>
      <link href="java-genericity-super-extends/"/>
      <url>java-genericity-super-extends/</url>
      
        <content type="html"><![CDATA[<p>最近在看阿里出的一本书 —— 《码出高效 Java 开发手册》，这本书不是之前那本关于 <a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/Java_1512024443940.pdf">Java 开发注意规范的手册</a>，这本书内容还是不错的，干货满满。</p><p>在看书的时候，就看到了关于上面讲的知识点，于是想到之前在看 Java 一些源码时候，也看到一些关于这个泛型的写法，当时还没注意，比如下面关于 ThreadLocal 源码是看到的。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181211102804.png"></p><p>这样以后看 Java 的源码就能看懂这些泛型的写法了。</p><? super T> 和 <? extends T> 是 Java 泛型中的 “通配符“和”边界”的概念。- <? super T> ： 是指“上界通配符”。 A super B 表示 A 是 B 的父类或者祖先，在 B 上面。- <? extends T>：是指“下界通配符”。A extends B 表示 A 是 B 的子类或者孙类，在 B 的下面。<? extends T>与<? super T>两种语法，但是两者的区别非常微妙。简单来说，<? extends T>是 Get first，适用于消费集合元素为主的场景；<? super T>是 Put First，适用于生产集合元素为主的场景。# <? extends T><? extends T>可以赋值给任何 T 及 T 子类的集合，上界为T，取出来的类型带有泛型限制，向上强制转型为T。null可以表示任何类型，所以除nul外，任何元素都不得添加进<? extends T>集合内。# <? super T><? super T>可以赋值给任何 T 及 T 的父类集合，下界为T。在生活中，投票选举类似于 <? super T> 的操作。选举代表时，你只能往里投选票，取数据时，根本不知道是谁的票，相当于泛型丢失。有人说，这只是一种生活场景，在系统设计中。很难有这样的情形。再举例说明一下，我们在填写对主管的年度评价时，提交后若想再次访问之前的链接修改评价，就会被告之：“您已经完成对主管的年度反馈,谢谢参与。" extends的场景是put功能受限，而 super的场景是get功能受限。# 集合和泛型下面的代码和说明出自《码出高效，Java开发手册》<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一阶段：泛型出现之前的集合定义方式</span></span><br><span class="line">        List a1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        a1.add(<span class="keyword">new</span> Object());</span><br><span class="line">        a1.add(<span class="keyword">new</span> Integer(<span class="number">111</span>));</span><br><span class="line">        a1.add(<span class="keyword">new</span> String(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : a1)&#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二段：把a1 引用赋值给a2，注意a2与a1的区别是增加了泛型限制&lt;Object&gt;</span></span><br><span class="line">        List&lt;Object&gt; a2 = a1;</span><br><span class="line">        a2.add(<span class="keyword">new</span> Object());</span><br><span class="line">        a2.add(<span class="keyword">new</span> Integer(<span class="number">222</span>));</span><br><span class="line">        a2.add(<span class="keyword">new</span> String(<span class="string">&quot;hello a2a2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三段:把a1引用赋值给a3,注意a3与a1的区别是增加了泛型&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Integer&gt; a3 = a1;</span><br><span class="line">        a3.add(<span class="keyword">new</span> Integer(<span class="number">333</span>));</span><br><span class="line">        <span class="comment">//下方两行编译出错,不允许增加非 Integer类型进入集合</span></span><br><span class="line">        a3.add(<span class="keyword">new</span> Object());</span><br><span class="line">        a3.add(<span class="keyword">new</span> String(<span class="string">&quot;hello a3a3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四段:把a1引用赋值给a4,a1与a4的区别是增加了通配符</span></span><br><span class="line">        List&lt;?&gt; a4 = a1;</span><br><span class="line">        a1.remove(<span class="number">0</span>);</span><br><span class="line">        a4.clear();</span><br><span class="line">        <span class="comment">//编译出错。不允许增加任何元素</span></span><br><span class="line">        a4.add(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>第一段说明：在定义List之后,毫不犹豫地往集合里装入三种不同的对象：Object、 Integer 和 String，遍历没有问题，但是贸然以为里边的元素都是 Integer，使用强制转化，则抛出 ClassCastException异常。第二段说明：把a赋值给a2，a2是 List<Object>类型的，也可以再往里装入三种不同的对象。很多程序员认为List和List<Object>是完全相同的，至少从目前这两段来看是这样的。第三段说明：由于泛型在JDK5之后才出现，考虑到向前兼容，因此历史代码有时需要赋值给新泛型代码，从编译器角度是允许的。这种代码似乎有点反人类，在实际故障案例中经常出现。第四段说明：问号在正则表达式中可以匹配任何字符，List<?><p>称为通配符集合。它可以接受任何类型的集合引用赋值，不能添加任何元素，但可以 remove 和 clear，并非 immutable集合。List&lt;?&gt;一般作为参数来接收外部的集合，或者返回一个不知道具体元素类型的集合。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《码出高效：Java开发手册》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 —— AQS</title>
      <link href="java-aqs/"/>
      <url>java-aqs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎指正。</p></blockquote><p>队列同步器（AbstractQueuedSynchronizer），是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态， 通用过内置的 FIFO 队列来，可以用于构建锁或者其他同步装置，完成资源获取线程的排队工作。</p><p>同步器的主要使用方法是继承、子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态镜像更改，这时就需要使用同步器提供的方法（getState()、setState(in newSate) 和 compareAndSetState(int expect, int update)）来进行操作。</p><p>AQS 是一个抽象类，内置<strong>自旋锁</strong>实现的同步队列，封装入队和出队的操作，提供独占、共享、中断等特性。</p><p><strong>基于AQS构建的同步器：</strong></p><ul><li>ReentrantLock</li><li>Semaphore</li><li>CountDownLatch</li><li>ReentrantReadWriteLock</li><li>SynchronusQueue</li><li>FutureTask</li></ul><h1 id="AQS-核心知识"><a href="#AQS-核心知识" class="headerlink" title="AQS 核心知识"></a>AQS 核心知识</h1><h2 id="队列同步器的接口与实例"><a href="#队列同步器的接口与实例" class="headerlink" title="队列同步器的接口与实例"></a>队列同步器的接口与实例</h2><p>重写同步器指定的方法是，需要使用同步器提供的3个方法来访问或者修稿同步状态：</p><ul><li>getState()：获取当前同步状态</li><li>setState(in newSate)：设置当前同步状态</li><li>ompareAndSetState(int expect, int update)：使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。</li></ul><h2 id="CLH-同步队列"><a href="#CLH-同步队列" class="headerlink" title="CLH 同步队列"></a>CLH 同步队列</h2><p>CLH 同步队列（Craig、Landin、Hagersten）是一个<strong>FIFO双向对象</strong>，AQS 依赖它来完成同步状态的管理，当线程如果获取同步状态失败时，AQS 则会将当前线程等待状态等信息构造成一个节点（Node）并将其加入到 CLH 同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 共享*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** 独占*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**  后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     * 表示下一次共享式同步状态获取将会无条件地传播下去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">/** 等待状态 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">/** 前驱节点*/</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/**后续节点*/</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">/** 获取同步状态的线程*/</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**Returns true if node is waiting in shared mode.*/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AQS-实现细节"><a href="#AQS-实现细节" class="headerlink" title="AQS 实现细节"></a>AQS 实现细节</h1><p>线程首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到FIFO队列中。 接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://mp.weixin.qq.com/s/-swOI_4_cxP5BBSD9wd0lA">【死磕Java并发】—–J.U.C之AQS（一篇就够了）</a></li><li>《Java并发编程艺术》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String s = new String(&quot;abc&quot;); 在运行时涉及几个String实例？</title>
      <link href="java-string-object/"/>
      <url>java-string-object/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有不正确的，欢迎指正。</p></blockquote><p><a href="https://jlj98.top/java-String-source/">String，StringBuilder，StringBuffer源码分析</a><br>上面这篇是之前写的关于 String 的一些介绍，有兴趣可以看下。</p><p>今天重新翻看 《Effective Java》这本书的时候，看到第五条：避免创建不必要的对象。文中是以 String s = new String(“stringette”); 拿来举例的。看到这里，就想起以前看一些面经中看到的一个问题，对于上面的的语句，在运行时涉及几个String实例？    </p><p>对于上面的答案： 两个，一个是字符串 “abc” 锁在常量池中的实例，另一个是通过 new String(String) 创建并初始化、内容与 “abc” 相同的实例。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181114142028.png"></p><p>但是对下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(s == s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181114142224.png"></p><p>字节码 ldc：将常量值从常量池中取出压入栈中。</p><p>通过查看上面代码的字节码的第0行和第7行可以看出，该字符串变量的值已经确定了，并没有重新创建一个变量，而是从缓冲区中取出，同时让该变量指向该字符串值。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://rednaxelafx.iteye.com/blog/774673">请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier、CountDownLatch 和 Semaphore 的比较</title>
      <link href="java-CyclicBarrier-CountDownLatch/"/>
      <url>java-CyclicBarrier-CountDownLatch/</url>
      
        <content type="html"><![CDATA[<p>Java 提供了很多同步工具，最近看Java锁的时候，看到了 CountDownLatch 和 Semaphore，同时了解到还有 CyclicBarrier，就想对它们做一个一定的了解。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch 是在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。使用一个计数器进行实践，计数器初始值为线程的数量。每当一个线程完成后，计数器的值就会减一。当计数器的值为0时，便是所有线程都完成了任务，然后等待的线程就可以恢复执行任务了。</p><blockquote><p>用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>CountDownLatch 是一次性的，计数值在构建的时候就已经初始化完成了。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>提供两种方法是当前线程处于等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p>当调用 countDown() 方法时，CountDownLatch 计数器就会减去一，而当计数器为0的时候，等待的线程就会被唤醒并执行线程。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier 是一个同步工具，允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）。</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="await-1"><a href="#await-1" class="headerlink" title="await()"></a>await()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h2><p>将屏障重置为其初始状态。如果所有参与者目前都在屏障处等待，则它们将返回，同时抛出一个BrokenBarrierException。</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore 是Java中提供的信号量，它是一个计数信号量，必须由获取线程释放。</p><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构建非公平锁  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取许可：acquire"><a href="#获取许可：acquire" class="headerlink" title="获取许可：acquire()"></a>获取许可：acquire()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放许可：release"><a href="#释放许可：release" class="headerlink" title="释放许可：release()"></a>释放许可：release()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CountDownLatch：允许一个或多个线程等待，直到在某些线程中执行的一组操作完成</li><li>CyclicBarrier：一个辅助性的同步结构，允许多个线程等待到达某个屏障</li><li>Semaphore：Java 版本的信号量实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> CyclicBarrier </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程之 Synchronized 详解</title>
      <link href="java-synchronized/"/>
      <url>java-synchronized/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>在之前的一篇博文中简单介绍了 Java 中的一些锁：<a href="https://jlj98.top/java-lock/">Java 中各种锁</a>。<br>最近在极客时间上买了杨晓峰的《Java核心技术36讲》，今天看到关于标题的东西，于是想记录下自己的学习。<br>Synchronized 和 ReentrantLock 这两个都是可重入锁，指的是同一线程在外层函数获取锁之后，内层函数仍然可以获取该锁，且不受影响。</p><p><a href="https://github.com/tedburner/JavaExample/tree/master/src/main/java/com/example/common/concurrent/lock/reentrant">Synchronized 可重入测试源码</a></p><h2 id="Synchronized-锁的原理"><a href="#Synchronized-锁的原理" class="headerlink" title="Synchronized 锁的原理"></a>Synchronized 锁的原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSth&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javac SynchronizedTest.java</code> 和 <code>javap -c -s -v -l  SynchronizedTest</code> 命令查看编译后的Test.class的字节码，可以很容易看出在代码块上和方法上是有区别的。代码块上使用 <code>monitorenter/monitorexit</code> 指令来实现的；方法上是使用 <code>ACC_SYNCHRONIZED</code>。详情看下面的图片，是编译后的字节码：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181113202347.png"></p><p>在 Java6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要用户状态到内核状态的切换，所有同步操作是一个重量级操作。</p><p>Synchronized 底层原理，Synchronized 有2个队列 waitSet 和 entrtyList。</p><ul><li>当多个线程进入同步代码块时，首先进入entryList</li><li>有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1</li><li>如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</li><li>如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210518134817.png"></p><h2 id="锁的优化机制"><a href="#锁的优化机制" class="headerlink" title="锁的优化机制"></a>锁的优化机制</h2><p>现在的JVM提供三种不同的 Monitor 实现方式：</p><ul><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><p>所谓锁的升级降级，就是JVM优化 synchronized 运行的机制，当JVM 检测到不同的竞争状态是，会自动切换到适合的锁的实现。</p><p>当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及到真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象声明周期最大会被一个线程锁定，使用偏向锁可以降低无竞争开销。</p><p>以 Hotspot 虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181129172656.png"></p><p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>没有对资源进行锁定，所有线程都能访问和修改，但同时只有一个线程修改成功。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在锁竞争不强烈的情况下，通常一个线程会多次获取同一个锁，为了减少获取锁的代价引入了偏向锁，会在 Java 对象头中记录锁的 <code>ThreadID</code>。</p><ul><li>当线程发现对相同的ThreadID存在是，判断于当前线程是否同一个线程；</li><li>如果相同则不需要再次加锁、解锁；</li><li>如果不是，则判断<code>ThreadID</code>是否存活。如果不存活，设置为无锁状态，其他线程竞争设置偏向锁；如果存活，查找<code>ThreadID</code>堆栈信息判断是否需要继续持有锁。如果需要持有则升级<code>ThreadID</code>线程的锁为轻量级锁，不需要持有则撤销锁，设置为无锁状态等待其他线程竞争。</li></ul><p>因为偏向锁的撤销操作还是比较重的，导致进入安全点，因此在竞争比较激烈时，会影响性能，可以使用<code>-XX:-UseBiasedLocking=false</code> 禁用偏向锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当偏向锁升级为轻量级锁时，其他线程尝试通过 <code>CAS</code> 方法设置对象头来获取锁。</p><ul><li>先在当前线程中的栈帧中设置 <code>Lock Record</code>，用来存储当前对象头中的 <code>Mark word</code> 的拷贝；<br>复制 <code>Mark word</code> 的内容到 <code>Lock Record</code>，并尝试使用 CAS 将 <code>Mark word </code>的指针指向<code>Lock Record</code>；</li><li>如果替换成功，则获取轻量级锁；替换不成功，则自旋重试一定次数</li><li>自旋一定次数或者有新的线程来竞争锁时，轻量级锁升级为重量级锁。</li></ul><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>自旋是消耗CPU的，因此在自旋一段时间，或者一个线程在自旋的时候，又有新的线程来竞争，则升级为重量级锁。</p><p>重量级锁，通过monitor实现，底层实现是依赖操作系统的互斥锁实现。</p><p>需要从用户态切换到内核态，成本比较高。</p><p>上面就是所谓的锁的升级，而对于锁的降级，当JVM 进入安全点的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210409192513.png"></p><h2 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>我们知道Vector的方法是由synchronized修饰的，它是线程安全的，但是我们可能仅在线程内使用，作为局部变量使用。不同线程调用时，都会创建不同的 Vector，因此，执行 add()方法的时候，使用同步操作，就是白白浪费系统资源。这时，我们可以通过编译器将其优化，将锁消除。<code>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</code>，前提是Java必须运行在server模式下，同时必须开启逃逸分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        vector.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>在一些情况下，我们希望多次锁的请求能够合并成一个请求，以降低最短时间内大量锁的请求、同步、释放带来的性能消耗。</p><p>比如以下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Demo.class) &#123;</span><br><span class="line">            list.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码经过锁初粗化后，将变成下面这种情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">synchronized</span> (Demo.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> lock </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 注解之—— @SpringBootApplication</title>
      <link href="spring-boot-bootstrap/"/>
      <url>spring-boot-bootstrap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有误，欢迎批评指正。友情提示，本文有点长。<br>SpringBoot 版本 2.0.5.RELEASE。</p></blockquote><p>在学习 <code>SpringBoot</code> 时，会在启动项里面看到在类名上面有一个注解 <code>@SpringBootApplication</code>。前几天在一个公众号中看到关于一道面试题，题目类似于：知道 <code>@SpringBootApplication</code> 的原理吗？   </p><p>突然发现自己对于 SpringBoot 还是处在‘知其然而不知所以然’的状态。于是就去官网和网上查看一些资料，于是有了这篇文章。</p><h1 id="SpringBoot-启动项"><a href="#SpringBoot-启动项" class="headerlink" title="SpringBoot 启动项"></a>SpringBoot 启动项</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApplicationStartup.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>看下 <code>@SpringBootApplication</code> 注解的详情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注解的源码中可以看到它被 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 等注解修饰。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p><code>@SpringBootConfiguration</code> 是 SpringBoot 项目的配置注解，这也是一个组合注解。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/a97cd95a4702fe1bb2ba093ebe728d15.jpg"></p><p>通过源码上的注解，可以看出 @SpringBootConfiguration 主要是 @Configuration。<br>@Configuration 是一个类级注释，指示对象是一个bean定义的源。@Configuration 类通过 @bean 注解的公共方法声明 bean。<br>@Bean 注释是用来表示一个方法实例化，配置和初始化是由 Spring IoC 容器管理的一个新的对象。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>启用 Spring 应用程序上下文的自动配置，试图猜测和配置您可能需要的bean。自动配置类通常采用基于你的 classpath 和已经定义的 beans 对象进行应用。<br>启用自动配置，该注解会使 SpringBoot 根据项目中依赖的jar包自动配置项目的配置项。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>组件扫描，为 @SpringBootConfiguration 自动扫描类配置组件</p><h1 id="SpringBoot-启动流程"><a href="#SpringBoot-启动流程" class="headerlink" title="SpringBoot 启动流程"></a>SpringBoot 启动流程</h1><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/4ee0cb26edfb817f1ce601d70e82137d.jpg"></p><p>上面<a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e">图片来源</a>，不过其中的流程是以前版本的，但是原理差不多。</p><h2 id="Spring-Boot-流程分析："><a href="#Spring-Boot-流程分析：" class="headerlink" title="Spring Boot 流程分析："></a>Spring Boot 流程分析：</h2><p>下面这个是 SpringBoot 的启动项：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/765272b5ad2cd4da5f60f460138e7592.jpg"></p><p>通过 run() 方法，我们可以看出：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/291099e703e07013b68a129311ae4984.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/f173cbece8f7523774c8c72971577c49.jpg"></p><p>通过上面的代码，分别分析下<code>SpringApplication()</code>和<code>run()</code>。</p><h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication()"></a>SpringApplication()</h3><p>通过一些类的调用，最后到下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = deduceWebApplicationType();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">       <span class="comment">//设置mainApplicationClass为AppBootstrap</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的这个 <code>SpringApplication()</code> 方法中可以看出 SpringBoot 在初始化的时候，需要加载的资源。<code>this.webApplicationType = deduceWebApplicationType();</code> 通过下面的 <code>deduceWebApplicationType()</code> 方法判断类型：</p><ul><li>NONE：应用程序不应作为Web应用程序运行，也不应启动嵌入式Web服务器。</li><li>SERVLET：应用程序应作为基于servlet的Web应用程序运行，并应启动嵌入式servlet Web服务器。</li><li>REACTIVE：应用程序应作为响应式Web应用程序运行，并应启动嵌入式响应式Web服务器。</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/4a12ba6898e130b3acb3e7591dae324f.jpg"></p><p><strong>ApplicationContextInitializer</strong></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/249822e109b284f17e224150aef27be7.jpg"></p><p>通过打断点，可以看到<code>setInitializer()</code>被加载的内容：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/6f487551835f4c316fc83db6fc12c79f.jpg"></p><p><strong>ApplicationListener</strong></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/62433ffa315cc2c3e69227b5c170f56b.jpg"></p><p>通过断点看到<code>setListeners()</code>方法中被加载的监听事件：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/eecc8f24ae3c5bc176351aa12ed596ab.jpg"></p><p><code>setInitializer()</code> 和 <code>setListeners()</code> 这两个方法都使用了 <code>getSpringFactoriesInstances</code> 方法。代码中使用了 <code>SpringFactoriesLoader.loadFactoryNames(type, classLoader));</code>，这个根据 type 和 classLoader</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/7347828f89baad5d99acae01173e0b28.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    List&lt;String&gt; factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));</span><br><span class="line">                    result.addAll((String)entry.getKey(), factoryClassNames);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>spring.factories文件</strong>的作用也就间接的实现了自动化配置。我们可以在项目下创建自己的<code>spring.factories</code>文件。从 <code>spring boot</code> 启动流程中加入我们自己需要的东西。</p><h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line"><span class="comment">//context 上下文</span></span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">//统一管理监听listeners，在事件发生是被调用</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"><span class="comment">//如果有监听器监听启动事件，则执行对应的动作</span></span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从命令行中读取参数作为propertySource，放入到这里,会加入到env中</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line"><span class="comment">//创建env,加载配置文件，系统的属性，profile文件，application.yml, 初始化日志系统</span></span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line"><span class="comment">//打印banner</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line"><span class="comment">//创建 context</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"><span class="comment">//准备上下文</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取监听事件"><a href="#获取监听事件" class="headerlink" title="获取监听事件"></a>获取监听事件</h4><p><code>SpringApplicationRunListeners listeners = getRunListeners(args);</code>首先看下图的<code>SpringApplicationRunListeners</code>类。其中包含一个 <code>SpringApplicationRunListener</code> 集合，可以看那个的那个 <code>SpringApplicationRunListener</code> 接口代码</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/3a8a13faa34791bb3fe4deea15cce8d4.jpg" alt="SpringApplicationRunListeners"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出在run()方法中构建了一个SpringApplicationRunListeners，其中包含多个 SpringApplicationRunListener，用来监听应用启动过程中的start、environmentPrepared、contextPrepared、contextLoaded 等事件。</p><h4 id="创建和准备环境：environment"><a href="#创建和准备环境：environment" class="headerlink" title="创建和准备环境：environment"></a>创建和准备环境：environment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, pplicationArguments);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//创建env，如果是web环境，则创建StandardServletEnvironment，如果不是StandardEnvironment</span></span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line"><span class="comment">//配置env</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"><span class="comment">//广播environment事件</span></span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line"><span class="comment">//绑定到SpringApplication</span></span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">.convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建应用上下文"><a href="#创建应用上下文" class="headerlink" title="创建应用上下文"></a>创建应用上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line"><span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Unable create a default ApplicationContext, &quot;</span></span><br><span class="line">+ <span class="string">&quot;please specify an ApplicationContextClass&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>context 初始化过程：</strong>   </p><ul><li>AbstractApplicationContext <ul><li>设置Log </li><li>设置id和displayName </li><li>初始化BeanFactoryPostProcessor的集合 </li><li>active,closed初始化 </li><li>初始化ApplicationListener的集合 </li><li>设置resourcePatternResolver </li></ul></li><li>GenericApplicationContext <ul><li>customClassLoader = false </li><li>refreshed = false </li><li>beanFactory = new DefaultListableBeanFactory </li></ul></li><li>AnnotationConfigEmbeddedWebApplicationContext <ul><li>this.reader = new AnnotatedBeanDefinitionReader(this);注册了几个BeanDefinition，最重要的是CongiurationClassPostProcessor的bean definition </li><li>this.scanner = new ClassPathBeanDefinitionScanner(this);设置了需要识别的注解的类型</li></ul></li></ul><h4 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext()"></a>prepareContext()</h4><ul><li>调用用户配置的initializer的方法</li><li>设置context的Id</li><li>context注册 ConfigurationWarningsPostProcessor用于检查错误的配置</li><li>向env中设置实际的端口</li><li>SharedMetadataReaderFactoryContextInitializer.CachingMetadataReaderFactoryPost- Processor</li><li>设置ContextRefreshedEvent监听器,打印ConditionEvaluationReport日志</li><li>打印启动日志</li><li>注册固定的单例bean</li><li>加载主类的bean definition</li><li>向context中添加-</li><li>ConfigFileApplicationListener.PropertySourceOrderingPostProcessor</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="SpringApplication-1"><a href="#SpringApplication-1" class="headerlink" title="SpringApplication()"></a>SpringApplication()</h2><p>调用里面的构造器，初始化一个 SpringApplication()。</p><ul><li>加载资源文件</li><li>加载主要的bean</li><li>判断是否web环境以及判断是那种web环境</li><li>设置setInitializers<ul><li>调用 <code>getSpringFactoriesInstances</code> 加载 <code>META-INF/spring.factories</code> 里面的信息</li></ul></li><li>设置setListeners<ul><li>调用 <code>getSpringFactoriesInstances</code> 加载 <code>META-INF/spring.factories</code> 中配置的 <code>org.springframework.context.ApplicationListener</code></li></ul></li><li>设置 <code>mainApplicationClass：deduceMainApplicationClass()</code> 该方法通过获取当前方法调用栈，找到main函数的类</li></ul><h2 id="run-1"><a href="#run-1" class="headerlink" title="run()"></a>run()</h2><ul><li>初始化StopWatch,调用其start方法开始计时.</li><li>调用configureHeadlessProperty设置系统属性java.awt.headless，这里设置为true，表示运行在服务器端，在没有显示器和鼠标键盘的模式下工作，模拟输入输出设备功能</li><li>调用SpringApplicationRunListeners#starting</li><li>创建一个DefaultApplicationArguments对象,它持有着args参数，就是main函数传进来的参数.调用prepareEnvironment方法.</li><li>打印banner</li><li>创建SpringBoot上下文</li><li>初始化FailureAnalyzers</li><li>调用prepareContext</li><li>调用AbstractApplicationContext#refresh方法,并注册钩子</li><li>在容器完成刷新后，依次调用注册的Runners</li><li>调用SpringApplicationRunListeners#finished</li><li>停止计时</li><li>初始化过程中出现异常时调用handleRunFailure进行处理,然后抛出IllegalStateException异常.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-application">SpringBoot官网</a></li><li><a href="https://www.cnblogs.com/trgl/p/7353782.html">SpringBoot启动流程解析</a></li><li><a href="https://blog.csdn.net/column/details/18708.html">SpringBott 源码解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringBoot启动流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 动态代理机制</title>
      <link href="java-proxy-cglib/"/>
      <url>java-proxy-cglib/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有错，希望指出</p></blockquote><p>动态代理在Java中有着广泛的应用，比如 Spring Aop、Hibernate 数据查询、RPC、Java 注解对象的获取。静态代理的代理关系在编译时确定，而动态代理的代理关系是在编译期确定的。主要了解：JDK Proxy 和 cglib 动态代理。</p><p>动态代理可以提供另一个对象的访问，同时可以隐藏实际对象的具体实例。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>再说动态代理之前，先了解下静态代理。</p><p>静态代理是代理模式实现方式之一，在程序运行前，由程序员创建或者特定工具自动生成源代码并对其编译生成 .class 文件。静态代理的实现需要三步：</p><ul><li>定义业务接口</li><li>实现业务接口</li><li>定义代理类并实现业务接口</li></ul><p>最后就可以直接通过客户顿进行调用静态代理了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181214100514.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181214100542.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181214100603.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181214100626.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181214100648.png"></p><p>静态代理总结：</p><ul><li>优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。</li><li>缺点：因为代理对象，需要实现和目标对象一样的接口，会导致代理对象十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。</li></ul><h1 id="JDK-Proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h1><p>先实现一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayJava</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用<code>java.lang.reflect.Proxy</code> 实现动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  动态代理类的引用，通常情况下不需要它</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法对象的引用，代表被动态代理类调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   args对象数组，代表被调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行&quot;</span> + method.getName() + <span class="string">&quot;方法&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDynamicProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HelloImpl hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(hello);</span><br><span class="line">        <span class="comment">//构造代码实例 Proxy.newProxyInstance(类加载器, 需要实现的接口数组,InvocationHandler接口)</span></span><br><span class="line">        Hello proxyHello = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(),</span><br><span class="line">                HelloImpl.class.getInterfaces(),</span><br><span class="line">                handler);</span><br><span class="line">        <span class="comment">//调用代理</span></span><br><span class="line">        proxyHello.sayHello();</span><br><span class="line">        proxyHello.sayJava();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。理解上述代码需要对Java反射机制有一定了解。动态代理神奇的地方就是：</p><ul><li>代理对象是在程序运行时产生的，而不是编译期；</li><li>对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法，在invoke()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了Hello对象的相应方法，还可以通过RPC调用远程方法。</li></ul><h1 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h1><p>GCLIB(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许在运行时对字节码进行修改和动态生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现MethodInterceptor方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行GCLIB动态代理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过 CGlib 动态获取代理对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(HelloImpl.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">        Hello helloProxy = (Hello) enhancer.create();</span><br><span class="line">        helloProxy.sayHello();</span><br><span class="line">        helloProxy.sayJava();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JDK-Proxy-1"><a href="#JDK-Proxy-1" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h2><ul><li>JDK动态代理只能代理<strong>有接口的类</strong>，并且是只能代理接口方法，不能代理一般的类中的方法</li><li>提供了一个使用 InvocationHandler 作为参数的构造方法，在代理类中做一层包装，业务逻辑在 invoke 方法中实现；</li><li>重写了 Object 类的 equals、hashCode、toString，它们都只是简单的调用了InvocationHandler 的 invoke 方法，即可以对其进行特殊的操作，也就是说JDK的动态代理还可以代理上述三个方法；</li><li>在 invoke 方法中我们甚至可以不用 <code>Method.invoke</code> 方法调用实现类就返回。这种方式常常用在 RPC 框架中，在 invoke 方法中发起通信调用远端的接口等。</li></ul><h2 id="CGlib"><a href="#CGlib" class="headerlink" title="CGlib"></a>CGlib</h2><ul><li>CGlib 可以传入接口也可以传入普通的类，接口使用实现的方式，普通类使用会使用继承的方式生成代理类；</li><li>由于是继承方式，如果是 <strong>static方法、private方法、final方法等描述的方法</strong>是不能被代理的；</li><li>做了方法访问优化，使用建立方法索引的方式避免了传统 Method 的方法反射调用；</li><li>提供 callback 和 filter 设计，可以灵活地给不同的方法绑定不同的 callback。编码更方便灵活。</li><li>CGLIB 会默认代理 Object 中 finalize、equals、toString、hashCode、clone等方法。比JDK代理多了finalize和clone。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://www.importnew.com/27772.html">Java Proxy 和 CGLIB 动态代理原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
            <tag> CGlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="java-reflect/"/>
      <url>java-reflect/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有问题，希望指出</p></blockquote><p>Reflection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借用 Reflection API 获取任何内部信息，并能操作任何对象的内部属性级方法。   </p><p>Java 反射机制主要提供一下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>生成动态代理</li></ul><p>Java 反射提供三种获取 Class 对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1L</span>, <span class="string">&quot;反射&quot;</span>);</span><br><span class="line"><span class="comment">//1、通过对象名</span></span><br><span class="line">Class personClass = person.getClass();</span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Class baseClass = Person.class;</span><br><span class="line"><span class="comment">//3、通过全类名</span></span><br><span class="line">Class baseClass2 = Class.forName(<span class="string">&quot;com.example.basejava.basics.reflect.Person&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Class 是一个类，一个描述类的类。它封装了描述方法的 Method，描述字段的 Filed，描述构造器的 Constructor 等属性。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试反射静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(Person person) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(默认)反射测试类构造了&quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了公有、无参构造方法执行了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(Long id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;name+&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,</span></span><br><span class="line"><span class="function">            IntrospectionException,</span></span><br><span class="line"><span class="function">            IllegalAccessException,</span></span><br><span class="line"><span class="function">            InvocationTargetException,</span></span><br><span class="line"><span class="function">            InstantiationException,</span></span><br><span class="line"><span class="function">            NoSuchMethodException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1L</span>, <span class="string">&quot;反射&quot;</span>);</span><br><span class="line">        <span class="comment">//1、通过对象名</span></span><br><span class="line">        Class clazz1 = person.getClass();</span><br><span class="line">        <span class="comment">//2、通过类名</span></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        <span class="comment">//3、通过全类名</span></span><br><span class="line">        Class clazz2 = Class.forName(<span class="string">&quot;com.example.basejava.basics.reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----获取文件名----&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---获取类内部信息-----&quot;</span>);</span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">//获取内部成员变量，比如 id、name</span></span><br><span class="line">            String key = field.getName();</span><br><span class="line">            PropertyDescriptor descriptor = <span class="keyword">new</span> PropertyDescriptor(key, clazz);</span><br><span class="line">            Method method = descriptor.getReadMethod();</span><br><span class="line">            Object value = method.invoke(person);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----获取实例对象----&quot;</span>);</span><br><span class="line">        <span class="comment">//利用Class对象的newInstance方法创建一个类的实例</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------获取方法---------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取方法，不能获取private方法，且获取从父类继承来的所有方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有方法，包括私有方法</span></span><br><span class="line">        methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改类内部信息，setName(&quot;反射)</span></span><br><span class="line">        method.invoke(obj, <span class="string">&quot;反射&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----所有公有构造方法-----&quot;</span>);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----所有的构造方法(包括：私有、受保护、默认、公有)-------&quot;</span>);</span><br><span class="line">        constructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------获取公有、无参的构造方法--------&quot;</span>);</span><br><span class="line">        Constructor constructor = clazz.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor : &quot;</span> + constructor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------获取私有构造方法，并调用-------&quot;</span>);</span><br><span class="line">        Object object = constructor.newInstance();</span><br><span class="line">        constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="comment">//调用构造方法</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        object = constructor.newInstance(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">测试反射静态代码块</span><br><span class="line">----获取文件名----</span><br><span class="line">com.example.basejava.basics.reflect.Person</span><br><span class="line">---获取类内部信息-----</span><br><span class="line">id:1</span><br><span class="line">name:反射</span><br><span class="line">----获取实例对象----</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">Person&#123;id=null, name=<span class="string">&#x27;null&#x27;</span>&#125;</span><br><span class="line">------获取方法---------</span><br><span class="line"> toString getName setName getId setId <span class="built_in">wait</span> <span class="built_in">wait</span> <span class="built_in">wait</span> equals hashCode getClass notify notifyAll</span><br><span class="line"> toString</span><br><span class="line"> getName</span><br><span class="line"> setName</span><br><span class="line"> getId</span><br><span class="line"> setId</span><br><span class="line"></span><br><span class="line">public void com.example.basejava.basics.reflect.Person.setName(java.lang.String)</span><br><span class="line">Person&#123;id=null, name=<span class="string">&#x27;反射&#x27;</span>&#125;</span><br><span class="line">----所有公有构造方法-----</span><br><span class="line">public com.example.basejava.basics.reflect.Person()</span><br><span class="line">-----所有的构造方法(包括：私有、受保护、默认、公有)-------</span><br><span class="line">com.example.basejava.basics.reflect.Person(java.lang.String)</span><br><span class="line">com.example.basejava.basics.reflect.Person(java.lang.Long,java.lang.String)</span><br><span class="line">public com.example.basejava.basics.reflect.Person()</span><br><span class="line">com.example.basejava.basics.reflect.Person(com.example.basejava.basics.reflect.Person)</span><br><span class="line">--------获取公有、无参的构造方法--------</span><br><span class="line">constructor : public com.example.basejava.basics.reflect.Person()</span><br><span class="line">------获取私有构造方法，并调用-------</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">com.example.basejava.basics.reflect.Person(java.lang.String)</span><br><span class="line">name+男</span><br><span class="line">Person&#123;id=null, name=<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="distributed-transaction/"/>
      <url>distributed-transaction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错，希望在下面的留言区指正。</p></blockquote><p>在之前的一篇文章中，写了一篇 <a href="https://jlj98.top/spring-transaction/">Spring 事务管理</a>。</p><p>本地事务管理主要考虑的是单台服务器上面的事务回滚。那么，如果在分布式服务之间如何管理事务呢？   </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/4ad51e568742f123fb93d08934e2b929.jpg"></p><p>如上图所示的分布式调用，客户端 client 调用服务A，而服务A 除了本身的对数据库的修改，还需要调用服务B和服务C。如果在调用服务B成功后在调用服务C，但是这时候服务C出错了，这时候如何解决事务的回滚？</p><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP 理论是分布式系统的一个基础理论，描述任何一个分布式系统最多只能满足下面三种特性中的两个：</p><ul><li>一致性（Consistency）：对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</li><li>可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</li><li>分区容忍性（Partition tolerance）：当出现网络分区后，系统能够继续“履行职责”。</li></ul><h2 id="CAP-的选择"><a href="#CAP-的选择" class="headerlink" title="CAP 的选择"></a>CAP 的选择</h2><p>虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求。分布式系统的组件必然是需要部署到不同节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题有时一个必定会出现的异常情况，因此分区容错性也就成为一个分布式系统必然需要面对和解决的问题了。</p><p>我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证 C，系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A 冲突了，因为 A 要求返回 no error 和 no timeout。因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/8c5f24c4a71c6fe31483d9c03dd3cd43.jpg"></p><p><strong>CAP 关注的粒度是数据，而不是整个系统</strong>。在实际设计过程中，每个系统不可能处理一种数据，而是包含多种数据，有的数据必须选择CP，有的数据必须选择AP。所以，我们在设计的时候，不能从整个系统去选择CP 还是AP。</p><p><strong>CAP 是忽略网络延迟的</strong>。在分布式环境下，数据在不同服务器复制，是存在延迟的。如果是相同机房，耗时时间可能是几毫秒；如果是跨地域的机房，可能就是十几毫秒。这以为着，CAP 理论中的 C 在实践中是不可能完美实现的，在数据复制的过程中，节点A 和节点B 的数据并不一致。</p><p>正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足 CA。</p><h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>BASE 思想解决了 CAP 提出的分布式系统的一致性和可用性不可兼容的问题。BASE 思想与 ACID 原理完全不同，它满足于 CAP 原理，通过牺牲<strong>强一致性</strong>获取可用性，<strong>一般应用于服务化系统的应用层或者大数据处理系统中，通过达到最终一致性来尽量满足业务的绝大多数需求。</strong></p><p>BASE 模型包含以下三个元素：</p><ul><li>BA：Basically Available，基本可用</li><li>S：Soft state，软状态，状态可以在一段时间内不同步</li><li>E：Eventually consistent，最终一致性，在一定的时间窗口内，最终数据达到一致性即可。</li></ul><h1 id="目前的分布式事务的解决方案"><a href="#目前的分布式事务的解决方案" class="headerlink" title="目前的分布式事务的解决方案"></a>目前的分布式事务的解决方案</h1><h2 id="两阶段提交-2PC"><a href="#两阶段提交-2PC" class="headerlink" title="两阶段提交 2PC"></a>两阶段提交 2PC</h2><p>2PC 又称 XA Transactions，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。</li></ul><h2 id="补偿事务-TCC"><a href="#补偿事务-TCC" class="headerlink" title="补偿事务 TCC"></a>补偿事务 TCC</h2><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC模型是把锁的粒度完全交给业务处理。它分为三个阶段：</p><ul><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul><h2 id="基于-TCC-源码"><a href="#基于-TCC-源码" class="headerlink" title="基于 TCC 源码"></a>基于 TCC 源码</h2><ul><li><a href="https://github.com/changmingxie/tcc-transaction">tcc-transaction</a></li><li><a href="https://github.com/liuyangming/ByteTCC">ByteTCC</a></li></ul><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/687ba5ef783d9b7152cbfecacc971d32.jpg"></p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p>这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p><p>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 <code>.NET</code> 中 有现成的解决方案。</p><p>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h2 id="MQ-事务"><a href="#MQ-事务" class="headerlink" title="MQ 事务"></a>MQ 事务</h2><p>有一些第三方的MQ是支持事务消息的，比如RocketMQ，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p><h2 id="阿里的-GTS"><a href="#阿里的-GTS" class="headerlink" title="阿里的 GTS"></a>阿里的 GTS</h2><p>阿里的 GTS 没有开源，需要购买它的产品，同时需要配套的分布式数据库。</p><ul><li><a href="https://help.aliyun.com/document_detail/48726.html">阿里 GTS</a></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://mp.weixin.qq.com/s/7OA2YyhXZSyXBFDj8p3kqQ">如果有人问你CAP理论是什么，就把这篇文章发给他</a></li><li><a href="https://mp.weixin.qq.com/s/WHWNAOK4C8wgd4CjcWviHQ">再有人问你分布式事务，把这篇扔给他</a></li><li><a href="https://segmentfault.com/a/1190000012762869">Spring Cloud分布式事务终极解决方案探讨</a></li><li><a href="https://juejin.im/post/5baa54e1f265da0ac2566fb2">从一笔金币充值去思考分布式事务</a></li><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解虚拟机 —— 类的加载</title>
      <link href="jvm-classloader/"/>
      <url>jvm-classloader/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://jlj98.top/jvm-memory-area/">深入理解虚拟机 —— Java内存区域</a></li><li><a href="https://jlj98.top/jvm-gc/">深入理解虚拟机 —— 垃圾收集器</a></li></ul><p>类被加载到虚拟机的内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/ebd2ba4b7e318811fb688705868bf751.jpg"></p><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构</li><li>在内存中生成一个代表这个类的  <code>java.lang.Class</code> 对象，作为<strong>方法区</strong>这个类的各种数据的访问入口。</li></ul><p>加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中，方法区中的数据存储格式完全由虚拟机实现自行定义。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。   </p><p>验证阶段大致上回完成下面4个阶段的校验：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量<strong>分配内存</strong>并<strong>设置类变量初始值</strong>的阶段，这些变量所使用的的内存都将在<strong>方法区</strong>中进行分配。在这个阶段进行分配仅包括<strong>类的变量（被static修饰的变量）</strong>，而不包括实例对象，实例对象将会在对象实例化时随对象一起分配在Java堆中。   </p><p>在“通常情况”下，初始值指的是数据类型的零值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> values = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>这里的 values 在准备阶段过后的初始值为0而不是120。如果类字段属性表中存在 ConstantValue 属性，那么初始值就是指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> values = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用是无歧义地定位到目标即可。</li><li>直接引用：直接引用可以直接指向目标的指针、相对偏移量或是一个间接定位到目标的句柄。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类初始化时类加载过程最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与外，其余动作完全由虚拟机主导和控制。这个阶段才真正执行类中定义的Java程序代码。    </p><p>初始化阶段是执行类构造器<code>&lt;client&gt;</code>方法的过程。<code>&lt;client&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;client&gt;</code>方法执行之前，父类的<code>&lt;client&gt;</code>方法已经执行完毕。</p><p>P.S: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;client&gt;()</code>方法。</p><p>注意以下几种情况不会执行类初始化：</p><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取Class对象，不会触发类的初始化。</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器只用于<strong>实现类的加载</strong>过程。对于任意一个类，都需要由加载它的类和这个了类本身一同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。</p><p>两个类是否“相等”的前提，只有这两个类是由同一个类加载器加载的。这里的“相等”指的是代表类的Class 对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从虚拟机的角度来说，只存在两种不同的加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分。</li><li>所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承抽象类 java.lang.ClassLoader。</li></ul><p>从程序员角度来说，可以更加细分：</p><ul><li>启动类加载器：这个类加载器负责加载存放在 <code>&lt;JAVA_HOME&gt;/lib</code> 目录，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中存放的，而且是 Java 虚拟机能够士必得类库加载到虚拟机的内存中。</li><li>扩展类加载器：这个类加载器在类 <code>sun.misc.Launcher$ExtClassLoader</code> 中以 Java 代码的形式实现的。它负责加载 <code>&lt;JAVA_HOME&gt;/lib/ext</code> 目录中，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器：这个类是由<code>sun.misc.Launcher$AppClassLoader</code> 来实现的。</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210412220100.png"></p><p>上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，别的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而都是使用组合关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送给顶端的启动类加载器中，只有当父类自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</p><p>这种模型的好处就是 Java 类随着它的加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— Hashtable</title>
      <link href="java-hashtable/"/>
      <url>java-hashtable/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8，如果有错希望指出</p></blockquote><p>在Java面试的时候，HashMap 和 Hashtable 经常被问，就想仔细分析下两者。</p><p><a href="https://jlj98.top/Java-HashMap/">Java集合框架 —— HashMap</a></p><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><p>HashMap 和 Hashtable 都是实现 Map 接口，两者主要的区别是线程安全性，同步，以及速度。   </p><table><thead><tr><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>键值接受null</td><td>键值对不能为null</td></tr><tr><td>非synchronized</td><td>Hashtable是synchronized，线程安全</td></tr><tr><td>单线程下HashMap的速度比Hashtable快</td><td>sychronized意味着在一次仅有一个线程能够更改Hashtable</td></tr><tr><td>迭代器(Iterator)是fail-fast迭代器</td><td>Hashtable的enumerator迭代器不是fail-fast的</td></tr></tbody></table><p>因此仅在需要线程安全的时候使用Hashtable，而如果Java5以上，还是使用 ConcurrentHashMap。   </p><p><a href="https://jlj98.top/Java-ConcurrentHashMap/">Java并发容器 ——— ConcurrentHashMap</a>。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/76ba345ad74c7606a5dc7ddc853f98d0.jpg"></p><p>Hashtable 虽然不是继承于 AbstractMap，但它继承于 Dictionary(Dictionary 也是键值对的接口)，而且也实现Map接口；因此，Hashtable 的内容也是“键值对，也不保证次序”。但和 HashMap 相比，Hashtable 是线程安全的，而且它支持通过 Enumeration 去遍历。Hashtable 采用的是<strong>数组+链表</strong>实现。Hashtable 通过 synchronized 保证其的线程安全。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//table数组扩容的节点数阈值，默认情况下为 8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">//负载因子，默认 0.75</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key =  key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="初始化构造"><a href="#初始化构造" class="headerlink" title="初始化构造"></a>初始化构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">//比较 initialCapacity * loadFactor和MAX_ARRAY_SIZE + 1，去两者的最小值，默认情况下 扩容阈值为 8</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认负载因子 0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认容量11，负载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put-操作"><a href="#put-操作" class="headerlink" title="put() 操作"></a>put() 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 限制 value不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//如果key为null会报错，key也不能为null</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">//根据key的hash值寻址</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果已存在，替换旧的值，并返回旧的value</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过addEntry将新节点添加进链表</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//如果元素个数超过阈值threshold，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把新的节点房贷table[index]位置</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash()"></a>扩容 rehash()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;<span class="comment">//获取旧容器的长度</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;<span class="comment">//复制旧的map</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//oldCapacity &lt;&lt; 1 向左移一位，相当于乘以2，最后还加上1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get() 操作"></a>get() 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
            <tag> Hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— TreeMap</title>
      <link href="java-treemap/"/>
      <url>java-treemap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8，如果有错希望指出</p></blockquote><p>本文将简单介绍 JAVA 集合框架——TreeMap。TreeMap 集合是基于<strong>红黑树</strong>的 NavigableMap 实现。该集合最重要的特性就是<strong>可排序</strong>，该映射可以根据 Map 的键的自然顺序排序，或者根据创建时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h1 id="TreeMap-继承关系"><a href="#TreeMap-继承关系" class="headerlink" title="TreeMap 继承关系"></a>TreeMap 继承关系</h1><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/1047c172180b4bd04bf5eaf4f3847925.jpg"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>TreeMap采用红黑树的数据结构来实现。树节点Entry实现了Map.Entry，采用内部类的方式实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br></pre></td></tr></table></figure><p>接下来看下 TreeMap 中支持红黑树的数据成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//用于接收自定义比较器，插入时用于比对元素的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line">    <span class="comment">//红黑树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line">    <span class="comment">//树中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="TreeMap-初始化与比较器"><a href="#TreeMap-初始化与比较器" class="headerlink" title="TreeMap 初始化与比较器"></a>TreeMap 初始化与比较器</h2><p>默认的构造器：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/bf6cd963dcd5b9bbf92a93805dc53655.jpg"></p><p>看源码注释，可以了解一些重点：</p><blockquote><ul><li>默认构建方法创建一棵空树</li><li>默认使用 key 的自然顺序构建有序树</li></ul></blockquote><p>除了使用 key 的默认比较器， TreeMap 还支持自定义比较器来初始化构造方法。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/1c060b06c9c2b0db1c691407bf28a1e1.jpg"></p><h2 id="TreeMap-的-put-方法"><a href="#TreeMap-的-put-方法" class="headerlink" title="TreeMap 的 put 方法"></a>TreeMap 的 put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeMap-的-get-方法"><a href="#TreeMap-的-get-方法" class="headerlink" title="TreeMap 的 get 方法"></a>TreeMap 的 get 方法</h2><p>TreeMap 的 get 方法其实只是一个简单的二叉树查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用自定义比较器</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//采用默认比较器</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自定义比较器</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeMap-的-remove-方法"><a href="#TreeMap-的-remove-方法" class="headerlink" title="TreeMap 的 remove 方法"></a>TreeMap 的 remove 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If strictly internal, copy successor&#x27;s element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeMap-的-clear-方法"><a href="#TreeMap-的-clear-方法" class="headerlink" title="TreeMap 的 clear 方法"></a>TreeMap 的 clear 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://blog.csdn.net/caoxiaohong1005/article/details/79673550">TreeMap源码分析-java8</a></li><li><a href="https://www.jianshu.com/p/07cceede7b03">Java集合-TreeMap深入浅出源码分析Java8</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
            <tag> TreeMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法 —— 插入排序、选择排序、冒泡排序、快速排序</title>
      <link href="algorithm-sort/"/>
      <url>algorithm-sort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎指正。</p></blockquote><p>最近打算重温一下排序算法。</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>插入排序主要是通过构建有序序列，对未排列的数据，从后往前扫描，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> target = array[i];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; target &lt; array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>第一次从下标为0的开始下标为0的这个数与后面的n-1个进行比较；找出最小或者最大的放在下标为0的这个位置。    </p><p>时间复杂度是O(n^2)。不稳定</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> target = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><ul><li>从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置。</li><li>指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置。</li><li>依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面。</li><li>依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置。</li><li>重复上述过程，没排完一轮，比较次数就减少一次。</li></ul><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">//左边比右边大</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                target = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>快排的原理：在需要排序的数据中选择一个中心值（key）,通过一趟排序将需要排序的数组分为两部分，其中以key为中心，key右边比key大，key左边比key小，然后重复这过程。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, target;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = low;</span><br><span class="line">    j = hight;</span><br><span class="line">    target = a[i];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用比基准小的记录替换低位记录</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[i++] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用比基准大的记录替换高位记录</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准数值替换回 a[i]</span></span><br><span class="line">    a[i] = target;</span><br><span class="line">    <span class="comment">// 对低子表进行递归排序</span></span><br><span class="line">    sort(a, low, i - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对高子表进行递归排序</span></span><br><span class="line">    sort(a, i + <span class="number">1</span>, hight);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
            <tag> 选择排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— Set</title>
      <link href="java-set/"/>
      <url>java-set/</url>
      
        <content type="html"><![CDATA[<p>在 Java 集合中，有一种集合框架叫 Set，应该很多人在日常开发中用到它。<br>先了解下 Set 的一些特性，然后看下源码：</p><ul><li>不重复存储元素</li><li>元素排列无序</li></ul><p>因为其是一个抽象的接口，所以不能直接实例化一个 set 对象。(Set s = new Set() 错误 )。该接口主要继承于Collections接口，所以具有Collection的一些常见的方法。 </p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Set是无序的，不是按照插入的顺序排列的，不允许重复</span><br><span class="line">Set&lt;String&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure><p>关于 HashSet，如果看下源码，就可以知道，其实实际使用的是 HashMap。而如果使用的是 TreeSet，通过源码，可以知道实际使用的是 TreeMap。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/6577004729ff7726a1b3905123411009.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/14053d346e58646e8404c9e6a0982ce5.jpg"></p><h2 id="如何判断元素是否重复"><a href="#如何判断元素是否重复" class="headerlink" title="如何判断元素是否重复"></a>如何判断元素是否重复</h2><p>HashSet 使用 hashCode 和 equals 方法。<br>注意：HashSet集合在判断元素是否相同先判断hashCode方法，如果相同才会判断equals。如果不相同，是不会调用equals方法的。 </p><p>如果看源码，我们可以知道 HashSet 的 add() 方法，实际上调用的是 HashMap 的 put 方法。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/9e4bf47a06d08d40ea489b303806bfde.jpg"></p><p>通过我之前的一篇文章 <a href="https://jlj98.top/Java-HashMap/">Java集合框架 —— HashMap</a> 中，可以了解 HashMap 的 put 方法的源码分析，这就符合上面的注意点了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— Docker 三剑客之 Compose 项目</title>
      <link href="docker-compose/"/>
      <url>docker-compose/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有什么错误的地方，希望指出。</p></blockquote><p>之前的文章中介绍了 Dockerfile，知道了 Dockerfile 模板文件可以定义一个单独的应用容器，如果需要定义多个容器就需要服务编排。服务编排有很多种技术方案，今天给大家介绍 Docker 官方产品 Docker Compose 。         </p><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multicontainer Docker applications）」，其前身是开源项目 Fig。  </p><p>Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你的 Docker 中有成百上千的容器需要启动，如果一个一个的启动那得多费时间。有了 Docker-Compose 只需要编写一个文件，在这个文件里面声明好要启动的容器，配置一些参数，执行一下这个文件，Docker就会按照你声明的配置去把所有的容器启动起来，但是Docker-Compose只能管理当前主机上的Docker，也就是说不能去启动其他主机上的Docker容器。恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件 （YAML 格式）来定义一组相关联的应用容器为一个项目（project）。   </p><p>Compose 中有两个重要的概念： </p><ul><li>服务 ( service )：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 </li><li>项目 ( project )：由一组关联的应用容器组成的一个完整业务单元，在 dockercompose.yml 文件中定义。</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建-Python-服务"><a href="#创建-Python-服务" class="headerlink" title="创建 Python 服务"></a>创建 Python 服务</h2><p>1、创建项目文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir composetest</span><br><span class="line">$ <span class="built_in">cd</span> composetest</span><br></pre></td></tr></table></figure><p>2、在目录下创建 <code>app.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，Redis 使用容器内默认端口 6379。   </p><p>3、在同目录下创建requirements.txt文件，添加项目依赖的python包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure><h2 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h2><p>在项目文件下创建 Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.4-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure><p>这段代码表示:</p><ul><li>使用基础镜像 Python 3.4</li><li>将当前目录映射到镜像/code目录下</li><li>设置工作目录为 /code</li><li>安装 Python 依赖包</li><li>启动 app.py 程序</li></ul><h2 id="创建-docker-compose-yml"><a href="#创建-docker-compose-yml" class="headerlink" title="创建 docker-compose.yml"></a>创建 docker-compose.yml</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure><p>这个 Compose 文件定义了两个服务, 一个 Pyhon Web 服务和 redis 服务。</p><ul><li>Pyhon Web 服务：使用 Dockerfile 构建了当前镜像。将 Web 容器内部的5000端口映射到 host 的5000端口；并将 Web 容器与 redis 容器连接。</li><li>redis服务：该容器直接由官方的 redis 镜像创建。</li></ul><h2 id="启动-docker-compose-yml"><a href="#启动-docker-compose-yml" class="headerlink" title="启动 docker-compose.yml"></a>启动 docker-compose.yml</h2><p>在项目目录下，使用命令 <code>docker-compose up</code> 启动</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/49e927af67523b3491343ff7c08afa32.jpg"></p><h1 id="Docker-Compose-其他命令"><a href="#Docker-Compose-其他命令" class="headerlink" title="Docker Compose 其他命令"></a>Docker Compose 其他命令</h1><p>在 <code>docker-compose.yml</code> 同一目录下，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后台运行服务</span></span><br><span class="line">$ docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名</span></span><br><span class="line">$ docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看启动的服务</span></span><br><span class="line">$ docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="comment">#拉取服务依赖的镜像</span></span><br><span class="line">$ docker-compose pull</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止服务</span></span><br><span class="line">$ docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动已经存在的服务容器。</span></span><br><span class="line">$ docker-compose start</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目中的服务</span></span><br><span class="line">$ docker-compose restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</span></span><br><span class="line">$ docker-compose rm </span><br><span class="line"></span><br><span class="line"><span class="comment"># -f  指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span></span><br><span class="line">$ docker-compose -f docker-compose.yml up -d </span><br></pre></td></tr></table></figure><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml ，可以 多次指定。 </li><li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 </li><li>–x-networking 使用 Docker 的可拔插网络后端特性 </li><li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge </li><li>–verbose 输出更多调试信息。 </li><li>-v, –version 打印版本并退出。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.docker.com/compose/install/">Install Docker Compose</a></li><li><a href="https://docs.docker.com/compose/gettingstarted/#prerequisites">Get started with Docker Compose</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— Docker 使用 Dockerfile 构建</title>
      <link href="docker-dockerfile/"/>
      <url>docker-dockerfile/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果有什么错误的地方，希望指出。</p></blockquote><p>在之前学习 Spring Boot 项目的时候，使用过 Dockerfile 来构建生产 Docker 镜像 —— <a href="https://jlj98.top/spring-boot-docker/">Spring Boot 在 Docker 上部署</a>，在之前的文章中稍微介绍了两种构建 Docker 镜像的方法，一种是基于 Dockerfile，一种是基于 pom.xml 内的插件直接构建。同时在之前的博文中简单介绍了一点关于 Dockerfile 的内容，这篇文字主要是详细了解下关于 Dockerfile 中的一些命令。  </p><h1 id="使用-Dockerfile-构建镜像"><a href="#使用-Dockerfile-构建镜像" class="headerlink" title="使用 Dockerfile 构建镜像"></a>使用 Dockerfile 构建镜像</h1><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。    </p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。   </p><p>比如构架一个 nginx 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。   </p><p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx 、 redis 、 mongo 、 mysql 、 httpd 、 php 、 tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node 、 openjdk 、 python 、 ruby 、 golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。   </p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力， RUN 指令在定制镜像时是最<br>常用的指令之一。其格式有两种。</p><h3 id="shell-格式"><a href="#shell-格式" class="headerlink" title="shell 格式"></a>shell 格式</h3><p>RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p><h3 id="exec-格式"><a href="#exec-格式" class="headerlink" title="exec 格式"></a>exec 格式</h3><p>RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 docker build 命令最后有一个 <code>.</code> 。 <code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。</p><p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服 务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计， 让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、 ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径， docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 Dockerfile 中这么写： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/ </span><br></pre></td></tr></table></figure><p>这并不是要复制执行 docker build 命令所在的目录下的 package.json ，也不是复制 Dockerfile 所在目录下的 package.json ，而是复制上下文（context） 目录下的 package.json 。</p><p>COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><h2 id="其他-docker-build-的用法"><a href="#其他-docker-build-的用法" class="headerlink" title="其他 docker build 的用法"></a>其他 docker build 的用法</h2><p>直接用 Git repo 构建，也可以直接给定的tar 压缩包构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:8.14</span></span><br><span class="line">//或者</span><br><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li>COPY &lt;原路径&gt; … &lt;目标路径&gt;</li><li>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li></ul><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。   </p><p>在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使 用 ADD 命令了。</p><h3 id="CMD-容器启动"><a href="#CMD-容器启动" class="headerlink" title="CMD 容器启动"></a>CMD 容器启动</h3><p>CMD 指令的格式和 RUN 相似，也是两种格式： </p><ul><li>shell 格式： CMD &lt;命令&gt; </li><li>exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…] </li><li>参数列表格式： CMD [“参数1”, “参数2”…] 。在指定了 ENTRYPOINT 指令后，用 CMD 指 定具体的参数。</li></ul><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时 也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指 定。</p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种： </p><ul><li><code>ENV &lt;key&gt; &lt;value&gt; </code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>格式：<br>ARG &lt;参数名&gt;[=&lt;默认值&gt;]  </p><p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG 所设置的构建环境的 环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密 码之类的信息，因为 docker history 还是可以看到所有值的。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为： </p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]     </li><li>VOLUME &lt;路径&gt; </li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存 动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂 载，其应用也可以正常运行，不会向容器存储层写入大量数据。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data </span><br></pre></td></tr></table></figure><p> 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记 录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设 置。比如：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx 在</span><br></pre></td></tr></table></figure><br>这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…] 。    </p><p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声 明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助 镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用 随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。    </p><p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中， 因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 –icc=false ，当指定该参数后，容器间将默认无法互访，除非互相间使用了 – links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 –icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很 轻松的实现容器间的互联与隔离。    </p><p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 -p ，是映射宿主端口和 容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明 容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 WORKDIR &lt;工作目录路径&gt; 。    </p><p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改 为指定的目录，如该目录不存在， WORKDIR 会帮你建立目录。    </p><p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解 还可能会导致出现下面这样的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /app RUN <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt </span><br></pre></td></tr></table></figure><p> 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其 内容不是 hello 。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前 一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令 的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念 不了解所导致的错误。    </p><p> 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任 何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关 系，自然不可能继承前一层构建过程中的内存变化。    </p><p> 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>详细的可以查看下面这篇，本片主要是阅读下面这本书籍的记录。</p><ul><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details">Docker —— 从入门到实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— Docker 命令使用大全</title>
      <link href="docker-command/"/>
      <url>docker-command/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录 Dcoker 使用过程中的一些命令</p></blockquote><p>在之前的一片文章——<a href="https://jlj98.top/docker-what-is-docker/">Docker —— Docker 简单介绍</a> 中介绍了 Docker。这篇主要是记录一些 Docker 的实际使用情况，以后再使用过程中如果有新的命令，也会记录。   </p><p>关于 Docker 的安装，网上有很多的教程，这里就不一一介绍了，主要说下关于 windows的安装，需要注意window版本必须是企业版，不然不能安装 Docker for Windows，主要是它需要Windows的 Hyper-V 功能，不然只能安装 Docker 之前的 DockerToolBox。</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>在 Docker Hub 上有大量高质量的镜像可以使用，只需要使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it &lt;镜像名&gt;</span><br></pre></td></tr></table></figure><p> docker run 就是运行容器的命令，具体格式下面讲解下：</p><ul><li>-it：只是两个参数，一个是 -i：交互式操作，一个是 -t 终端。</li><li>-d：需要让docker在后头运行而不是直接把执行命令的结果输出在当前宿主机下。</li></ul><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images ls &lt;仓库名/标签&gt;</span><br></pre></td></tr></table></figure><p>在镜像列表中，可能出现 <code>&lt;none&gt;</code> 这样的镜像，主要是有新的镜像，重新拉取新的镜像或者本地重新构建新的镜像，就会出现这种就得镜像 <code>&lt;none&gt;</code>。这类无标签镜像也被称为虚悬镜像(dangling image)。删除这些镜像的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>删除本地镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image rm &lt;镜像名/镜像ID&gt;</span><br><span class="line">//或者</span><br><span class="line">docker rmi &lt;镜像名/镜像ID&gt;</span><br></pre></td></tr></table></figure><h1 id="docker-容器"><a href="#docker-容器" class="headerlink" title="docker 容器"></a>docker 容器</h1><h2 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h2><p>和之前的启动镜像一样。</p><h2 id="终止-启动-重启容器"><a href="#终止-启动-重启容器" class="headerlink" title="终止/启动/重启容器"></a>终止/启动/重启容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop/start/restart [container ID or NAMES]</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>在删除容器之前，请确保容器是否已经停止运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [container ID or NAMES]</span><br></pre></td></tr></table></figure><h2 id="列举运行的容器"><a href="#列举运行的容器" class="headerlink" title="列举运行的容器"></a>列举运行的容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker los -f [container ID or NAMES] --tail 200</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 -d 参数，容器启动后悔进入后台。某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐使用 docker exec 命令。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docekr attach [container ID or NAMES]</span><br></pre></td></tr></table></figure><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [container ID or NAMES]</span><br></pre></td></tr></table></figure><p>参数使用说明：<br>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。<br>当 <code>-i -t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud —— Ribbon 负载均衡策略</title>
      <link href="spring-cloud-ribbon-balanced/"/>
      <url>spring-cloud-ribbon-balanced/</url>
      
        <content type="html"><![CDATA[<p>最近在看 Spring Cloud，买了本翟永超的《Spring Cloud 微服务实战》，感觉里面讲的挺详细的，只是书本里面的版本相对于官网来说，还是有些落后的，不过作为入门书籍还是可以的。   </p><p>今天在一个公众号里面看到一篇面试的文章，里面有一个问题问的是负载均衡，于是想起了 Spring Cloud 的 Ribbon 负载均衡策略。在Spring Cloud Ribbon 中，RestTemplate 使得 Ribbon实现了自动化配置，同时通过 @LoadBalanced 还能开启客户端负载均衡。打算好好的整理下关于负载均衡的算法策略，梳理下用的比较多的几种。   </p><p>在Spring Cloud 中，负载均衡策略都是 继承 <code>AbstractLoadBalancerRule</code>。</p><h2 id="轮询策略（默认，RoundRobinRule）"><a href="#轮询策略（默认，RoundRobinRule）" class="headerlink" title="轮询策略（默认，RoundRobinRule）"></a>轮询策略（默认，RoundRobinRule）</h2><p>轮询策略标识每次都顺序取下一个 provider，比如一共有5个，第1次去第1个，第2次取第2个，以此类推。</p><h2 id="随机策略（RandomRule）"><a href="#随机策略（RandomRule）" class="headerlink" title="随机策略（RandomRule）"></a>随机策略（RandomRule）</h2><p>该策略实现了从服务实例清单中随机选择一个服务实例功能。</p><h2 id="权重轮询策略（WeightedResponseTimeRule）"><a href="#权重轮询策略（WeightedResponseTimeRule）" class="headerlink" title="权重轮询策略（WeightedResponseTimeRule）"></a>权重轮询策略（WeightedResponseTimeRule）</h2><p>该策略是对 <code>RoundRobinRule</code> 的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例，已达到更优的分配效果，响应时间越长，权重越小，被选中的可能性越小。   </p><p>它的核心：</p><ul><li>定时任务：启动一个定时任务，用来为每个服务实例计算权重，该任务默认时间30秒执行一次。</li><li>权重计算：1、根据 LoadBalancerStats 中记录的每个实例的统计信息，累加所有实例的平均响应时间，得到总平均响应时间 <code>totalResponseTime</code>，该值会用于后面计算。2、为负载均衡器中维护的实例清单逐个计算权重，计算规则为 weightSoFar+totalResponseTime —— 实例的平均响应时间，其中 <code>weightSoFar</code> 初始化为零，并且每计算好一个权重需要累加到weightSoFar上供下次计算。</li><li>实例选择</li></ul><p>原理：一开始为轮询策略，并开启一个计时器，每30秒收集一次每个provider的平均响应时间，当信息足够时，给每个provider 附上一个权重，并按权重随机选择 provider，权重越高，选中几率越大。 </p><h2 id="最少并发数策略（BestAvailableRule）"><a href="#最少并发数策略（BestAvailableRule）" class="headerlink" title="最少并发数策略（BestAvailableRule）"></a>最少并发数策略（BestAvailableRule）</h2><p>选择正在请求中的兵书最小的 provider，除非这个 provider 在熔断中。</p><h2 id="在“选定的负载均衡策略”基础上进行重试机制（RetryRule）"><a href="#在“选定的负载均衡策略”基础上进行重试机制（RetryRule）" class="headerlink" title="在“选定的负载均衡策略”基础上进行重试机制（RetryRule）"></a>在“选定的负载均衡策略”基础上进行重试机制（RetryRule）</h2><p>该策略具备重试机制的实例选择功能。“选定的负载均衡策略”是轮询策略，改该重试策略先设定一个阈值时间段，如果在这个阈值时间段内，选择的 provider 不超过，则一直尝试采用“选定的负载均衡策略”：轮询策略，最后选择一个可用的 prov。</p><h2 id="可用性敏感策略（AvailabilityFilteringRule）"><a href="#可用性敏感策略（AvailabilityFilteringRule）" class="headerlink" title="可用性敏感策略（AvailabilityFilteringRule）"></a>可用性敏感策略（AvailabilityFilteringRule）</h2><p>继承抽象出来 PredicateBaseRule，继承了“先过滤清单，在轮询选择”的基本出来逻辑。  </p><p>主要判断服务实例中下面的内容：</p><ul><li>是否故障，即断路器是否生效已断开。</li><li>实例的并发请求数是否大于阈值，默认值为 2^32 - 1，该参数可通过参数 <code>&lt;clientName&gt;.&lt;nameSpace&gt;.ActiveConnectionsLimit</code> 来修改。</li></ul><h2 id="区域敏感性策略（ZoneAvoidanceRule）"><a href="#区域敏感性策略（ZoneAvoidanceRule）" class="headerlink" title="区域敏感性策略（ZoneAvoidanceRule）"></a>区域敏感性策略（ZoneAvoidanceRule）</h2><p>以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下的 provider 中选择。如果这个ip 区域内有一个或者多个实例不可达或反应变慢，会降低 ip 区域内其他 ip 被选中的权重。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker —— Docker 简单介绍</title>
      <link href="docker-what-is-docker/"/>
      <url>docker-what-is-docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇只是也是本人在学习了解 Docker 的记录</p></blockquote><p>现在在互联网公司中，Docker 的使用已经非常普遍了，在一些大公司中，都在内部实现容器化（PS:这些也是网上了解到了）。Docker 是一个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，总之，Docker 容器化给计算机行业带来了大变革。Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面是传统虚拟化方式和 Docker 的比较。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/af94f045a65a123feb0e973238d0419d.jpg"><br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/5ac1fcf840bb0fef081b5e5ad2fc8bbf.jpg"></p><p>如果了解<a href="https://jlj98.top/docker-container-namespace-cgroups/">Docker —— 容器的隔离与限制</a>后，会发现上面关于Docker的描述不是很正确，对于容器来说，其实是运行在宿主机上的，而不是Docker Engine 上。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200114193503.png" alt="container-w150"> </p><h1 id="为什么使用-Docker"><a href="#为什么使用-Docker" class="headerlink" title="为什么使用 Docker"></a>为什么使用 Docker</h1><h2 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h2><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h2 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h2><p>Docker 容器应用直接运行在宿主内核，无需启动完整的操作系统，可以做到快速的启动。</p><h2 id="一直的运行环境"><a href="#一直的运行环境" class="headerlink" title="一直的运行环境"></a>一直的运行环境</h2><p>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h2 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h2><p>开发人员使用 Dockerfile 构建镜像，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员可以直接在生产环境快速部署，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p><h2 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况</p><h2 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h2><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h2><table><thead><tr><th>特性</th><th>Docker 容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/b7e9f66c92978f820fa1fc5a6cc36d18.jpg"></p><p>Docker：容器是应用层的抽象，它将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c837bac155b9aaf5fd28af9a021f2236.jpg"></p><p>虚拟机：虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。虚拟机管理程序允许多台虚拟机在一台计算机上运行。每个VM都包含操作系统的完整副本，应用程序，必要的二进制文件和库 —— 占用数十GB。虚拟机也可能很慢启动。</p><h1 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h1><p>Docker 三个基本概念：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>操作系统分为内核和用户空间，对于Linux，内核启动后，会加载 <code>root</code> 问价系统为妻提供用户空间支持，而 Docker 镜像（image）就相当于一个 <code>root</code> 文件系统。  </p><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时需要的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。  </p><p>Docker 镜像的文件系统是分层存储的。  </p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>镜像和容器存在一定的关系，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。  </p><p>容器存储层的生命周期和容器一样，当容器消亡时，容器存储也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。    </p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>存储打包好的镜像，方便可以从别的服务器上拉取构建的镜像。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details">Docker —— 从入门到实践</a></li><li><a href="https://www.docker.com/resources/what-container">What is a Container</a></li><li><a href="https://draveness.me/docker">Docker 核心技术与实现原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 服务集群</title>
      <link href="redis-server-mater-salve/"/>
      <url>redis-server-mater-salve/</url>
      
        <content type="html"><![CDATA[<p>Redis系列：</p><ul><li><a href="https://jlj98.top/redis-basic-knowledge/">Redis——初识Redis</a></li><li><a href="https://jlj98.top/redis-under-structure/">Redis——底层结构</a></li><li><a href="https://jlj98.top/redis-database/">Redis——数据库实现</a></li><li><a href="https://jlj98.top/redis-server-mater-salve/">Redis 服务集群</a></li></ul><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>在 Redis 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制另一个服务器，被复制的叫主服务器（master），对主服务器进行复制的叫从服务器（slave）。</p><p>命令是在从服务器上执行的。</p><h2 id="旧版复制功能"><a href="#旧版复制功能" class="headerlink" title="旧版复制功能"></a>旧版复制功能</h2><p>对于初次复制，旧版复制功能能够很好完成，但是对于短线后的复制来说，其效率非常低。主要是这种复制对于短线后的从服务器来说，会把主服务器的所有 RDB 文件发送给从服务器。<br>SYNC 命令是一个非常耗费资源的操作。每次执行命令，主从服务器需要执行下面操作：</p><ul><li>主服务器需要执行 BGSAVE 命令来生成 RDB 文件，这个操作会耗费主服务器大量的 CPU、内存和磁盘I/O资源</li><li>主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送会耗费注册服务器大量的网络资源，并对主服务器响应命令请求的时间产生影响</li><li>接收到 RDB 文件的从服务器需要载入主服务器发来的 RDB 文件，并在载入期间，从服务器会因为阻塞而没办法处理请求</li></ul><h2 id="新版复制功能"><a href="#新版复制功能" class="headerlink" title="新版复制功能"></a>新版复制功能</h2><p>PSYNC 代替 SYNC 命令来执行复制的同步操作。<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>:其中 runid 是上一次复制的主服务器的运行ID,而 offset则是从服务器当前的复制偏移量,接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。</p><ul><li>完整同步：处理初次复制情况</li><li>部分重同步：处理短线后重复制情况。</li></ul><h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>执行复制的双方会分别维护一个复制偏移量。通过对比主从服务器复制偏移量，可以清楚只掉注册服务器是否处于一致状态。</p><ul><li>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N。</li><li>从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N。</li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>复制大约分为6个步骤：</p><ul><li>保存主节点（master）信息：执行 slaveof 后从节点值保存主节点的地址信息变直接返回了，这是建立复制流程还没有开始，在从节点执行 info replication 可以查看一些信息。</li><li>从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的猪节点后，会尝试与该节点简历网络连接。</li><li>发送 ping 命令。连接简历成功后从节点发送 ping 请求进行首次通信，ping 请求主要目的：检测主从之间网络套接字是否可用；检测主从节点当前是否可接受处理命令。</li><li>权限验证。如果主节点设置了 requirepass 参数，则需要密码验证，从节点必须配置 masterauth 参数保证与主节点的相同的密码才能通过验证；如果验证失败复制将终止，从节点重新发起复制流程。</li><li>同步数据。主从复制连接正常通信后，对首次简历的复制场景，主节点会把持有数据全部发送给从节点，这部分操作是耗时最长的步骤。</li><li>命令持续复制。当主节点吧当前的数据同步给从节点，便完成了复制的建立流程。接下来主节点会持续的吧写命令发送给从节点，保证主从数据的一致性。</li></ul><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>Redis 的主从复制模式下，一旦节点由于故障不能提供服务，就需要人工的把从节点晋升为主节点，同时通知应用方更新胡节点，这种方式在多应用场景是不能接收的。Redis 提供了 Redis sentinel 来解决这个问题。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis Cluster 是 Redis 的分布式解决方案，有效的解决了 Redis 分布式方面的需求。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="distributed-lock/"/>
      <url>distributed-lock/</url>
      
        <content type="html"><![CDATA[<p>现实生产环境中为什么需要分布式锁？   </p><p>在现在的公司的生产环境中，一个项目的部署最起码需要两台服务器，你不可以在你产品上线部署的时候，不让用户使用你们公司的产品，而且分布式部署，通过Nginx的负载均衡，也可以减轻单台服务器的压力，带来性能和效率上的提升。那么问题来了，在分布式部署产品的时候，就会产生一个问题，如何保证数据的一致性。当某个资源在多个系统之间，存在着共享的时候，为了保证大家访问这个资源数据是一致性的，就必须保证统一时刻只能有只有一个客户端出来，不能并发执行。单机部署，我们需要考虑并发问题，我们往往采用线程间加锁的机制。但是在分布式系统时代，为了实现我们之前的问题，就必须考虑分布式锁了。   </p><p>分布式锁指的是在分布式部署环境下，通过锁机制来让多客户端互斥的对共享资源镜像访问。   </p><p>目前主流的分布式锁的技术：</p><ul><li>基于数据库实现</li><li>基于Redis实现（本篇主要讲的内容）</li><li>基于Memcached实现</li><li>基于 ZooKeeper实现</li></ul><h1 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h1><p>基于数据库实现分布式锁，主要是依靠数据库的乐观锁或者悲观锁来实现。这里可以看下我之前的博客—<a href="https://jlj98.top/mysql-locks/">MySQL数据库锁机制</a>。</p><h2 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h2><p>在数据库表里面引入一个版本号(version)，通过这个字段来控制数据是否更新。</p><h2 id="基于悲观锁"><a href="#基于悲观锁" class="headerlink" title="基于悲观锁"></a>基于悲观锁</h2><p>悲观锁也叫排他锁，在 MySQL 中主要是通过 <code>for update</code> 来实现加锁。</p><h1 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h1><p>使用Redis来实现分布式锁，主要依靠Redis自身的原子操作。通过Redis在缓存中占个“坑位”，告诉后来者，这个“坑”已经被我占用了，你要使用，请稍后。</p><p>在之前的版本中，使用 <code>setnx key value</code>，如果这个key在Redis中不存在，这个命令会往Redis中插入一条数据，返回数据 1，如果存在就会返回 0。在使用后，使用Redis的del删除这条数据。<br>不过存在问题的是如果在两个命令之间出现异常，那么就不会删除数据，一种方法是使用try{}catch{}finally{}，删除的命令放到finally里面。另外一种是加一个过期时间，不过加过期时间的话，就有存在一个问题，过期时间大小的控制，如果时间小，这个现场还没结束，这条数据就过期了怎么办？     </p><p>在Redis 2.6.12 版本后，字符串命令中加入了一些参数，<code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code>，这才是它所提供全部的命令。不过从这个命令中可以看出，在后来版本的Redis中，基本上 <code>set</code> 命令取代了 <code>setnx</code> 。</p><ul><li>EX/PX： EX指的是秒数；PX指的是毫秒</li><li>NX/XX：NX表示当key不存在是，创建保存；XX表示当key存在是，保存value</li></ul><p><a href="https://juejin.im/post/5b8737cdf265da43737ea13a">Redis分布式锁解决方案</a></p><p>注意点：</p><ul><li>set命令要用set key value px milliseconds nx；</li><li>value要具有唯一性；</li><li>释放锁时要验证value值，不能误解锁；</li></ul><p>这类锁在也是比较容易实现的，但是这种分布式锁最大的缺点就是<strong>加锁是只能作用在一个Redis节点上</strong>，即使Redis通过sentinel保证高可用，如果这个master节点由于某种原因发生了主从切换，那么就会出现锁丢失的情况：</p><ul><li>在Redis的master节点拿到锁</li><li>但是这个锁的key还没有同步到slave节点</li><li>master故障，发生故障转移，slave节点升级为master节点</li><li>导致锁丢失</li></ul><h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>Redis 作者基于上面的问题，提出了 <a href="https://redis.io/topics/distlock">Redlock算法</a>。</p><p>在算法的分布式版本中，我们假设我们有N个Redis主机。这些节点完全独立，因此我们不使用复制或任何其他隐式协调系统。我们已经描述了如何在单个实例中安全地获取和释放锁。我们理所当然地认为算法将使用此方法在单个实例中获取和释放锁。在我们的示例中，我们设置N = 5，这是一个合理的值，因此我们需要在不同的计算机或虚拟机上运行5个Redis主服务器，以确保它们以大多数独立的方式失败。</p><p>为了获取锁，客户端执行以下操作：</p><ul><li><p>以毫秒为单位获取当前时间。</p></li><li><p>它尝试按顺序获取所有N个实例中的锁，在所有实例中使用<strong>相同的键名和随机值</strong>。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</p></li><li><p>客户端通过从当前时间中减去开始获取锁的时间戳（步骤1中记录的时间）来计算获取锁定使用所需的时间。当且仅当客户端能够在大多数实例中获取锁定时（N/2+1，这里至少3个）并且获取锁定所经过的总时间小于锁定有效时间，认为锁定被获取。</p></li><li><p>如果获得了锁，key的有效时间被认为是初始有效时间减去经过的时间，如步骤3中计算的。</p></li><li><p>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p></li></ul><h2 id="Redlock算法的实现"><a href="#Redlock算法的实现" class="headerlink" title="Redlock算法的实现"></a>Redlock算法的实现</h2><p>redisson 已经对Redlock算法封装了。在 POM 中引入 redisson。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>具体关于 <a href="https://www.jianshu.com/p/7e47a4503b87">Redission 实现和源码解析</a>。</p><h1 id="基于Memcached实现"><a href="#基于Memcached实现" class="headerlink" title="基于Memcached实现"></a>基于Memcached实现</h1><p>这种方式和基于Redis类似，利用 Memcached 的 add 命令。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。</p><h1 id="基于ZooKeeper"><a href="#基于ZooKeeper" class="headerlink" title="基于ZooKeeper"></a>基于ZooKeeper</h1><blockquote><p>这部分主要是看网上的资料了解的。<br>利用Zookeeper的顺序临时节点，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的。   </p></blockquote><p>原理就是：当某客户端要进行逻辑的加锁时，就在zookeeper上的某个指定节点的目录下，去生成一个唯一的临时有序节点， 然后判断自己是否是这些有序节点中序号最小的一个，如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到比自己小的那个节点，并对其调用exist()方法，对其注册事件监听，当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。</p>]]></content>
      
      
      <categories>
          
          <category> distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程 Thread</title>
      <link href="java-thread/"/>
      <url>java-thread/</url>
      
        <content type="html"><![CDATA[<p>现代操作系统中，运行一个程序时，会创建一个进程。现代操作系统的最小调度单元是线程，在一个进程中创建多个线程。</p><h2 id="Java-线程状态"><a href="#Java-线程状态" class="headerlink" title="Java 线程状态"></a>Java 线程状态</h2><ul><li> NEW：初始状态，线程构建但没有调用 start 方法</li><li>RUNNABLE：运行状态，Java操作系统中的就绪和运行状态的统称</li><li>BLOCKED：阻塞状态，表示线程阻塞于 <strong>锁</strong></li><li>WAITING：等待状态，表示线程进入等待，进入等待状态表示当前线程需要其他线程做出一些特定动作（通知或中断）</li><li>TIME_WAITING：超时等待状态，该主题不同于 WAITING，它是可以在指定时间内自动返回</li><li>TERMINATED：终止状态，表示该线程执行完毕</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动使用 start() 方法，含义：当前线程同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用 start() 方法的线程。   </p><h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join() 的使用"></a>Thread.join() 的使用</h2><p> 如果线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程执行终止之后，才从thread.join()返回。线程Thread 还提供 join(long millis) 和 join(long millis, int nanos) 两个具备超时特性的方法。这两个方法表示，如果线程thread在给定的超时时间内没有终止，那么将会从超时方法中返回。</p><h2 id="start-和-run"><a href="#start-和-run" class="headerlink" title="start 和 run"></a>start 和 run</h2><p> start()只是让线程处于就绪状态。告诉CPU我已经准备好了，可以调用我了。而run()则是直接按顺序执行。</p><h2 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait() 和 sleep()"></a>wait() 和 sleep()</h2><p> wait()、notify()、notifyAll() 是 Object 类的方法；sleep() 和 yield() 是 Thread 类的方法。</p><h2 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h2><p> 在多线程中，经常会提到这两个概念，串行和并行。</p><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><p> 串行指的是由单个线程来完成多个线程任务。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p> 并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的在同一时刻发生的，并行在时间上是重叠的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范</title>
      <link href="code-standard/"/>
      <url>code-standard/</url>
      
        <content type="html"><![CDATA[<h1 id="Git提交规范"><a href="#Git提交规范" class="headerlink" title="Git提交规范"></a>Git提交规范</h1><p>Git Commit 规范：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;):&lt;subject&gt;</span><br></pre></td></tr></table></figure><p>具体里面参数的含义：</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>用于说明 commit 的类别，值允许使用下面7中标识：</p><ul><li>feat：新功能（featur）</li><li>fix：修补bug</li><li>doc：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或者辅助工具的变动</li></ul><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</p><h2 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h2><p>用于commit 目的的简单描述，不得超过50个字符。</p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>命名的时候，取一个好的命名是非常重要的。</p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名和对象名应该使用 <strong>名词或者名词短语</strong>，如 Customer、WikiPage等，避免使用 Manager、Processor、Data 或 Info这样的类名。</p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>方法名应该是 <strong>动词或者动词短语</strong>，如postPayment、deletePage 或 save。属性访问器、修改其和断言应该根据其值命名，并咦Javabean标准加上 get、set 和 is 前缀。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h2><p>函数代码行数尽量不要很多。</p><h2 id="抽离-try-catch-代码块"><a href="#抽离-try-catch-代码块" class="headerlink" title="抽离 try/catch 代码块"></a>抽离 try/catch 代码块</h2><p>书上说 try/catch 代码块打乱了代码结构，把错误代码处理和正常处理混为一谈。书上的建议是抽离出错误代码块，形成函数。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/Java_1512024443940.pdf">阿里巴巴Java开发手册</a></li><li>《代码整洁之道》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的存储引擎 —— InnoDB和MyIsAM</title>
      <link href="mysql-innodb-myisam/"/>
      <url>mysql-innodb-myisam/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎指正。</p></blockquote><p>MySQL 作为现在互联网行业使用最广的数据库之一，最近几天刚好看到两者的区别，就想了解下数据库的存储引擎。MySQL的主流数据存储引擎有 InnoDB 和 MyIsAM 两种。</p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB 是 MySQL 的默认事务性引擎，它被设计用来处理大量短期事务，短期事务大部分情况是正常提交的，很少会回滚。InnoDB采用 MVCC(多版本并发控制)来支持高并发，并实现四个标准的隔离级别。其默认级别是 REPEATABLE READ(可重复读)，并且通过间隙锁策略防止出现幻读的出现。</p><p>InnoDB 引擎是基于聚簇索引建立的。聚索簇引对主键查询有很高的性能。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>可以认为是行级锁的一个变种，但是在很多情况下避免了加锁的操作，因此开销更低。实现思路大体都是非阻塞的读，写操作只锁定必要的行。</p><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本</li><li>修改时Copy出当前版本随意修改，每个事务之间无干扰</li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><p>就是每行都有版本号，保存时根据版本号决定是否成功，挺像乐观锁的，而 Innodb 的实现方式是：</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul><p>理想的MVCC很难实现。如果 Transaciton1 执行理想的 MVCC，修改 Row1 成功，而修改 Row2 失败，此时需要回滚 Row1，但因为 Row1 没有被锁定，其数据可能又被 Transaction2 所修改，如果此时回滚 Row1 的内容，则会破坏 Transaction2 的修改结果，导致 Transaction2 违反 ACID。</p><h3 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h3><p>InnoDB 的设计者为我们提供了4中不同类型的行格式分别是 <code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code> 和 <code>Compressed</code> 行格式。</p><h3 id="VARCHAR-M-溢出"><a href="#VARCHAR-M-溢出" class="headerlink" title="VARCHAR(M)溢出"></a>VARCHAR(M)溢出</h3><p>varchar 类型字段占用的字节长度不能超过 <code>65535</code>。但是在实际中，varchar 类型的列，其实需要占用3部分储存空间：</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li>NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分储存空间</li></ul><p>如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><h2 id="MyIsAM-存储引擎"><a href="#MyIsAM-存储引擎" class="headerlink" title="MyIsAM 存储引擎"></a>MyIsAM 存储引擎</h2><p>MyIsAM 存储引擎提供了大量特性，包括全文索引、压缩、空间函数等，但是它不支持事务和行级锁，这是和InnoDB存储引擎的区别之一。对于只读数据，或者表比较小、可以忍受修复操作，则可以使用MyIsAM引擎。</p><h3 id="MyIsAM-特性"><a href="#MyIsAM-特性" class="headerlink" title="MyIsAM 特性"></a>MyIsAM 特性</h3><ul><li>加锁和并发：MyIsAM 对整张表加锁，而不是针对行。读数据会对需要读到的所有表加共享锁，写入是则对表加排他锁。但是在表有读取查询的时候，也可以往表里插入新数据。</li><li>修复：手动或者自动执行检查和修复操作。</li><li>索引特性：可以针对长字段，基于其前500个字符创建索引。MyIsAM 也支持全文索引，这是一种基于分词创建的索引。</li><li>延迟更新索引键：创建 MyISAM表的时候，如果指定了 DELAY KEY WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。</li></ul><h2 id="InnoDB和MyIsAM的区别"><a href="#InnoDB和MyIsAM的区别" class="headerlink" title="InnoDB和MyIsAM的区别"></a>InnoDB和MyIsAM的区别</h2><p>下面的表格简单的列举了两者的区别：</p><table><thead><tr><th></th><th>InnoDB</th><th>MyIsAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>锁</td><td>MVCC</td><td>表锁</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>存储空间</td><td>存储空间需要高速缓存，较大</td><td>可压缩</td></tr><tr><td>使用场景</td><td>有一定量的insert和update</td><td>大量select</td></tr><tr><td>是否支持全文查询</td><td>5.6之后就支持了</td><td>支持</td></tr></tbody></table><p>下面的内容是别人公众号里看了的。</p><h3 id="关于count"><a href="#关于count" class="headerlink" title="关于count(*)"></a>关于count(*)</h3><p>MyISAM 会直接存储总行数，InnoDB则不会，需要按行扫描。对于select count(*) from t; 如果数据量大，MyISAM 会瞬间返回，而InnoDB则会一行行扫描。  </p><p>常见坑：只有查询全表的总行数，MyISAM才会直接返回结果，当加了where条件后，两种存储引擎的处理方式类似。</p><h3 id="关于全文索引"><a href="#关于全文索引" class="headerlink" title="关于全文索引"></a>关于全文索引</h3><p>MyISAM 支持全文索引，InnoDB5.6 之前不支持全文索引。</p><h3 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h3><p>MyISAM不支持事务，InnoDB支持事务。</p><h3 id="关于外键"><a href="#关于外键" class="headerlink" title="关于外键"></a>关于外键</h3><p>知识点：MyISAM不支持外键，InnoDB支持外键。</p><p>实践：不管哪种存储引擎，在数据量大并发量大的情况下，都不应该使用外键，而建议由应用程序保证完整性。</p><h3 id="关于行锁与表锁"><a href="#关于行锁与表锁" class="headerlink" title="关于行锁与表锁"></a>关于行锁与表锁</h3><p>知识点：MyISAM只支持表锁，InnoDB可以支持行锁。</p><p>分析：MyISAM：执行读写SQL语句时，会对表加锁，所以数据量大，并发量高时，性能会急剧下降。<br>InnoDB：细粒度行锁，在数据量大，并发量高时，性能比较优异。   </p><p>实践：网上常说，select+insert的业务用MyISAM，因为MyISAM在文件尾部顺序增加记录速度极快。楼主的建议是，绝大部分业务是混合读写，只要数据量和并发量较大，一律使用InnoDB。</p><p>常见坑：InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《高性能MySQL（第三版）》</li><li><a href="https://juejin.im/post/5b6c5be86fb9a04fb30a2bc7">为什么开发人员必须要了解数据库锁？</a></li><li><a href="https://mp.weixin.qq.com/s/JEJcgD36dpKgbUi7xo6DzA">InnoDB，5项最佳实践，知其所以然？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis —— 数据库实现</title>
      <link href="redis-database/"/>
      <url>redis-database/</url>
      
        <content type="html"><![CDATA[<p>Redis系列：</p><ul><li><a href="https://jlj98.top/redis-basic-knowledge/">Redis——初识Redis</a></li><li><a href="https://jlj98.top/redis-under-structure/">Redis——底层结构</a></li><li><a href="https://jlj98.top/redis-database/">Redis——数据库实现</a></li><li><a href="https://jlj98.top/redis-server-mater-salve/">Redis 服务集群</a></li></ul><p>Redis是一款NoSQL数据库，在大多数项目中作为缓存使用，也可以作为数据库，存储数据。</p><ul><li><a href="https://github.com/antirez/redis">Redis源码</a></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>Redis服务器将所有数据库都保存在服务器状态 <code>redis.h/redisServer</code> 结构的 <code>db</code> 数组中，<code>db</code> 数组的每个项都是一个 <code>redis.h/redisDb</code>结构，每个 <code>redis</code> 结构代表个数据库:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    redisDb *db;<span class="comment">//数组，保存服务器中的所有数据库</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> dbnum; <span class="comment">//服务器数据库数量，默认16个</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//数据库键空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间，保存着数据库中所有键值对 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 过期字典，保存所有过期时间*/</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><ul><li><p>定时删除：在设置键的过期时间的同时，创建一个定时器( timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。这种策略对内存友好，但是对CPU时间是最不友好的：在过期间比较多的情况下，删除过期键这一行为可能会占用箱单大一部分CPU时间，影响服务器的响应时间和吞吐量。</p></li><li><p>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。这种策略是对内存很不友好，如果一些过期键，一直没被查找，就会一直占用内存，可能会出现内存泄露的危险。</p></li><li><p>定期删除：每隔一段时间，程序就对数据库进行一次检査，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定</p></li></ul><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。 </p><p>Redis 服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h2><p>Redis 提供了6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ul><p>4.0 版本后增加了以下两种：</p><ul><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ul><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><h2 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB (Redis DataBase) 持久化"></a>RDB (Redis DataBase) 持久化</h2><p>因为 Redis 是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一且服务器进程退出，服务器中的数据库状态也会消失不见。为了解决这个问题，Redis 提供了 RDB 持久化功能，可以将 Redis 在内存中的数据库状态保存到磁盘中，避免数据丢失。RDB是一个经过压缩的二进制文件。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/fb1f4dd82647357663581535d5ebe744.jpg"></p><p>Redis 有两个命令用来自生成 RDB 文件：<code>SAVE</code> 和 <code>BGSAVE</code>。</p><ul><li>SAVE：当 save 执行是，Redis服务器会被阻塞，客户端发送的所有命令请求都会被拒绝。</li><li>BGSAVE：Redis 进程执行 fork 操作创建子进程，所以 Redis 服务器可以继续执行客户端的命令。</li></ul><p>在 Redis 涉及 RDB 的操作都采用 <code>BGSAVE</code> 的方式，而 <code>SAVE</code> 命令已经废弃。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/b336872f74a6e24214f7769bfb6e8ae1.jpg"></p><p>RDB文件的最开头是 REDIS 部分，这个部分的长度为5字节，保存着 <code>REDIS</code> 五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载人的文件是否RDB文件。</p><p>db version 长度为 <code>4字节</code>，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006就代表RDB文件的版本为第六版。本章只介绍第六版 RDB 文件的结构。</p><p>databases 部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据:</p><ul><li>如果服务器的数据库状态为空(所有数据库都是空的)，那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空(有至少一个数据库非空)，那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇<br>这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。  </p><p>check sum 是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对 REDIS、 db version、 databases、EoF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与 check sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><p>RDB 快照的过程如下：</p><ul><li>Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li><li>父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li><li>当子进程写入完所有数据后会用该临时文件替换旧的 RDB 文件，至此一次快照操作完成。</li></ul><h3 id="Copy-On-Write-机制"><a href="#Copy-On-Write-机制" class="headerlink" title="Copy-On-Write 机制"></a>Copy-On-Write 机制</h3><p>核心思路：fork 一个子进程，只在父进程发生写操作修改内存数据时，才会真正去分配内存空间，并复制内存数据，而且也<strong>只是复制被修改的内存页中的数据，并不是全部内存数据</strong>，所以新的RDB文件存储的是执行 fork 那一刻的内存数据。</p><ul><li>Redis中执行BGSAVE命令生成RDB文件时，本质就是调用Linux中的fork()命令，Linux下的fork()系统调用实现了<code>Copy-On-Write</code>写时复制；</li><li>fork()是类Unix操作系统上创建线程的主要方法，fork用于创建子进程（等同于当前进程的副本）；</li><li>传统的普通进程复制，会直接将父进程的数据拷贝到子进程中，拷贝完成后，父进程和子进程之间的数据段和堆栈是相互独立的；</li><li><code>Copy-On-Write</code>技术，在fork出子进程后，与父进程共享内存空间，两者只是虚拟空间不同，但是其对应的物理空间是同一个。</li></ul><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>AOF 持久化是通过保存 Redis 服务器所执行的<strong>写命令</strong>来记录数据库状态的，查询操作不会记录，AOF 命令写入的内容直接是文本协议格式，在重启时在执行 AOF 文件中的命令达到恢复数据的目的。</p><p>AOF 的主要作用是解决数据持久化的实时性，目前已经是 Redis 持久化的主流方式。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/d82b58f9af0b26a6b461b7aad20f7025.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">&quot;hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; PUSH number 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>)3</span><br></pre></td></tr></table></figure><p>对于RDB持久化存储的是SET、PUSH这两个键值对；AOF持久化存储的是SET、PUSH这两个命令。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志 “瘦身”。</p><p>Redis 提供了 <code>bgrewriteaof</code> 指令用于对 AOF 日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。</p><h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h3><p>AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回磁盘中。</p><p>Redis 提供2中策略</p><ul><li>永不 fsync : 让操作系统来决定适合同步磁盘</li><li>fsync : 使用 fsync 紫菱，Redis 每个1秒执行一次 fsync 命令</li></ul><h2 id="RDB-和-AOF-比较"><a href="#RDB-和-AOF-比较" class="headerlink" title="RDB 和 AOF 比较"></a>RDB 和 AOF 比较</h2><h3 id="RDB-持久化优缺点"><a href="#RDB-持久化优缺点" class="headerlink" title="RDB 持久化优缺点"></a>RDB 持久化优缺点</h3><p>RDB 持久化优点：</p><ul><li>使用 RDB 持久化，整个 Redis 数据库将只包含一个文件，这对于文件备份而言非常完美</li><li>对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于 AOF 机制，如果数据集很大，RDB的启动效率会更高</li></ul><p>RDB 持久化缺点：</p><ul><li>如果想保证 Redis 数据的高可用性，即最大限度的避免数据丢失，RDB 不是一个好的选择。在 Redis 定时持久化之前出现宕机现象，就不能保证数据及时写入磁盘中。</li><li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作，当数据集比较大的时候，可能导致整个服务器停止服务操作。</li></ul><h3 id="AOF-持久化优缺点"><a href="#AOF-持久化优缺点" class="headerlink" title="AOF 持久化优缺点"></a>AOF 持久化优缺点</h3><p>AOF 持久化优点：</p><ul><li>该方法保证了数据的安全性。Redis 中提供了3种同步策略，即每秒同步、每修过同步和不同步。每秒同步是异步完成的，其效率是非常高的，其缺点是出现宕机时，这一秒内修改的数据会丢失；每修改同步，可以看做为同步持久化，即每次数据发生变化时，就记入到磁盘中，这种同步方法性能相对比较低；不同步就是字面的意思。</li><li>该机制对日志文件的写入操作采用的是 append 模式，因此即使在写入过程中出现宕机现象，也不会破坏之前的日志文件内容。如果本次操作只是写入了一半数据就出现了系统崩溃问题，不需要担心数据丢失，在Redis下一次启动之前，我们可以通过redis-check-aof 工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis 可以自动启用 rewrite 机制。即 Redis 以 append 模式不断的将修改数据写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行 rewrite 切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul><p>AOF 持久化缺点：</p><ul><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于持久化的选择，主要看系统是愿意牺牲一些性能，换取更高的缓存一致性（AOF），还是愿意写操作频繁的时候，不启动被封换取高性能，手动运行备份（RDB）。</p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件:</p><ul><li>文件事件(file event): Redis服务器通过套接字与客户端(或者其他 Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件(time event): Redis服务器中的一些操作(比如 servercron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis 基于Reactor模式开发了自己的网络事件处理器即文件事件处理器。<br>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事务处理器。</p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类:</p><ul><li>定时事件:让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>周期性事件:让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件的三个属性：</p><ul><li>ID：服务器为时间事件创建的全局唯一ID。</li><li>when：毫秒精度的UNX时间戳，记录了时间事件的到达( arrive )时间。</li><li>timeproc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>服务器把所有时间事件都放在一个无序链表中，每当时间事件执行，遍历整个链表，查找所有已达的时间事件，并调用相应的事件处理器。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>命令请求过程：</p><ul><li>客户端向服务器发送请求命令：Redis服务器的命令请求来自Reds客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</li><li>服务器接收并处理客户端发来的命令请求，在数据库中进行设置操作，并尝试命令回复OK<ul><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。</li><li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里面</li><li>调用命令执行器，执行客户端指定的命令</li></ul></li><li>服务器将命令回复OK发送给客户端</li><li>客户端接收到服务器的返回的命令OK，并打印显示在客户端</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://draveness.me/whys-the-design-redis-bgsave-fork/">为什么 Redis 快照使用子进程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis —— 底层结构</title>
      <link href="redis-under-structure/"/>
      <url>redis-under-structure/</url>
      
        <content type="html"><![CDATA[<p>Redis系列：</p><ul><li><a href="https://jlj98.top/redis-basic-knowledge/">Redis——初识Redis</a></li><li><a href="https://jlj98.top/redis-under-structure/">Redis——底层结构</a></li><li><a href="https://jlj98.top/redis-database/">Redis——数据库实现</a></li><li><a href="https://jlj98.top/redis-server-mater-salve/">Redis 服务集群</a></li></ul><p>对于Redis的一些基本知识，在之前的博客<a href="https://jlj98.top/redis-basic-knowledge/">Redis——初识Redis</a>中简单的介绍了。最近打算了解下Redis的一些底层内容，买了本书《Redis设计与实现》，这本书才看，也不好评价好坏。之所以选择这个本，是因为看到说这本书讲的是Redis的一些底层内容。</p><h2 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h2><p>redis源码里面的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型  </span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">// 编码方式 </span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// 对象的「热度」</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 对象的 body</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>在 LRU 模式下，lru 字段存储的是 Redis 时钟 server.lruclock。Redis 时钟是一个 24bit 的整数，默认是 Unix 时间戳对 2^24 取模的结果，大约 97 天清零一次。当某个 key 被访问一次，它的对象头的 lru 字段值就会被更新为 server.lruclock。</p><p>默认 Redis 时钟值每毫秒更新一次，在定时任务 serverCron 里主动设置。Redis 的很多定时任务都是在 serverCron 里面完成的，比如大型 hash 表的渐进式迁移、过期 key 的主动淘汰、触发 bgsave、bgaofrewrite 等等。</p><p>如果 server.lruclock 没有折返 (对 2^24 取模)，它就是一直递增的，这意味着对象的 LRU 字段不会超过 server.lruclock 的值。如果超过了，说明  server.lruclock 折返了。通过这个逻辑就可以精准计算出对象多长时间没有被访问——对象的空闲时间。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>Redis 4.0 里引入了一个新的淘汰策略 —— LFU 模式。 </p><p>在 LFU 模式下，lru 字段 24 个 bit 用来存储两个值，分别是 ldt(last decrement time) 和 logc(logistic counter)。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/289c902d9239e15b33ea307b5fc9e9b4.jpg"></p><p>logc 是 8 个 bit，用来存储访问频次，因为 8 个 bit 能表示的最大整数值为 255，存储频次肯定远远不够，所以这 8 个 bit 存储的是频次的对数值，并且这个值还会随时间衰减。如果它的值比较小，那么就很容易被回收。为了确保新创建的对象不被回收，新对象的这 8 个 bit 会初始化为一个大于零的值，默认是LFU_INIT_VAL=5。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/31e234eb533897803bd1b1f1e52a4578.jpg"> </p><p>ldt 是 16 个位，用来存储上一次 logc 的更新时间，因为只有 16 位，所以精度不可能很高。它取的是分钟时间戳对 2^16 进行取模，大约每隔 45 天就会折返。同 LRU 模式一样，我们也可以使用这个逻辑计算出对象的空闲时间，只不过精度是分钟级别的。图中的 server.unixtime 是当前 redis 记录的系统时间戳，和 server.lruclock 一样，它也是每毫秒更新一次。</p><h2 id="Redis对象底层数据结构"><a href="#Redis对象底层数据结构" class="headerlink" title="Redis对象底层数据结构"></a>Redis对象底层数据结构</h2><p>底层数据结构共有八种，如下表所示：</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td><code>long</code> 类型的整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td><code>embstr</code> 编码的简单动态字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串叫 <code>SDS</code>，相对于 <code>C</code> 语言，它的结构信息带有长度信息的字节数组，而 <code>C</code> 语言则需要变量字符串，判断最后一位是否是 <code>\0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;</span>T&gt; &#123;</span><br><span class="line">  T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">  T len; <span class="comment">// 数组长度</span></span><br><span class="line">  byte flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">  byte[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时候两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。</p><h3 id="跳跃列表（skipList）"><a href="#跳跃列表（skipList）" class="headerlink" title="跳跃列表（skipList）"></a>跳跃列表（skipList）</h3><p>跳跃列表的查询如下图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/4aab7300b5d406e362517e54d9c7f0e7.jpg"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis使用对象来表示数据库中的键和值，每次当我们在 Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(键对象)，另一个对象用作键值对的值(值对象)。</p><p>举个例子，以下SET命令在数据库中创建了一个新的键值对，其中键值对的键是一个包含了字符串值”msg”的对象，而键值对的值则是一个包含了字符串值”hello world”的对象。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串对象的编码可以是 int、raw 或者 embstr。</p><ul><li>int：8个字节的长整型</li><li>embstr：小于等于44个字节的字符串</li><li>raw：大于44个字节的字符串</li></ul><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将 void* 转换成 long)，并将字符串对象的编码设置为int。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面创建字符串对象中可以看出，**如果字符串长度小于44，就用<code>embstr</code>创建对象，否则使用<code>Raw</code>**。</p><p>embstr 编码是专门用于保存短字符串的一种优化编码方式，这种编码和 <code>raw</code> 编码一样，都使用 <code>redisobject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象，但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 redisobject 结构和 sdshdr 结构，而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含 redisobject 和 sdshdr 两个结构。</p><p><code>embstr</code> 的好处有如下几点：</p><ul><li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li><li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数,而释放 <code>raw</code> 编码的字符串对象需要调用两次内存释放函数。</li><li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面,所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code>。</p><p>ziplist 编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点(entry)保存了一个列表元素。举例，如果我们执行以下 <code>RPUSH命令</code>，那么服务器将创建一个列表对象作为 <code>numbers</code> 键的值 。</p><p>当 List 对象同时满足以下两个条件时，List 列表使用 ziplist 进行存储，否则使用 linkedlist:</p><ul><li>列表对象保存的所有字符串元素的长度小于 64 字节</li><li>列表对象保存的元素数量小于 512 个</li></ul><p>linkedlist 编码的列表对象使用双端链表作为底层实现，每个双端链表节点(node)都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。如果前面所说的 numbers 键创建的列表对象使用的不是 ziplist 编码，而是 linkedlist 编码。</p><p>注意: <code>linkedlist</code> 编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现，字符串对象是 Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希对象的底层实现可以是 <code>ziplist</code> 或者 <code>hashtable</code>。</p><p><code>ziplist</code> 中的哈希对象是按照key1、value1、key2、value2这样的顺序存放来存储的。当对象数目不多且内容不大时，这种方式效率是很高的。当 Hash 对象同时满足以下两个条件时，使用 <code>ziplist</code>：</p><ul><li>Hash 对象保存的所有键值对和值的字符串长度小于 64 字节</li><li>Hash 对象保存的键值对数量小于 512 个</li></ul><p>hashtable 的是由 dict 这个结构来实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合对象的编码可以是<code>intset</code> 或者<code> hashtable</code>。</p><p>Set 的底层存储 <code>intset</code> 和 <code>hashtable</code> 是存在编码转换的，当 <code>Set</code> 对象同时满足以下两个条件时，<code>Set</code> 列表使用 <code>intset</code> 进行存储，否则使用 <code>hashtable</code>:</p><ul><li>结合对象保存的所有元素都是<strong>整数值</strong></li><li>集合对象保存的元素数量不超过 512 个</li></ul><p><code>intset</code> 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><p><code>hashtable</code> 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素,而字典的值则全部被设置为NULL。</p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code>。</p><p>满足下面条件的时候，使用 <code>ziplist</code>，其它时候使用 <code>skiplist</code>:</p><ul><li>有序集合保存的所有元素长度小于 64 字节</li><li>有序集合保存的元素数量小于 128 个</li></ul><p><code>ziplist</code> 编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，而第二个元素则保存元素的分值(score)。</p><p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现，一个zset结构同时包含一个 dict 和一个 skiplist。dict 保存的 key-value，key 为元素，value 为分值。skiplist 保存有序的元素列表，每个元素列表包括元素和分值。两种数据结构下的元素指向相同的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">/** 字典，键为成员，值为分值</span></span><br><span class="line"><span class="comment">    用于支持 O(1) 复杂度的按成员取分值操作 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">/**跳跃表，按分值排序成员</span></span><br><span class="line"><span class="comment">    用于支持平均复杂度为 O(log N) 的按分值定位成员操作</span></span><br><span class="line"><span class="comment">    以及范围操作 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>因为C语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个 <strong>引用计数( reference counting)</strong> 技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。每个对象的引用计数信息由 redisobject 结构的 <code>refcount</code> 属性记录:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;</span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1；</li><li>当对象被一个新程序使用时，它的引用计数值会被增；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>对于同一个对象，为了节约内存，直接指向现有的内存的方法肯定是节约内存。在Redis中，指向同一个对象需要以下两步：</p><ul><li>将数据库键的值指针指向一个现有的值对象</li><li>将被共享的值对象的引用计数增一</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336601f265da598e13f917">Redis 深度历险：核心原理与应用实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列 —— LinkedBlockingDeque 和 LinkedBlockingQueue</title>
      <link href="java-queue-LinkedBlockingDeque/"/>
      <url>java-queue-LinkedBlockingDeque/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。 </p></blockquote><p><code>LinkedBlockingDeque</code> 则是一个由链表组成的双向阻塞队列。可以从对头、对尾两端插入和移除元素，同样意味着 <code>LinkedBlockingDeque</code> 支持FIFO、FILO两种操作方式。<code>LinkedBlockingDeque</code> 是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。</p><p>LinkedBlockingQueue 是一个由链表组成的，只能从一端出一端入，支持 FIFO，并通过 ReentrantLock 和 两个Condition实现。</p><h1 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h1><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>通过上面的Lock可以看出，LinkedBlockingDeque底层实现机制与LinkedBlockingQueue一样，依然是通过互斥锁ReentrantLock 来实现，notEmpty 、notFull 两个Condition做协调生产者、消费者问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDeque</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">// 双向链表的表头</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">// 双向链表的表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;<span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><p>LinkedBlockingDeque 的add、put、offer、take、peek、poll系列方法都是通过调用XXXFirst，XXXLast方法。因此只需要了解putFirst、putLast、pollFirst、pollLast。</p><h3 id="putFirst"><a href="#putFirst" class="headerlink" title="putFirst"></a>putFirst</h3><p>putFirst(E e) :将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。<br>先获取锁，然后调用linkFirst方法入列，最后释放锁。如果队列是满的则在notFull上面等待。linkFirst设置Node为对头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);<span class="comment">//生成一个新节点</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!linkFirst(node))<span class="comment">//调用linkFirst添加节点</span></span><br><span class="line">                notFull.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">linkFirst主要是设置node节点队列的列头节点，成功返回<span class="keyword">true</span>，如果队列满了返回<span class="keyword">false</span>。整个过程还是比较简单的。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node&lt;E&gt; f = first;<span class="comment">//首节点</span></span><br><span class="line">        node.next = f;<span class="comment">// 新节点的next指向原first</span></span><br><span class="line">        first = node;<span class="comment">// 设置node为新的first</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 没有尾节点，设置node为尾节点</span></span><br><span class="line">            last = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 有尾节点，那就将之前first的pre指向新增node</span></span><br><span class="line">            f.prev = node;</span><br><span class="line">        ++count;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="putLast"><a href="#putLast" class="headerlink" title="putLast"></a>putLast</h3><p>putLast(E e) :将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用linkLast将节点Node链接到队列尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!linkLast(node))</span><br><span class="line">            notFull.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; l = last;<span class="comment">//获取尾节点</span></span><br><span class="line">    node.prev = l; <span class="comment">// 将Node的前驱指向原本的last</span></span><br><span class="line">    last = node;<span class="comment">// 将node设置为last</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 首节点为null，则设置node为first</span></span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//非null，说明之前的last有值，就将之前的last的next指向node</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst"></a>pollFirst</h3><p>pollFirst()：获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast"></a>pollLast</h3><p>pollLast():获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unlinkLast();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; p = l.prev;</span><br><span class="line">    E item = l.item;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = l; <span class="comment">// help GC</span></span><br><span class="line">    last = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这是一个只能一端出一端入的单向队列结构，具有 FIFO 特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要 node节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 边界限制，否则是Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用AtomicInteger 来记录数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**链表头结点*/</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**链表last节点*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**take 锁*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待take的节点序列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** put锁*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**put等待队列*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>put操作是向队列尾部插入一个元素，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//插入的元素不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;<span class="comment">//获取put锁</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;<span class="comment">//获取count</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列满了，使用notFull阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();<span class="comment">//CAS增加count</span></span><br><span class="line">        <span class="comment">//如果队列有空间了，notFull唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果队列size为0，也要</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入队操作，对尾插入元素</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();<span class="comment">//用于signal，notEmpty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h2><p>take操作是从对了中弹出一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;<span class="comment">//设定一个记录变量</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;<span class="comment">//获取count</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;<span class="comment">//获取take锁</span></span><br><span class="line">    takeLock.lockInterruptibly();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列中没有元素，就阻塞性等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//队列还有元素，唤醒队列</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//释放锁</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();<span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC 指向自己，帮助GC回收</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;<span class="comment">//从队列头部弹出元素</span></span><br><span class="line">    first.item = <span class="keyword">null</span>;<span class="comment">//将head.item设为null</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 阻塞队列 </tag>
            
            <tag> LinkedBlockingDeque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列 —— DelayQueue</title>
      <link href="java-queue-DelayQueue/"/>
      <url>java-queue-DelayQueue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。、队列元素会按照最终执行时间在队列中进行排序。当队列中的元素到达延迟时间时才会被取出。<br>主要作用：</p><ul><li>缓存：清掉缓存中超时的缓存数据</li><li>任务超时处理</li></ul><p>DelayQueue实现的关键主要有如下几个：</p><ul><li>可重入锁ReentrantLock</li><li>用于阻塞和通知的Condition对象</li><li>根据Delay时间排序的优先级队列：PriorityQueue</li><li>用于优化阻塞通知的线程元素leader</li></ul><h2 id="Delayed"><a href="#Delayed" class="headerlink" title="Delayed"></a>Delayed</h2><p>Delayed接口是用来标记那些应该在给定延迟时间之后执行的对象，它定义了一个long getDelay(TimeUnit unit)方法，该方法返回与此对象相关的的剩余时间。同时实现该接口的对象必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。<br>先看下实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义该元素及其属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Long delayTime;</span><br><span class="line">    <span class="keyword">public</span> TimeUnit delayTimeUnit;</span><br><span class="line">    <span class="keyword">public</span> Long executeTime;<span class="comment">//ms</span></span><br><span class="line"></span><br><span class="line">    DelayTask(String name, <span class="keyword">long</span> delayTime, TimeUnit delayTimeUnit) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">        <span class="keyword">this</span>.delayTimeUnit = delayTimeUnit;</span><br><span class="line">        <span class="keyword">this</span>.executeTime = System.currentTimeMillis() + delayTimeUnit.toMillis(delayTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getDelay方法的作用即是计算当前时间到执行时间之间还有多长时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(executeTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//compareTo方法的作用即是判断队列中元素的顺序谁前谁后。当前元素比队列元素后执行时，返回一个正数，比它先执行时返回一个负数，否则返回0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 可重入锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** 支持优先级的BlockingQueue */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line">     <span class="comment">/** 用于优化阻塞 */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/** Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 向 PriorityQueue中插入元素</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">// 如果当前元素的对首元素（优先级最高），leader设置为空，唤醒所有等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 对首元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)<span class="comment">// 对首为空，阻塞，等待off()操作唤醒</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 获取对首元素的超时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)<span class="comment">// &lt;=0 表示已过期，出对，return</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// leader != null 证明有其他线程在操作，阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则将leader 设置为当前线程，独占</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 超时阻塞</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                         <span class="comment">// 释放leader</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒阻塞线程</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>DelayQueue</code> 的入队、出对过程和其他的阻塞队列没有很大区别，无非是在出对的时候增加了一个到期时间的判断。同时通过leader来减少不必要阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 阻塞队列 </tag>
            
            <tag> DelayQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列 —— PriorityBlockingQueue</title>
      <link href="java-queue-PriorityBlockingQueue/"/>
      <url>java-queue-PriorityBlockingQueue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。   </p></blockquote><p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。在Thread中，我们可以通过 <code>setPriority(int newPriority)</code> 来设置优先级，线程优先级高的线程先执行，优先级低的后执行。 <code>PriorityBlockingQueue</code> 默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。<br><code>PriorityBlockingQueue</code>底层是二叉堆构成实现的，下面先介绍一些二叉堆知识点。</p><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/9c4b230d24565454573b0e58cf7fce8d.jpg"></p><p>二叉堆是一种特殊的堆，就结构性而言就是完全二叉树或者是近似完全二叉树，满足树结构性和堆序性。树机构特性就是完全二叉树应该有的结构，堆序性则是：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。</p><h2 id="队列结构定义"><a href="#队列结构定义" class="headerlink" title="队列结构定义"></a>队列结构定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5595510919245408276L</span>;</span><br><span class="line">    <span class="comment">//默认初始化大小11</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//定义列表最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//二叉堆数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//队列个数</span></span><br><span class="line">    <span class="comment">// 比较器，如果为空，则为自然顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>PriorityBlockingQueue是无界的，所以不可能会阻塞。内部调用offer(E e)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        offer(e); <span class="comment">// never need to block</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">int</span> n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">        <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">            <span class="comment">// 根据比较器是否为null，做不同的处理</span></span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            size = n + <span class="number">1</span>;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用自然排序，调用siftUpComparable方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = array[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当比较器不为null时，采用所指定的比较器，调用siftUpUsingComparator方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            Object e = array[parent];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>扩容：tryGrow</p><figure class="highlight java"><figcaption><span>private void tryGrow(Object[] array, int oldCap) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) : <span class="comment">// grow faster if small</span></span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><p>PriorityBlockingQueue提供put()、add()、offer()方法向队列中加入元素。我们这里从put()入手：put(E e) ：将指定元素插入此优先级队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Object[] array = queue;</span><br><span class="line">         E result = (E) array[<span class="number">0</span>];</span><br><span class="line">         E x = (E) array[n];</span><br><span class="line">         array[n] = <span class="keyword">null</span>;</span><br><span class="line">         Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">         <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">             siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">         size = n;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">         <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// loop while a non-leaf</span></span><br><span class="line">         <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">             <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">             Object c = array[child];</span><br><span class="line">             <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                 ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                 c = array[child = right];</span><br><span class="line">             <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             array[k] = c;</span><br><span class="line">             k = child;</span><br><span class="line">         &#125;</span><br><span class="line">         array[k] = key;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">             <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">             Object c = array[child];</span><br><span class="line">             <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                 c = array[child = right];</span><br><span class="line">             <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             array[k] = c;</span><br><span class="line">             k = child;</span><br><span class="line">         &#125;</span><br><span class="line">         array[k] = x;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 阻塞队列 </tag>
            
            <tag> PriorityBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列 —— ArrayBlockingQueue</title>
      <link href="java-queue-ArrayBlockingQueue/"/>
      <url>java-queue-ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。   </p></blockquote><p><code>ArrayBlockingQueue</code> 是一个数组实现的有界阻塞队列，采用FIFO算法对队列元素进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line">    <span class="comment">//一个定长数组，维护ArrayBlockingQueue的元素</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">//为ArrayBlockingQueue对首位置</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">//ArrayBlockingQueue对尾位置</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//重入锁，出列入列都必须获取该锁，两个步骤公用一个锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">//出列条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">//入列条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。AbstractQueue提供了对queue操作的骨干实现。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。<br>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。</p><h1 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h1><h2 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h2><p>add(E e)调用父类AbstractQueue接口，如果添加成功，返回true，否则抛出 <code>IllegalStateException(&quot;Queue full&quot;)</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a>offer(E e)</h2><p>add方法最后调用的还是offer进行添加元素的。先判断添加的节点是否为null，然后获取lock，如果队列已经满了，返回false，否则调用enqueue添加元素，最后释放lock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);<span class="comment">//检查添加的节点是否是null</span></span><br><span class="line">    <span class="comment">//获取lock</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h1><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dequeue</code> 方法主要是从列头（takeIndex 位置）取出元素，同时如果迭代器itrs不为null，则需要维护下该迭代器。最后调用notFull.signal()唤醒入列线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 阻塞队列 </tag>
            
            <tag> ArrayBlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发容器 —— ConcurrentLinkedQueue</title>
      <link href="java-queue-ConcurrentLinkedQueue/"/>
      <url>java-queue-ConcurrentLinkedQueue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>对于实现线程安全队列，现在有两种方式：1、使用阻塞算法；2、使用非阻塞算法。使用阻塞算法的队列是锁的应用。非阻塞则是CAS算法的应用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CoucurrentLinkedQueue是一个基于链接节点的无界线程安全队列，采用 FIFO 对节点排序。CoucurrentLinkedQueue是一个非阻塞队列。<br>CoucurrentLinkedQueue规定了如下几个不变性：</p><ul><li>在入队的最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>对于要删除的节点，不是直接将其设置为null，而是先将其item域设置为null（迭代器会跳过item为null的节点）</li><li>允许head和tail更新滞后。这是什么意思呢？意思就说是head、tail不总是指向第一个元素和最后一个元素。</li></ul><h2 id="CoucurrentLinkedQueue结构"><a href="#CoucurrentLinkedQueue结构" class="headerlink" title="CoucurrentLinkedQueue结构"></a>CoucurrentLinkedQueue结构</h2><p><code>CoucurrentLinkedQueue</code> 继承 <code>AbstractQueue</code>。CoucurrentLinkedQueue 是由head节点和tair节点组成，每个节点（Node）又节点元素（item）和主项下一个节点的（next）组成。默认情况下head节点存储的元素为空，tair节点等于head节点。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/414e8693eda05a70cd2ea034bbcc99bc.jpg"></p><p>CoucurrentLinkedQueue主要方法：</p><ul><li>add/offer：add是调用offer方法的，指定元素插入到队列尾部</li><li>poll：拉取头部元素</li><li>remove：删除元素</li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**节点元素*/</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">/**初始化，获得item和next的偏移量，为后期的CAS做准备*/</span></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;<span class="comment">//偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;<span class="comment">//下个元素偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll（出队）"><a href="#poll（出队）" class="headerlink" title="poll（出队）"></a>poll（出队）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:<span class="comment">//没搞懂这个是干啥子的？？？</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">// item 不为null，则将item 设置为null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// p != head 则更新head</span></span><br><span class="line">                <span class="comment">// p.next != null，则将head更新为p.next ,否则更新为p</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p.next == null 队列为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当一个线程在poll的时候，另一个线程已经把当前的p从队列中删除——将p.next = p，p已经被移除不能继续，需要重新开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>updateHead()</code> ，该方法用于CAS更新head节点，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offer-入队"><a href="#offer-入队" class="headerlink" title="offer(入队)"></a>offer(入队)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**检查添加的元素是否是null*/</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">/**创建新的节点*/</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">//q==null，表示节点p是最后一个节点了，在尾部添加节点</span></span><br><span class="line">        <span class="comment">// 如果插入失败，则表示其他线程已经修改了p的指向</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// casNext：t节点的next指向当前节点</span></span><br><span class="line">            <span class="comment">// casTail：设置tail 尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// node 加入节点后会导致tail距离最后一个节点相差大于一个，需要更新tail</span></span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    casTail(t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// p == q 代表着该节点已经被删除了</span></span><br><span class="line">            <span class="comment">// 由于多线程的原因，我们offer()的时候也会poll()，如果offer()的时候正好该节点已经poll()了</span></span><br><span class="line">            <span class="comment">// 那么在poll()方法中的updateHead()方法会将head指向当前的q，而把p.next指向自己，即：p.next == p</span></span><br><span class="line">            <span class="comment">// 这样就会导致tail节点滞后head（tail位于head的前面），则需要重新设置p</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">            <span class="comment">// tail并没有指向尾节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// tail已经不是最后一个节点，将p指向最后一个节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/07fdafe7940045e5c0af5e748fdd763a.jpg"></p><ul><li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li><li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/a5a5a4e13ecd67ab453aa2af7c761f1b.jpg"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></li><li><a href="http://cmsblogs.com/?p=2353">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentLinkedQueue</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 非阻塞队列 </tag>
            
            <tag> ConcurrentLinkedQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="mysql-index/"/>
      <url>mysql-index/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎指正。</p></blockquote><p>索引的一些基本认知：</p><ul><li>索引可以加快数据库的检索速度</li><li>表经常进行INSERT/UPDATE/DELETE操作就不要建立索引了，换言之：索引会降低插入、删除、修改等维护任务的速度。</li><li>索引需要占物理和数据空间。</li><li>了解过索引的最左匹配原则</li><li>知道索引的分类：聚集索引和非聚集索引</li><li>MySQL 支持Hash索引和B+树索引两种</li></ul><h1 id="索引的基础知识"><a href="#索引的基础知识" class="headerlink" title="索引的基础知识"></a>索引的基础知识</h1><p>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间 (因为索引也要随之变动)。<br>创建索引可以大大提高系统的性能。</p><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，</li><li>使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li></ul><h2 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h2><p>创建索引的一些原则：</p><ul><li>较频繁的作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合创建索引（数据库会将索引数据根据算法排序，数据量大之后重新排序会占用过多资源）</li><li>用于索引的最好的备选数据列是那些出现在WHERE子句、join子句、ORDER BY或GROUP BY子句中的列。</li></ul><h2 id="MySQL-存储结构"><a href="#MySQL-存储结构" class="headerlink" title="MySQL 存储结构"></a>MySQL 存储结构</h2><p>MySQL的基本存储结构是<strong>页</strong>，一页的大小一般是<code>16KB</code>。</p><ul><li>各个数据页可以组成一个<strong>双向链表</strong></li><li>每个数据页中的记录可以组成单向链表</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/f3ea17bcd1d487bed8fa85bc599fde88.jpg"></p><h2 id="InnoDB-表"><a href="#InnoDB-表" class="headerlink" title="InnoDB 表"></a>InnoDB 表</h2><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的。在InnoDB存储引擎表中，每张表都有个主键，如果在创建表的时没有显式地定义主键，InnoDB存储引擎会按照下面选择或者创建主键：</p><ul><li>首先判断表中是否有非空的<strong>唯一索引</strong>，如果有，则该列即为主键（如果有多个的时候，选择第一个定义的唯一索引）；</li><li>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。</li></ul><p><strong>注意：</strong> 在建表的时候，最好还是指定主键，而且最好使用自增，而不是UUID这种作为主键，因为UUID一般都是无序的，在插入新的记录的时候，可能增加额外的开销。B+树为了维护索引的有序性，在插入新值得实惠需要做必要的维护。比如在某页数据中间插入某条数据，这时候就需要移动后面的数据，空出位置。如果碰到这一页数据满了，还需要申请新的数据页，挪动部分数据过去，这种过程称为页的分裂，这种情况就很影响性能。</p><h2 id="索引提高检索速度"><a href="#索引提高检索速度" class="headerlink" title="索引提高检索速度"></a>索引提高检索速度</h2><p>索引用于快速查找具有特定列值的行。如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。表越大，成本越高。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间寻找的位置，而无需查看所有数据。这比按顺序读取每一行要快得多。 </p><h3 id="如果没有索引"><a href="#如果没有索引" class="headerlink" title="如果没有索引"></a>如果没有索引</h3><h4 id="在一个页里查找"><a href="#在一个页里查找" class="headerlink" title="在一个页里查找"></a>在一个页里查找</h4><p>如果表中数据现在比较少，都存放在一个页里，在查找的时候按照不同省市条件查找：</p><ul><li>主键：在 <strong>页目录</strong> 中使用二分法快速定位到相应的槽，然后在遍历该槽对应分组即可查找到数据</li><li>其他列：只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件</li></ul><h4 id="多页中查找"><a href="#多页中查找" class="headerlink" title="多页中查找"></a>多页中查找</h4><ul><li>先定位到数据所在的页；</li><li>在从页中查找相应的数据。</li></ul><h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><p>将无序的数据变成有序(相对)。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/bdef6bdea768f141655ca0dcc49e676d.jpg"></p><h1 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h1><h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><p>B-Tree 是一棵多叉树，在非叶子节点中存储了数据。</p><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h2><p>该索引使用 B+Tree 数据结构来存储数据，B+Tree 是InnoDB存储引擎默认的索引结构。</p><p>B+ Tree 是 B-Tree 的变种，通常意味着所有数据值都是按照顺序存储的，并且每一个叶子页到根的距离相同。存储引擎不需要进行全表扫描来获取需要的数据，只需要从索引节点进行搜索。索引的叶子节点之间通过索引互相连接。</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from table <span class="built_in">where</span> name = <span class="string">&#x27;Peter&#x27;</span></span><br></pre></td></tr></table></figure><p>MySQL先会计算 ‘Peter’ 的哈希值，并使用该值寻找对应的记录指针。</p><p>哈希索引的限制：</p><ul><li>不能使用索引中的值来避免读取行</li><li>不能按照索引顺序存储，所以无法用于排序</li><li>不支持部分索引列匹配查询</li><li>只支持等值查询，包括 =、in()、&lt;=&gt;</li></ul><h2 id="InnoDB-为什么选择-B-Tree-作为默认索引结构"><a href="#InnoDB-为什么选择-B-Tree-作为默认索引结构" class="headerlink" title="InnoDB 为什么选择 B+Tree 作为默认索引结构"></a>InnoDB 为什么选择 B+Tree 作为默认索引结构</h2><ul><li>哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；</li><li>B-Tree 能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+Tree 的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O。</li></ul><h2 id="常见索引类型"><a href="#常见索引类型" class="headerlink" title="常见索引类型"></a>常见索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引指主索引文件和数据文件为同一份文件，聚簇索引主要用在 <code>InnoDB</code> 存储引擎中。在该索引实现方式中，<code>B+ Tree</code> 的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引。一张表也不可能有两个地方存储数据，所以一张表只能有一个聚簇索引。</p><p>InnoDB 表中聚簇索引的索引列就是主键，所以聚簇索引也叫主键索引。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引指的是 <code>B+Tree</code> 的叶节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引的key一定是唯一的。主要用于MyIsAM存储引擎中。</p><p>非聚簇索引比聚簇索引多了一次读取数据的IO操作，索引查找性能上会差。</p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>对于 InnoDB 表，在非主键的其他列上建的索引就是二级索引。</p><h3 id="按照字段列分类"><a href="#按照字段列分类" class="headerlink" title="按照字段列分类"></a>按照字段列分类</h3><p>MySQL的索引分为单列索引（主键索引，唯一索引，普通索引）和组合索引（或叫联合索引）</p><ul><li>单列索引:一个索引只包含一个列，一个表可以有多个单列索引</li><li>组合索引:一个组合索引包含两个或两个以上的列。从左到右</li></ul><h1 id="索引使用的基本常识"><a href="#索引使用的基本常识" class="headerlink" title="索引使用的基本常识"></a>索引使用的基本常识</h1><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>使用索引时的一些注意点：</p><ul><li>符合最左原则</li><li>如果是or，不走索引</li><li>数据区分度不大的字段不宜使用索引</li><li>MySQL从左到右的使用索引中的字段，一个查询可以使用索引中的一部分，但只能是最左侧部分。例如索引是key index(a,b，c)，可以支持a|a，b|a，b，c 3种组合进行查询，但不支持b，c进行查找。当最左侧字段是常量引用时，索引就十分有效。  </li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机 I/O 变为顺序 I/O</li></ul><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><ul><li>索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。</li><li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (&gt;、&lt;、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。</li><li>因此，列的排列顺序决定了可命中索引的列数。</li></ul><p>比如，现在有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c&gt;3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)。</p><h2 id="回表和覆盖索引"><a href="#回表和覆盖索引" class="headerlink" title="回表和覆盖索引"></a>回表和覆盖索引</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>在InnoDB中，对于普通索引的查询，是无法直接定位行记录的。普通索引需要先定位到对象的主键，然后通过主键去查询数据。这种查询相对于聚簇索引来说，多了一次查询。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引是一种避免回表查询的优化策略。具体的做法是将<strong>查询的数据作为索引列建立普通索引</strong>，这样就可以直接返回索引中的数据，而不需要通过聚簇索引去定位行记录，避免回表的发生。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>最左前缀可以用于在索引中定位记录。现在我们有一个联合索引(name, age)，现在需要查询下面这个SQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table <span class="built_in">where</span> name like <span class="string">&quot;张%&quot;</span> and age = 10</span><br></pre></td></tr></table></figure><p>使用前缀索引规则是，只能用“张”，找到第一个满足条件的记录，然后在一个个回表查询数据行。MySQL 引入索引的下推优化(index condition pushdown)，可以在索引遍历中，对索引包含的字段现做判断，直接过滤掉不满足的记录，减少回表次数。如下图所示，第一个图是吴索引下推的流程，第二张图，则是进行了索引下推优化，减少了回表次数。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200416213132.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200416213146.png"></p><h2 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h2><p>对于注意点最后一点，在MySQL中，对于索引会自动优化条件的顺序，方便匹配尽可能对的索引列。可以看下面一个实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `card` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;身份证&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机&#x27;</span>,</span><br><span class="line">  `province_id` <span class="type">bigint</span>(<span class="number">12</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;省份城市&#x27;</span>,</span><br><span class="line">  `city_id` <span class="type">bigint</span>(<span class="number">12</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;城市ID&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;状态, 1:启用,0:删除&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_user` (`name`,`password`,`card`,`phone`,`age`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `idx_age` (`age`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  FULLTEXT KEY `ft_name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如上面创建一张表，并创建索引 <code>idx_user</code>。<br>1、从上面的一个例子，我们可以看出，虽然我们查询条件并没有按照索引里面的顺序，但是查询还是走的是索引。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/5588441b2b01cbb195c0ced1e2befe41.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/caa7c87b03ad3ed466176f31d0ec26c0.jpg"></p><p>2、这个例子看出，下面这个查询没有走索引。可以注意点最后一点对照着看。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/ab33d1e09a4c0bfe6b94ce2b023d5711.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/1b529270d16fe8934d39267f534aca06.jpg"></p><h3 id="关于IN是否走索引"><a href="#关于IN是否走索引" class="headerlink" title="关于IN是否走索引"></a>关于IN是否走索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> age <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">19</span>)</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200416213854.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://mp.weixin.qq.com/s/GYRuFhty5gDLAmDXw7AluA">InnoDB数据页结构</a></li><li><a href="https://mp.weixin.qq.com/s/9gloKNtZrYlGsBODCckQrw">MySQL的索引</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 对象地址问题</title>
      <link href="problem-java-memory-address/"/>
      <url>problem-java-memory-address/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>上周在写代码的时候，碰到一个问题：代码结构如下图，前端传过来一个对象，我在service方法中会通过不同方法，每个方法中都有相对于的修改，然后插入数据库。但是发现在方法A中对传值进行修改，其中修改后的值，使用了静态变量保存，但是发现前面的变量的值编程了C中最后的变量。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/7ab24c69ffcc104d4ab2ff7d79264ae0.jpg">  </p><p>后来分析了下，通过 <code>=</code> 去进行赋值，只是把变量的地址指向了对象，然后，修改对象，变量重新指向对象，最后发现变量也跟着对象改变了。<br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/24a54e8121f8d7969fe79f729e07b099.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/4670c9f5e8d1dc570bc86fa7460ae0e3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象地址 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 MongoDB</title>
      <link href="spring-boot-monogdb/"/>
      <url>spring-boot-monogdb/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><p>MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用MongoDB来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。    </p><p>MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性。   </p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。   </p><p>传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。   </p><p>MongoDB中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB文档与JSON对象类似。字段的值有可能包括其它文档、数组以及文档数组。MongoDB支持OS X、Linux及Windows等操作系统，并提供了Python，PHP，Ruby，Java及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。   </p><p>MongoDB的适合对大量或者无固定格式的数据进行存储，比如：日志、缓存等。对事物支持较弱，不适用复杂的多文档（多表）的级联查询。文中演示mongodb版本为3.4</p><h2 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h2><p>对于MongoDB的安装，可以选择官网下载，也可以通过docker安装等。个人感觉直接从docker上面拉取镜像，启动比较方便。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search mongodb</span><br><span class="line">docker pull &lt;镜像&gt;</span><br><span class="line">docker images</span><br><span class="line">docker run -p 27017:27017 -td &lt;镜像&gt;</span><br></pre></td></tr></table></figure><p>进入MongoDB控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 25d9e7028145(镜像ID) mongo admin(数据库)</span><br></pre></td></tr></table></figure><p>对于如何添加管理员用户，<a href="https://www.jianshu.com/p/3a8c1904e807">Docker部署安装MongoDB</a>，这篇博客上面介绍了了。</p><h2 id="Spring-Boot-MongoDB"><a href="#Spring-Boot-MongoDB" class="headerlink" title="Spring Boot + MongoDB"></a>Spring Boot + MongoDB</h2><h3 id="添加jar"><a href="#添加jar" class="headerlink" title="添加jar"></a>添加jar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="添加连接数据库信息"><a href="#添加连接数据库信息" class="headerlink" title="添加连接数据库信息"></a>添加连接数据库信息</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/7c919424bf0479e5907b2b7db188a9fd.jpg"></p><p>对于上面这种直接连接数据库的操作，本人是没有连接成功，从提示错误中看到，虽然连接信息是服务器上面的，但是报错一直提示本地MongoDB连接不上，最后选择了配置数据库连接。如下图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/f13ee8271d12b9e38675360f487a7421.jpg"></p><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/d194d72ff8c67a035e7ca3b0691e70c9.jpg"></p><h3 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/b01c0327bf355188524435ceb884ab20.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在测试类中测试，最后在数据库中有数据插入。选择<code>spring-boot-starter-data-mongodb</code>这个jar，已经支持对 <code>MongoDB</code>的增删改查的基本数据库操作。<br>对于MongoDB来说，如果没有相对于的数据库，则会创建数据库；如果没有表的话，则会创建新的表。这不像MySQL一样，需要自己先手动创建相应的数据库和表。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务管理</title>
      <link href="spring-transaction/"/>
      <url>spring-transaction/</url>
      
        <content type="html"><![CDATA[<p>在项目中，事务可以有效的防止在程序出错时，对于数据的错误修改，回滚到修改之前。<br>spring事务和数据库事务一样，都有四个特性（ACID）:</p><ul><li><p>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏；</p></li><li><p>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏；</p></li><li><p>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中；</p></li></ul><h1 id="事务的传播性"><a href="#事务的传播性" class="headerlink" title="事务的传播性"></a>事务的传播性</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html">官方文档解释</a></p><ul><li>PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。（比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_NESTED，那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的子事务并设置savepoint，等待ServiceB.methodB的事务完成以后，他才继续执行。）</li><li>PROPAGATION_REQUIRED：支持当前事务，如果不存在则创建新事务。（方法B已经运行在方法A的事务内部，就不再起新的事务，直接加入方法A）。</li><li>RROPAGATION_REQUIRES_NEW：创建一个新事务，并暂停当前事务（如果存在）。（方法A所在的事务就会挂起，方法B会起一个新的事务，方法B新起的事务不依赖方法A的事务，等待方法B的事务完成以后，方法A才继续执行，如果方法B执行没有异常，方法A抛出异常，方法B的操作不会被回滚，方法A中除了方法B外，会回滚数据）。</li><li>PROPAGATION_SUPPORTS：如果当前存在事务中，即以事务的形式运行；如果不存在则以非事务方式执行。（方法B看到自己已经运行在方法A的事务内部，就不再起新的事务，直接加入方法A）</li><li>PROPAGATION_NOT_SUPPORTED：支持当前事务，如果不存在则创建新事务。（方法A所在的事务就会挂起，而方法B以非事务的状态运行完，再继续方法A的事务）。</li><li>PROPAGATION_MANDATORY：支持当前事务，如果有，使用当前事务；如果不存在则抛出异常。</li><li>PROPAGATION_NEVER：如果事务存在，则以非事务方式执行，抛出异常。（假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。）</li></ul><p>下面给出一张图，对上面的事务传播性，做出总结：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200430092429.png"></p><h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><p>事务并发可能引起的问题：</p><ul><li><p>脏读：脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的；</p></li><li><p>不可重复读：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新；</p></li><li><p>幻读：幻读是由“可重复读”隔离级别导致的事务问题。事务T1查询某条数据，发现数据库没有数据，同时事务T2也查询这条数据，也同样没查询到。这时T1就将数据插入到了数据，由于可重复读的隔离级别，所以T2还是查询不到这条数据，然后T2插入了同样的数据，然后提示说数据以及存在，但是在事务T2中有查询不到这条数据，就像出现幻觉一样。</p></li></ul><p>Isolation是事务自带事务隔离级别， 隔离级别是指若干个并发的事务之间的隔离程度。</p><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/annotation/Isolation.html">官方文档解释</a></p><ul><li><p>DEFAULT（默认隔离级别）：使用基础数据存储的默认隔离级别；</p></li><li><p>READ_UNCOMMITTED（读未提交）：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。一个常量，表示可以发生<strong>脏读，不可重复读和幻像读</strong>；</p></li><li><p>READ_COMMITTED（读已提交）：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。可以发生<strong>不可重复的读取和幻像读取</strong>；</p></li><li><p>REPEATABLE_READ（重复读取）：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。一个常量，表示防止脏读和不可重复读; 可以发生<strong>幻取</strong>；</p></li><li><p>SERIALIZABLE（串行化）：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p></li></ul><p>下面表格是对上面的事务隔离级别对并发问题解决情况：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191116141347.png"></p><h1 id="spring支持编程式事务管理和声明式事务管理两种方式。"><a href="#spring支持编程式事务管理和声明式事务管理两种方式。" class="headerlink" title="spring支持编程式事务管理和声明式事务管理两种方式。"></a>spring支持编程式事务管理和声明式事务管理两种方式。</h1><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p>编程式事务管理使用 TransactionTemplate 或者直接使用底层的 PlatformTransactionManager。对于编程式事务管理，spring 推荐使用 TransactionTemplate。</p><h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p> 声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。<br>一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。</p><p><strong>注意点</strong>：声明式事务，主要依赖的是Spring Aop，基于动态代理机制，就会出现事务的失效。<a href="https://jlj98.top/Java-proxy-cglib/">Java 动态代理机制</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问：执行某操作，前50次成功，第51次失败a全部回滚，b前50次提交第51次失败抛出异常，ab场景分别如何设置Spring（传播性）？<br>答：a设置为 <code>PROPAGATION_REQUIRED</code>，b设置为 <code>PROPAGATION_REQUIRES_NEW</code></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://blog.csdn.net/lovesomnus/article/details/69942697">Spring事务的传播特性</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Aop</title>
      <link href="spring-aop/"/>
      <url>spring-aop/</url>
      
        <content type="html"><![CDATA[<p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理，<a href="https://jlj98.top/java-proxy-cglib/">关于Java代理</a>。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li>增强（Adivce）</li><li>切点（Pointcut)</li><li>连接点（Join point)</li><li>切面（Aspect）</li><li>引入（Introduction）</li><li>织入（Weaving）</li></ul><p>Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。<br>aop开发时，其中需要程序员参与的只有 3 个部分：</p><ul><li>定义普通业务组件。</li><li>定义切入点，一个切入点可能横切多个业务组件。</li><li>定义增强处理，增强处理就是在 AOP 框架为普通业务组件织入的处理动作。</li></ul><h1 id="什么是Spring-AOP"><a href="#什么是Spring-AOP" class="headerlink" title="什么是Spring AOP"></a>什么是Spring AOP</h1><p>Spring AOP面向切面编程，将日志、事务等相对独立且重复的功能抽取出来，利用Spring的配置文件或者注解的形式将这些功能织入进去，提高了复用性。 </p><p>采用技术：AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 </p><p>Spring AOP 采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，Spring AOP提供了对JDK动态代理的支持以及CGLib的支持。前者是基于反射技术的实现，后者是基于继承的机制实现。Spring AOP默认使用AOP代理的标准JDK动态代理。这使得任何接口（或接口集）都可以被代理。Spring AOP也可以使用CGLIB代理。这是代理类而不是接口所必需的。默认情况下，如果业务对象未实现接口，则使用CGLIB。由于优化的做法是编程接口而不是类，业务类通常实现一个或多个业务接口。</p><h1 id="业务中的一些切面"><a href="#业务中的一些切面" class="headerlink" title="业务中的一些切面"></a>业务中的一些切面</h1><ul><li>Filter过滤器：拦截web访问url地址。</li><li>Interceptor拦截器：拦截以 .action结尾的 url，拦截Action的访问。</li><li>Spring AOP拦截器：只能拦截Spring管理Bean的访问（业务层Service）</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop">Spring Aop 官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC 容器</title>
      <link href="spring-ioc/"/>
      <url>spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>Spring IoC容器：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。开发人员在开发过程中，把对象的创建和销毁交给了spring容器，在使用的时候，只需要向容器申请就好了。这样就是的程序实现了解耦。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/8d6283f75c7f5433f3a4c659f3e071bc.jpg"></p><h2 id="Spring-IOC容器和bean介绍"><a href="#Spring-IOC容器和bean介绍" class="headerlink" title="Spring IOC容器和bean介绍"></a>Spring IOC容器和bean介绍</h2><p>IoC也被称为依赖注入（DI）。它是一个过程，对象通过构造函数参数，工厂方法的参数或在工厂方法构造或返回后在对象实例上设置的属性来定义它们的依赖关系，即它们使用的其他对象。容器在创建bean时会注入这些依赖关系。这个过程基本上是相反的，因此名为Inversion of Control（IoC），通过使用类的直接构造或诸如Service Locator模式之类的机制来控制其依赖关系的实例化或位置的bean本身。   </p><p>在<code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。该 <code>BeanFactory</code>接口提供了一种能够管理任何类型对象的高级配置机制。 ApplicationContext 是BeanFactory 的一个子接口。它增加了与Spring的AOP功能更容易的集成; 消息资源处理（用于国际化），事件发布; 和特定于应用层的上下文（例如，WebApplicationContext 用于Web应用程序中）。</p><h2 id="Spring容器"><a href="#Spring容器" class="headerlink" title="Spring容器"></a>Spring容器</h2><p>Sping的容器可以分为两种类型</p><ul><li><p>BeanFactory：<code>org.springframework.beans.factory.BeanFactory</code> 接口是最简单的容器，提供了基本的 DI 支持。最常用的 BeanFactory 实现就是 XmlBeanFactory 类，它根据XML文件中的定义加载beans，该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p></li><li><p>ApplicationContext 应用上下文：<code>org.springframework.context.ApplicationContext</code> 基于BeanFactory之上构建，并提供面向应用的服务。该接口<code>org.springframework.context.ApplicationContext</code> 表示 Spring IoC 容器，并负责实例化，配置和组装上述bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指示信息。配置元数据用XML，Java注释或Java代码表示。它允许您表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p></li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/f9e0f42c943069b714ed8d7a1365b8a8.jpg"></p><p>在Spring框架中的核心组件只有三个：Core、Context 和 Bean。它们构建起了整个Spring的骨骼架构，没有它们就不可能有AOP、Web等特性功能。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/8d6283f75c7f5433f3a4c659f3e071bc.jpg"></p><p>如果说在三个核心中再选出一个核心，那就非Bean莫属了。可以说，Spring就是面向Bean的编程，Bean在Spring中才是真正的主角。   </p><p>Spring为何如此流行？你会发现Spring解决了一个非常关键的问题，它可以让你对对象之间的关系转而用配置文件来管理，或者注解，也就是它的依赖注入机制。   </p><p>而这个注入关系在一个叫Ioc的容器中管理。Ioc容器就是被Bean包裹的对象。Spring正是通过把对象包装在Bean中从而达到管理这些对象及做一些列额外操作的目的。</p><h2 id="BeanFactory-与-ApplacationContext-的区别"><a href="#BeanFactory-与-ApplacationContext-的区别" class="headerlink" title="BeanFactory 与 ApplacationContext 的区别"></a>BeanFactory 与 ApplacationContext 的区别</h2><p>IOC中最核心的接口是Beanfactory提供IOC的高级服务，而ApplicationContext是建立在BeanFactory基础之上提供抽象的面向应用的服务。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/7f5f53de33c9aeabf9d0def11c063598.jpg"></p><h2 id="spring依赖注入"><a href="#spring依赖注入" class="headerlink" title="spring依赖注入"></a>spring依赖注入</h2><ul><li>Setter方式注入（设值注入）</li><li>构造器方式注入</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#spring-core">Spring Framework</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&mid=2650071764&idx=2&sn=dfea9ad65640f19fe26530e06ebd9a9c&chksm=bedb39ba89acb0ac04f89083f98d530001c334d97733dfea1993a885c9786fb2223548940d0f&scene=21#wechat_redirect">Spring 思维导图，让 Spring 不再难懂（ioc 篇）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot maven 配置多环境部署</title>
      <link href="springboot-mvn-profileactive/"/>
      <url>springboot-mvn-profileactive/</url>
      
        <content type="html"><![CDATA[<p>在实际项目开发中，线上数据和开发测试的环境不可能是一样的，不然每次上线还要进行删除测试数据，而进行版本迭代的时候，开发人员可以之间操作线上用户数据进行开发，作为一个开发人员，你觉得这样合理吗？<br>针对上面的问题，在实际项目开发过程中，一般就会出现不同的开发环境，比如有开发环境，测试环境，线上环境。但是对于一些中小型公司来说，其实数据库、Redis什么的，只需要两套，一套是线上正式环境，一套开发测试环境。    </p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>对于SpringBoot来说，进行多环境开发配置，很简单的，看下面的:</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/2b18f9544ca290b926d49d254a3173f5.jpg"></p><p>通过修改配置文件的命名，在<em>application.yml</em>中选择自己需要加载那那个配置文件。并在相对于的配置文件中加入下面的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project:</span><br><span class="line">  name: production</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>  application.yml中的名字必须和你命名的配置问价后面部分相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 配置正式和测试库，分别是production/test</span></span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>对于启动jar包，选择不同的配置环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar &lt;jar包&gt; --spring.profiles.active=<span class="built_in">test</span>/production</span><br></pre></td></tr></table></figure><h2 id="使用maven来进行配置多环境部署"><a href="#使用maven来进行配置多环境部署" class="headerlink" title="使用maven来进行配置多环境部署"></a>使用maven来进行配置多环境部署</h2><p>下面是使用maven来配置不同的环境。 </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c8769e7b3ec4e075395c41032b6ff64e.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/ac08b67e485dcf2b25f384595885398e.jpg"></p><p>现在pom文件中添加自己需要的哪几种配置环境，别的配置文件和上面类似，只是在application.yml文件中不在需要手动去修改环境变量。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/fc4da9fbac9e7dbfd19406b19f2b20af.jpg"></p><p>这样只需要在打包的时候，通过下面的打包命令，来生成相对于的war/jar包就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -P(对应的环境的id，要把括号去掉且是紧挨着大写的P)</span><br><span class="line">比如：</span><br><span class="line">mvn clean package -Pproduction</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/tedburner/spring-boot-examples">GitHub项目</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存模型和内存结构</title>
      <link href="jmm-jvm/"/>
      <url>jmm-jvm/</url>
      
        <content type="html"><![CDATA[<p>之前有点傻傻的分不清内存模型和内存结构的区别，以为都是指的是JVM。直到前段时间在一篇博客上看到这两者的区别，才知道这两者指的是不同的东西。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>内存结构就是我们常说的JVM，比如，堆、栈等。这些就是Java的内存结构。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/5bce8da420efd10d81b348427057c660.jpg"></p><p>关于JVM可以看 <strong>深入理解Java虚拟机（周志明）</strong> 写的这本书。下面两篇博客是我看这本书的一些笔记：</p><ul><li><a href="https://jlj98.top/jvm-memory-area/">深入理解虚拟机-Java内存区域</a></li><li><a href="https://jlj98.top/jvm-gc/">深入理解虚拟机–垃圾收集器</a></li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是<strong>一组规则或规范</strong>，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。Java虚拟机定义JMM来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/683938430ad9246803a21b944038d361.jpg"></p><p>简单的总结，Java多线程之间通过共享内存来进行通信，但由于采用共享通信，在通信过程中会出现可见性、原子性、顺序性等问题，而JMM就是围绕多线程通信以及其相关的一系列特性建立的模型。</p><h3 id="内存屏障（Memory-Barrier"><a href="#内存屏障（Memory-Barrier" class="headerlink" title="内存屏障（Memory Barrier)"></a>内存屏障（Memory Barrier)</h3><p>内存屏障，又称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。</p><ul><li>保证特定操作的执行顺序。</li><li>影响某些数据（或则是某条指令的执行结果）的内存可见性。</li></ul><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before原则定义如下：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><p>happens-before规则如下：</p><ul><li>程序顺序规则：一个线程内，安装代码顺序，书写在前面的操作先行发生于书写后面的操作，happens-before于该线程中任意的后续操作；</li><li>监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作；</li><li>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读；</li><li>传递性规则：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li></ul><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/javazejian/article/details/72772461">全面理解Java内存模型(JMM)及volatile关键字</a></li><li><a href="https://juejin.im/post/5b87ad31e51d4538e41066e9">啃碎并发（九）：内存模型之基础概述</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存模型 </tag>
            
            <tag> 内存结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次JVM内存泄露</title>
      <link href="problem-jvm-thread/"/>
      <url>problem-jvm-thread/</url>
      
        <content type="html"><![CDATA[<p>之前接手一个别人刚写好的项目，丢到服务器上跑了没几天，服务器上别的服务都不能使用了。查看阿里云控制台，发现内存爆满了，只能先把这个服务先下，保证别的服务正常使用，还好是在测试阶段，还没正式上线。<br>对于内存泄露，一开始以为是Java I/O操作没有关闭，导致Java JVM内存泄露。但是发现项目中的I/O操作都已经把做了close操作。最后使用 <strong>jconsole</strong> 来监控本地内存的变化，发现是不断的创建线程，导致内存的不足，本地长时间跑项目出现下面的错误，这个和通过jconsole监控内存得出的结果差不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create new native thread</span><br></pre></td></tr></table></figure><p>于是就到项目中看了下，项目中对于线程的创建，终于知道什么问题了。项目中线程的创建没有通过线程池，而是直接<code>new Thread</code>和通过 <code>ScheduledExecutorService</code> 定时创建线程，导致线程耗尽内存。   </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/25608cff2f17a1f8543bbead2fecd424.jpg"></p><p>在阿里的Java开发手册中，就指出项目中的对于线程的创建，必须通过线程池，不能私自创建线程。关于<a href="https://jlj98.top/java-thread-pool">线程池</a>可以看这篇博客。</p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发容器 ——— ConcurrentHashMap</title>
      <link href="java-ConcurrentHashMap/"/>
      <url>java-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>在Java中，map是一个非常常用的。在平时，一般使用，<a href="https://jlj98.top/Java-HashMap/">HashMap</a>就可以了，但是HashMap不是线程安全的。JDK为我们解决了这个问题，它为HashMap提供了一个线程安全的高效版本 —— ConcurrentHashMap。在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术(JAVA8之前)只对所操作的段加锁而不影响客户端对其它段的访问。<strong>特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作</strong>。</p><h2 id="JDK8之前的实现"><a href="#JDK8之前的实现" class="headerlink" title="JDK8之前的实现"></a>JDK8之前的实现</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/3fe9c26928160aacdb70deee77591c69.jpg"></p><h3 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h3><p>在Java8之前的ConcurrentHashMap中，采用的是分段加锁来解决线程安全问题。默认情况下内部按并发级别为16来创建。对于每个segment的容量，默认情况也是16。当然并发级别(concurrentLevel)和每个段(segment)的初始容量都是可以通过构造函数设定的。<br>下面是segment的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>，<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    Segment(<span class="keyword">float</span> lf) &#123; <span class="keyword">this</span>.loadFactor = lf; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>对于ConcurrentHashMap，在读取的时候不使用锁，它没有使用同步控制，交给segment去找</p><h2 id="JDK8中的实现"><a href="#JDK8中的实现" class="headerlink" title="JDK8中的实现"></a>JDK8中的实现</h2><p>它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(JDK7与JDK8中HashMap的实现)，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。<br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/2db6678d67951be631195fb6f0d8d9e0.jpg"></p><p>下面是源码中的一些默认参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认初始值，16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//哈希表在其容量自动增加之前可以达到多满的一种尺度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值 &gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS（Compare and Swap），即比较并替换，实现并发算法时常用到的一种技术，Doug lea大神在java同步器中大量使用了CAS技术，鬼斧神工的实现了多线程执行的安全性。<br>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p><h3 id="重要内部类"><a href="#重要内部类" class="headerlink" title="重要内部类"></a>重要内部类</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node作为ConcurrentHashMap中最核心、最重要的内部类，保存key-value的数据结构。所有插入ConCurrentHashMap的中数据都将会包装在Node中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; </span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;           <span class="comment">//带有volatile，保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;  <span class="comment">//下一个节点的指针</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + val; &#125;</span><br><span class="line">     <span class="comment">/** 不允许修改value的值 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**  赋值get()方法 */</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Node内部类中，其属性value、next都是带有volatile的。同时其对value的setter方法进行了特殊处理，不允许直接调用其setter方法来修改value的值。最后Node还提供了find方法来赋值map.get()。</p><h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p>HashMap的核心数据结构就是链表，在ConcurrentHashMap中就不一样了，如果链表的数据过长是会转换为红黑树来处理。当它并不是直接转换，而是将这些链表的节点包装成TreeNode放在TreeBin对象中，然后由TreeBin完成红黑树的转换。所以TreeNode也必须是ConcurrentHashMap的一个核心类，其为树节点类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon </span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找hash为h，key为k的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h4><p>该类并不负责key-value的键值对包装，它用于在链表转换为红黑树时包装TreeNode节点，也就是说，ConcurrentHashMap红黑树存放是TreeBin。TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K, V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">        </span><br><span class="line">        TreeBin(TreeNode&lt;K, V&gt; b) &#123;</span><br><span class="line">            <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.first = b;</span><br><span class="line">            TreeNode&lt;K, V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K, V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    r = x;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K, V&gt; p = r; ; ) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            r = balanceInsertion(r, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.root = r;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** 省略很多代码 */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//casTabAt()方法使用的是CAS技术</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//synchronized加锁来保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CAS更新</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectRelease(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h3><ul><li>为每个内核分任务，并保证其不小于16</li><li>检查nextTable是否为null，如果是，则初始化nextTable，使其容量为table的两倍</li><li>死循环遍历节点，知道finished：节点从table复制到nextTable中，支持并发，请思路如下：<ul><li>如果节点 f 为null，则插入ForwardingNode（采用Unsafe.compareAndSwapObjectf方法实现），这个是触发并发扩容的关键</li><li>如果f为链表的头节点（fh &gt;= 0），则先构造一个反序链表，然后把他们分别放在nextTable的i和i + n位置，并将ForwardingNode 插入原节点位置，代表已经处理过了</li><li>如果f为TreeBin节点，同样也是构造一个反序 ，同时需要判断是否需要进行unTreeify()操作，并把处理的结果分别插入到nextTable的i 和i+nw位置，并插入ForwardingNode 节点</li></ul></li><li>所有节点复制完成后，则将table指向nextTable，同时更新sizeCtl = nextTable的0.75倍，完成扩容过程</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树，相对而言，总结如下思考：</p><ul><li>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而 JDK1.8锁的粒度就是HashEntry（首节点）</li><li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</li><li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li><li>JDK1.8使用内置锁synchronized来代替重入锁ReentrantLock </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://ifeve.com/java-concurrent-hashmap-2/">深入剖析ConcurrentHashMap(2)</a></li><li><a href="https://www.jianshu.com/p/afced7423ce6">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 字符串排序</title>
      <link href="mysql-varchar-order-by/"/>
      <url>mysql-varchar-order-by/</url>
      
        <content type="html"><![CDATA[<p>之前对于MySQL数据库的字符串排序没有深入了解，今天帮同事看这个问题，就深入的了解下。先看下数据库的表，我想查询字母倒序，字符串倒序的一个数据。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/aec7b472f5b49e5e90e495c08a367f7b.jpg"></p><p>根据上面的要求，第一个版本的SQL是下面的样子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> level <span class="keyword">from</span> test <span class="keyword">order</span> <span class="keyword">by</span> level <span class="keyword">desc</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果发现最后的数据是 <strong>B9</strong>。咦，这是什么问题，网上看了下，字符的排序规则是先对第一个字符串排序，再下一个字符串，就这样排序，所以就出现之前的问题。于是出现了第二个版本的SQL查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MID(level,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">left</span>(level,<span class="number">1</span>) <span class="keyword">DESC</span> , <span class="built_in">CAST</span>(MID(level,<span class="number">2</span>) <span class="keyword">AS</span> UNSIGNED) <span class="keyword">DESC</span></span><br><span class="line">limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上面的SQL中可以看出，对于字符串的数字，可以使用<code>CAST(MID(level,2) AS UNSIGNED)</code>来转化。在网上查询资料的时候，也发现了下面两种查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="number">1</span>  <span class="keyword">order</span> <span class="keyword">by</span> id<span class="operator">+</span><span class="number">0</span> <span class="keyword">desc</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="number">1</span>  <span class="keyword">order</span> <span class="keyword">by</span> id<span class="operator">*</span><span class="number">1</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h2 id="数据库空格对字符串的查找的影响"><a href="#数据库空格对字符串的查找的影响" class="headerlink" title="数据库空格对字符串的查找的影响"></a>数据库空格对字符串的查找的影响</h2><p>MySQL 数据库对字符串影响，空格在字符串的前面和中间是会影响字符串，在字符串后面的空格，MySQL 会忽略。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是一个日常总结。不过在查询资料的时候，和数据库的类型也有一定的关系。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中各种锁</title>
      <link href="java-lock/"/>
      <url>java-lock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：如果本文有错误，希望指出。</p></blockquote><p>数据库中的各种锁可以前往<a href="https://jlj98.top/database-locks">数据库锁机制</a>查看。Java中提供的各种锁可以实现并发编程。<br>锁是用来控制多个线程访问共享资源的方式，一辩来说，一个锁能够防止多个线程同时访问共享资源。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁 ，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。 </p><p>在JAVA环境下 ReentrantLock 和 Synchronized 都是 <strong>可重入锁</strong>。<br>可重入锁最大的作用是避免死锁。</p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁是采用让当前线程不停地在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。</p><p>自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不断增加时，性能下降明显，因为每个线程都需要执行，会占用CPU时间片。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p><h1 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h1><p>独享锁是指该锁一次只能被一个线程所持有。ReentrantLock 、Synchronized 都是独享锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReetrankLock-与-synchronized-比较"><a href="#ReetrankLock-与-synchronized-比较" class="headerlink" title="ReetrankLock 与 synchronized 比较"></a>ReetrankLock 与 synchronized 比较</h2><p><a href="https://jlj98.top/java-synchronized">Java 并发编程之 Synchronized 详解</a></p><p><a href="https://jlj98.top/java-reentrantlock/">Java 并发编程之 ReentrantLock 详解</a></p><p>synchronized 在1.5版本之前性能低下，因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。但在之后的JDK版本中进行了大量的优化，性能已经和ReetrankLock相媲美。 使用 synchronized 关键字将会隐式的获取锁，但是它将锁的获取和释放固定化了，也就是先获取再释放。 </p><p>Synchronized 底层实现原理：</p><ul><li>Synchronized 同步语句块的实现使用的是 <code>monitorenter </code>和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。 </li><li>Synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</li></ul><p>ReentrantLock与synchronized很相似，它们都具备一样的线程重入特性，只是代码写法上有点区别而已，一个表现为API层面的互斥锁（Lock），一个表现为原生语法层面的互斥锁（Synchronized）</p><h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><p>共享锁是指该锁可被多个线程所持有。ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的。独享锁与共享锁也是通过AQS（AbstractQueuedSynchronizer）来实现的，通过实现不同的方法，来实现独享或者共享</p><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>独享锁/共享锁就是一种广义的说法，互斥锁/读写锁指具体的实现。互斥锁在Java中的具体实现就是ReentrantLock</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>在Java中读写锁的具体实现是 <code>ReentrantReadWriteLock</code>，这个类在<code>java.util.concurrent.locks</code>包下面。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//上读锁，其他线程只能读不能写</span></span><br><span class="line">    readWriteLock.readLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上写锁，不允许其他线程读也不允许写</span></span><br><span class="line">    readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这篇博客对读写锁分析的挺不错的。</p><ul><li><a href="https://blog.csdn.net/yanyan19880509/article/details/52435135">轻松掌握java读写锁(ReentrantReadWriteLock)的实现原理</a></li></ul><h1 id="公平锁和不公平锁"><a href="#公平锁和不公平锁" class="headerlink" title="公平锁和不公平锁"></a>公平锁和不公平锁</h1><p>两者的区别主要体现在<strong>是否按照申请锁的顺序来获取锁</strong>。</p><p><a href="https://juejin.im/post/5b25eed351882574b9693985">Java多线程 – 公平锁和非公平锁</a></p><ul><li>公平锁：多个线程按照申请锁的顺序来获取锁。</li><li>不公平锁：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。可能造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，通过构造函数 ReentrantLock(boolean fair) 指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/aalansehaiyang/Lock-Learning">锁汇总</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程 —— ThreadLocal</title>
      <link href="java-ThreadLocal/"/>
      <url>java-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错误，希望指出。</p></blockquote><p>今天在重新看阿里Java手册的时候，看到了ThreadLocal，就想对ThreadLocal进一步了解下。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/991749bb14c68f0ef80a4ad575c71c83.jpg"></p><p>在讲ThreadLocal之前，先去了解了下SimpleDateFormat为什么不是线程安全的。先来看下SimpleDateFormat的部分源码，这个在网上应该也有讲解。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/cb0807512850a1ff54de2be570a2afea.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c33ac0b3ab33797a1fe8a000388d31e9.jpg"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c445d42e6c69474ddaa9d79b4cb33ddc.jpg"></p><p>可以看这个 **<a href="http://ifeve.com/notsafesimpledateformat/">原因</a>**，讲解的挺详细的。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20210412214501.png"></p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>每一个线程持有一个ThreadLocalMap。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/1b21be84147d34226b604d57c2589f1a.jpg"></p><p>一个Thread中只有一个 ThreadLocalMap，一个 ThreadLocalMap 中可以有多个 ThreadLocal 对象，其中一个 ThreadLocal 对象对应一个ThreadLocalMap中的一个Entry（也就是说：一个Thread可以依附有多个ThreadLocal对象）。</p><h3 id="ThreadLocalMap-和-WeakReference"><a href="#ThreadLocalMap-和-WeakReference" class="headerlink" title="ThreadLocalMap 和 WeakReference"></a>ThreadLocalMap 和 WeakReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;<span class="comment">//默认初始化16容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap 从字面上可以看出是保存 ThreadLocal 对象的 map(其实是以 ThreadLocal 为 key)，不过是经过两层包装：</p><ul><li>第一次使用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 将 ThreadLocal 对象变成一个弱引用对象。</li><li>第二层是定义一个专门的类 Entry 来扩展<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 。</li></ul><p>类 Entry 保存 map 键值对的实体，<code>ThreadLocal&lt;?&gt;</code> 为 key，保存的线程局部变量值为 value。super(k) 调用的是 WeakReference 的构造函数，表示将 ThreadLocal&lt;?&gt; 变为弱引用。</p><h3 id="TreadLocal-构造函数"><a href="#TreadLocal-构造函数" class="headerlink" title="TreadLocal 构造函数"></a>TreadLocal 构造函数</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/0903514258514082721d839fbede5c67.jpg"></p><h3 id="TreadLocal-的-set-方法"><a href="#TreadLocal-的-set-方法" class="headerlink" title="TreadLocal 的 set 方法"></a>TreadLocal 的 set 方法</h3><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/7f08d6516ee4fd781629b169a2dd2c20.jpg"></p><h3 id="table扩容"><a href="#table扩容" class="headerlink" title="table扩容"></a>table扩容</h3><p>如果table中的元素数量达到阈值threshold的3/4，会进行扩容操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>; <span class="comment">//旧的大小的2倍</span></span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123; <span class="comment">//如果key为null，回收value</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-内存回收"><a href="#ThreadLocal-内存回收" class="headerlink" title="ThreadLocal 内存回收"></a>ThreadLocal 内存回收</h2><p>ThreadLocal 涉及到两个层面的内存回收。</p><h3 id="ThreadLocal-层面的内存回收"><a href="#ThreadLocal-层面的内存回收" class="headerlink" title="ThreadLocal 层面的内存回收"></a>ThreadLocal 层面的内存回收</h3><p>当线程死亡，所有的保存的线程局部变量就会被回收，其实这里只线程 Thread 对象中的 ThreadLocal.ThreadLocalMap threadLocals 会被回收。</p><h3 id="ThreadLocalMap-层面的内存回收"><a href="#ThreadLocalMap-层面的内存回收" class="headerlink" title="ThreadLocalMap 层面的内存回收"></a>ThreadLocalMap 层面的内存回收</h3><p>当线程存活的时间够长，并且该线程保存的线程局部变量很多，就需要在线程的生命期内进行 ThreadLocalMap 的内存回收。 </p><p>Entry 对象的key 是WeakReference 的包装，当 ThreadLocalMap 的 <code>private Entry[] table</code>，已经被占用达到 <strong>2/3</strong> (线程拥有的局部变量超过10个)时，就会尝试回收。在 <code>ThreadLocalMap.set</code> 方法中有回收的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br></pre></td></tr></table></figure><p><code>cleanSomeSlots</code> 具体回收代码：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/0c6ddb2d3674cf6fecba6b797bb8a754.jpg"></p><h2 id="ThreadLocal-可能引起的-OOM-问题"><a href="#ThreadLocal-可能引起的-OOM-问题" class="headerlink" title="ThreadLocal 可能引起的 OOM 问题"></a>ThreadLocal 可能引起的 OOM 问题</h2><p>在一个线程结束的时候，<code>Thread</code> 会调用 <code>exit</code> 方法进行回收。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/849b64181522efa2a3386f91c39b1725.jpg"></p><p>但是，当我们使用线程池的时候，这意味着当前线程未必会退出。这可能使得一些大的对象设置到 ThreadLocal 中，导致出现 OOM。比如当线程是设置固定值，第一次处理业务时，向 ThreadLocalMap 中存放了一个很大的对象，第二次，第三次。。。，线程一直在运行，这会导致这个线程的出现 OOM。</p><h3 id="ThreadLocalMap的key为弱引用"><a href="#ThreadLocalMap的key为弱引用" class="headerlink" title="ThreadLocalMap的key为弱引用"></a>ThreadLocalMap的key为弱引用</h3><p>关于弱引用、强引用这些，可以看<a href="https://jlj98.top/jvm-gc/">深入理解虚拟机——垃圾收集器</a>，这里面稍微讲解了下这方面。</p><p>ThreadLocalMap 会在下一次GC的时候，回收掉 key，而ThreadLocal 在下一次调用 get、set 和 remove，会清除并重构 ThreadLocalMap，其方法是 <code>expungeStaleEntry</code>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.jianshu.com/p/33c5579ef44f">深入浅出ThreadLocal</a></li><li><a href="http://ifeve.com/notsafesimpledateformat/">线程不安全的SimpleDateFormat</a></li><li><a href="http://ifeve.com/threadlocal%E4%BD%BF%E7%94%A8/">ThreadLocal使用</a></li><li><a href="https://blog.csdn.net/xlgen157387/article/details/78297568">Java多线程编程-（8）-多图深入分析ThreadLocal原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程 —— 线程池</title>
      <link href="java-thread-pool/"/>
      <url>java-thread-pool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果本文有错误，希望指出。</p></blockquote><p>在项目中，线程是一种稀缺资源，频繁的创建和销毁，对于系统的性能有着很大的消耗。线程池是线程资源复用的典范之作，通过维护一个一定数量的线程集合，在需要运行线程任务的时候直接从这个集合中取出一个线程去运行任务，而不是重新创建一个。这点在阿里Java手册上也提出了：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/a7ad8beaaf5dfaefbd568fe4a9046a5c.jpg"></p><p>使用线程池可以带来一系列好处：</p><ul><li>降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li>提高响应速度：任务到达时，无需等待线程创建即可立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li>提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><p>在Java中提供了几种线程池创建的方法，不过这几种方法都是最后通过 <code>ThreadPoolExecutor</code> 来创建线程的。在开始讲Java提供的几种之前，先讲下 <code>ThreadPoolExecutor</code> 中几个参数的含义。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="内部工作原理"><a href="#内部工作原理" class="headerlink" title="内部工作原理"></a>内部工作原理</h3><ul><li>corePoolSize ：池中所保存的线程数，包括空闲线程，除非设置 allowCoreThreadTimeOut 参数，否则创建后会一直存活</li><li>maximumPoolSize：池中允许的最大线程数</li><li>keepAliveTime：<strong>非核心线程</strong>空闲线程等待新任务的最长时间，即线程数多余核心数的线程，会被销毁掉</li><li>unit：keepAliveTime 参数的时间单位</li><li>workQueue ：执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务</li><li>threadFactory：执行程序创建新线程时使用的工厂</li><li>handler ：由于超出线程范围和队列容量而使执行</li></ul><h3 id="线程池运行流程"><a href="#线程池运行流程" class="headerlink" title="线程池运行流程"></a>线程池运行流程</h3><ul><li>如果当前池大小 poolSize 小于 corePoolSize ，则创建新线程执行任务；</li><li>如果当前池大小 poolSize 大于 corePoolSize ，且等待队列未满，则进入等待队列；</li><li>如果当前池大小 poolSize 大于 corePoolSize 且小于 maximumPoolSize ，且等待队列已满，则创建新线程执行任务；</li><li>如果当前池大小 poolSize 大于 corePoolSize 且大于 maximumPoolSize ，且等待队列已满，则调用拒绝策略来处理该任务；</li><li>线程池里的非核心线程执行完任务后不会立刻退出，而是会去检查下等待队列里是否还有线程任务需要执行，如果在 keepAliveTime 里等不到新的任务了，那么非核心线程就会退出。</li></ul><p>在线程大于 corePoolSize，进入队列等待。如果队列也满了，且线程数小于 maximumPoolSize，则创建新的线程。如果线程数大于maximumPoolSize，则使用拒绝策略来处理任务。关于非核心线程的存活，详细看<a href="https://jlj98.top/java-thread-pool-source/">多线程编程 —— 线程池源码解析</a></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池有四种拒绝策略：</p><ul><li>AbortPolicy：抛出 <code>RejectedExecutionException</code> 异常，默认</li><li>CallerRunsPolicy：使用调用者所在线程执行任务</li><li>DiscardPolicy：直接丢弃任务</li><li>DiscardOldestPolicy：丢弃队列中最旧的任务</li></ul><p>对于线程池选择的拒绝策略可以通过 <code>RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();</code> 来设置。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? </span><br><span class="line">        <span class="keyword">null</span> : </span><br><span class="line">        AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中提供的几种方法"><a href="#Java-中提供的几种方法" class="headerlink" title="Java 中提供的几种方法"></a>Java 中提供的几种方法</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>通过创建一个 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同的线程池。使用 <code>LinkedBlockingQuene</code> 作为阻塞队列，不过当线程池没有可执行任务时，也不会释放线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><ul><li>初始化一个可以缓存线程的线程池，以前构建的线程可用时将重用它们，空闲线程默认缓存60s，线程池的线程数可达到 <code>Integer.MAX_VALUE</code>，即 2147483647，内部使用 <code>SynchronousQueue</code> 作为阻塞队列；   </li><li>和 <code>newFixedThreadPool</code> 创建的线程池不同，<code>newCachedThreadPool</code> 在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用 <code>LinkedBlockingQueue</code> 作为阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据，也是使用 <code>ThreadPoolExecutor</code> 构建线程池，最大核心线程数 <code>Integer.MAX_VALUE</code>，使用<code>DelayedWorkQueue</code> 作为阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>newWorkStealingPool，它是 <code>jdk1.8</code> 提供的一种线程池，用于执行并行任务。默认并行级别为当前可用最大可用cpu数量的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：用于大耗时同时可以分段并行的任务。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>除了 newWorkStealingPool 之外，其他四个创建方式都存在资源耗尽的风险。在<a href="https://developer.aliyun.com/topic/java20?source=5176.11533457&userCode=bfol0yvy&type=copy">阿里Java开发手册——嵩山版</a>上面关于线程池创建的注意：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200830090608.png"></p><p>在最新版的Java 开发手册中，在说 Executors 创建线程池弊端中，去掉了 newScheduledThreadPool，在之前的版本中，还是提示 newScheduledThreadPool 因为创建的线程数为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><h2 id="多少的线程数合适？"><a href="#多少的线程数合适？" class="headerlink" title="多少的线程数合适？"></a>多少的线程数合适？</h2><h3 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h3><p>对于CPU密集型任务，比如加密解密，压缩，计算等一系列需要大量耗费CPU资源的任务，最佳的任务线程数为CPU核心数的1~2倍，如果设置过多线程数，实际并不会起到很好的效果。以内CPU密集型任务会占用大量的CPU资源，所以这时的CPU的每个核心工作基本都是满负荷的，而设置多过线程，每个线程都会去利用CPU资源来执行任务，这就会造成不必要的上下文切换。</p><h3 id="耗时IO型任务"><a href="#耗时IO型任务" class="headerlink" title="耗时IO型任务"></a>耗时IO型任务</h3><p>耗时IO型任务，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗CPU资源，但是IO操作很耗时，总体会占用比较多的时候。对于这种任务，最大线程数一般会大于核心数的很多倍，因为IO读写速度相对于CPU的速度而言是比较慢的，如果设置过少的线程数，就会导致CPU资源的浪费。</p><p>《Java 并发编程实战》作者推介的算法：<code>线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）</code>。</p><p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.jianshu.com/p/87bff5cc8d8c">深入分析java线程池的实现原理</a><br><a href="https://github.com/tedburner/spring-boot-examples/tree/master/common-kit/src/main/java/com/kit/common/util/thread">Github上的源码</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— Vector</title>
      <link href="java-vector/"/>
      <url>java-vector/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8</p></blockquote><p>关于<a href="https://jlj98.top/Java-ArrayList-LinkedList/">ArrayList和LinkedList的区别</a>可以看这里。   </p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector也是实现List接口的，底层数据结构和 <code>ArrayList</code> 类似，也是一个动态数组存放数据。不过是在 add() 方法的时候使用 synchronize 进行同步写数据，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。  </p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Vector也提供了几种初始化方法，默认初始化为10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initialCapacity 初始容量；capacityIncrement 每次扩容时的增加量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>); <span class="comment">//调用ensureCapacityHelper 方法，是否需要扩容</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数 minCapacity 当前集合的位置加一</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定位置插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">&quot; &gt; &quot;</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这是一个native方法，数组指定位置往后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;<span class="comment">//覆盖指定位置的值</span></span><br><span class="line">    elementCount++;<span class="comment">//数组大小统计加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>Vector默认情况下每次扩容请求其大小的2倍空间。这和初始化时 <code>capacityIncrement</code> 的值有关，如果不为0，则是老的容量在加上 <code>capacityIncrement</code>。最后和你现在需要的容量在进行对比，是否符合当前需要的容量。<code>ArrayList</code> 默认扩容1.5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组最大的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//如果扩容增加量不为零，每次的扩容是加上扩容量，不然则是原来的2倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//如果新的容量小于最小需要扩容量</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
            <tag> Vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="java-static-final-abstract/"/>
      <url>java-static-final-abstract/</url>
      
        <content type="html"><![CDATA[<p>在Java这门面向对象编程语言中，有几个关键字是必须了解的，下面是我在学习的记录笔记。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>在平时，我们调用一个类里面的属性或者方法的时候，需要new一个新的类，然后调用类的方法或者属性。<br>static表示全局或者静态的意思。可用来修饰成员变量或者方法。被static修饰的成员变量和方法独立于该类的任何对象，也就是说，它不依赖类特定的实例，就是被这个修饰的不需要实例化就可以使用，就可以被类的所有实例共享。<br>static代码块也叫静态代码块，在类中独立于类成员的static语句块，<strong>JVM加载时</strong> 会执行这些静态代码块。<br>在静态方法中，不能访问非静态方法或者是非静态变量。如代码中，准确的来说，只有被static修饰的变量和方法，才能不需要实例化直接使用，即使在static修饰的方法中，也不能直接调用没有实例化的非静态方法或者是非静态变量。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/bc734d93d090090a2e8a1364402af6fb.jpg"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>一旦使用了final，该变量就不可修改；如果方法被final修饰，那么这个方法就不可被子类重写；final类，是不能被子类继承的。这里有一篇<a href="https://juejin.im/post/5ae9b82c6fb9a07ac3634941">博客</a>讲的挺详细的。 </p><ul><li>final 修饰类,表示该类不可以被继承</li><li>final 修饰变量,分两种情况,如果修饰的是基本类型变量,那么只能被赋值一次,不能被赋值两次, 如果修饰的是引用类型变量,那么引用指向的内存地址将不可变,但是引用类型内的属性可以被修改</li><li>final 修饰方法,表示该方法不可以被子类重写,但是可以被子类继承使用</li></ul><p>final的好处：  </p><ul><li>final关键字提高了性能。JVM和java的应用都会缓存final变量  </li><li>final变量可以安全的在多线程环境下进行共享；</li><li>使用final关键字，JVM会对方法、变量及类进行优化。   </li></ul><p>final修饰的变量是引用类型变量,那么引用指向的内存地址将不可变,但是引用类型内的属性可以被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer a = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">a.append(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>抽象类里面不一定有抽象方法，但是有抽象方法，那么这个类就是抽象类。<br>使用abstract关键字修饰的话，类可以进行扩展，但是方法不能实例化，如下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然抽象方法不能实例化，但是可以通过继承，在子类中进行重写。其实Java中接口interface就是一个抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> <span class="keyword">extends</span> <span class="title">AbstractTest</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hell abstract&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便我们来下看接口类的方法中，我们咋样来写方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">interfaceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//这种是Java8中新增的一种方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法可以实现</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile则是轻量级的synchronized。如果一个变量使用volatile，则它比使用synchronized的成本更加低，因为它不会引起线程上下文的切换和调度。Java语言规范对volatile的定义如下：  </p><p><strong>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量</strong>。     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对于这语句，在执行的过程中，会先从内存中读取i的值，然后复制一份到高速缓存中，然后CPU执行指令对进行加1操作，然后将数据写入高速缓存，最后将高速缓存中最新的值刷新到主存中   </p><p>volatile保证了下面这两点：</p><ul><li>可见性</li><li>禁止重排序</li></ul><p>Java提供volatile关键字来保证可见性。当一个共享变量被修饰的时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。<br>volatile修饰符组织了变量访问前后的指令重排，保证指令执行顺序，但是不能保证线程安全，因为不能保证原子性。<br>下面的代码起了20个线程，每个线程对race自增10000，理论上应该是200000，但是最后输出的结果并不是，而且每次运行都不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等所有累加线程结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>this 只能在方法内使用，表示对调用的方法的对象的引用。</p><h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p>如果一个对象中的某个属性不希望被序列化，则可以使用transient关键字进行声明。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static </tag>
            
            <tag> final </tag>
            
            <tag> abstract </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解虚拟机 —— 垃圾收集器</title>
      <link href="jvm-gc/"/>
      <url>jvm-gc/</url>
      
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。   </p><h2 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h2><p>Java虚拟机中如何判断Java对象死亡，需要被回收的呢？</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个计数器，当被引用，就加1，当失效就减一，当计数器为零的时候就是对象不再引用。这种算法实现简单，判断效率也高。</p><p>首先，引用计数算法无法解决「循环引用无法回收」的问题，即两个对象互相引用，所以各对象的计数器的值都是 1，即使这些对象都成了垃圾（无外部引用），GC 也无法将它们回收。当然上面这一点还不是引用计数法最大的弊端，引用计数算法最大的问题在于：计数器值的增减处理非常繁重，譬如对根对象的引用，此外，多个线程之间共享对象时需要对计数器进行原子递增/递减，这本身又带来了一系列新的复杂性和问题，计数器对应用程序的整体运行速度的影响。</p><p>案例：Redis 中的对象，就是使用引用计数来判断对象是否应该被回收，在 redisObject 结构体中使用了 refcount 来计数。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始往下搜索，搜索所有走过的路径称为引用链，当一个对象到GC Roots没有任何引用的时候，则证明该对象不可用。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><strong>强引用</strong>：强引用就是指在程序中普遍存在的，类似 <code>Object obj= new Obj</code> 这类引用，只要强引用还在，垃圾回收期永远不会回收被引用的对象。</li><li><strong>软引用</strong>：用来描述还有用但并非必需的对象。在系统将要发生内存溢出之前，对这些对象进行二次回收。</li><li><strong>弱引用</strong>：用来描述非必需的对象，但是比软引用强度更弱，被弱引用关联的对象只能存活到下一次垃圾回收之前。</li><li><strong>虚引用</strong>：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响；也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到个系统通知。</li></ul><h4 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h4><p>引用队列 <code>ReferenceQueue</code> 是用来配合引用工作的，没有ReferenceQueue一样可以运行。创建引用的时候可以指定关联的队列，<strong>当GC释放对象内存的时候，会将引用加入到引用队列，这相当于是一种通知机制</strong>。当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。JVM提供了一个ReferenceHandler线程，将引用加入到注册的引用队列中。</p><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使可达性算法中不可达的对象，也并发是”非死不可“，会暂时处于”缓刑“状态，真要宣告一个对象死亡，至少需要经历两次标记过程：如果对象在进行可达性分析后没有和 GC Roots 相连接的引用链，那它会被第一次标记并进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200526165629.png"></p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前面讲述对象标记判定时已经介绍过了。这是基础算法，别的回收算法都是在这基础上改进的。</p><p>缺点：</p><ul><li>效率不高</li><li>会产生大量不连续的内存碎片</li></ul><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这块的内存用完了，就将还存活着的对象复制到另外块上面，然后再把已使用过的内存空间一次清理掉。</p><p>缺点：</p><ul><li>内存的使用率不高，使用中浪费了一半的内存</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流的垃圾收集采用的都是”分代收集算法“，新生代使用复制算法，老年代使用标记-整理/清除算法。</p><p>根据对象存活周期将内存划分为新生代和老年代。在新生代中，每次垃圾收集都发现大批对象死去，只有少量存活，就选用复制算法；老年代因为对象存活率高、没有额外空间进行分配担保，使用标记-整理/清除算法。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200526170139.png"></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>是一个单线程收集器，它进行垃圾收集时，必须<strong>暂停</strong>其他所有的工作现场，直到它收集结束。    </p><p>新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本。</p><p>新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器类似于ParNew 收集器。Parallel Scavenge收集器是一个新时代收集器。使用复制算法，并行的多线程收集器。它的吞吐量非常不错。</p><p>新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，使用<strong>标记-整理算法</strong>。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>是Parallel Scavenge收集器老年代的收集器，使用多线程和<strong>标记-整理算法</strong>。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS( Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器就非常符合这类应用需求。</p><p>CMS收集器使用<strong>标记-清除算法</strong>。</p><p>运作流程：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>1、初始标记只是标记一下 GC Roots 能直接关联到对象，速度很快；</p><p>2、并发标记是对 GC Roots Tracing 的过程，从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但不需要停顿用户线程；</p><p>3、重新标记是为了修正并发标记期间，因用户程序继续运行而导致标记产生变换的一部分，这个阶段的停顿时间一般比初始标记阶段长；</p><p>4、并发清除阶段，清除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也可以与用户线程同时并发；</p><p>5、整个 GC 过程中消耗最长的是并发标记和并发清除过程，但是这两个阶段的垃圾回收可以和用户现场一起并发执行。</p><p>初始标记和重新标记，需要<code>STW</code>。总体上说，CMS 收集器的内存回收过程式和用户现场一起执行的。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1 ( garbage-first)收集器是当今收集器技术发展的最前沿成果之一。  </p><p>G1 将 Java 堆内存分割成若干相同大小的区域，即 region，包括 Eden、Survivor、Old、Humongous 四种类型。其中 Humongous 是特殊的 Old 类型，专门放置大型对象。这样的划分方式意味着不需要一个连续的内存空间管理对象。G1 将空间分为多个区域，<strong>优先回收垃圾最多的区域</strong>。G1 从整体来看是基于”标记-整理“算法实现的收集器，但从局部(两个 Region 之间)上看又是基于”标记-复制“算法实现的，不过无论如何，这两种算法都不会产生大量的空间碎片。G1 的一大优势在于可预测停顿时间，能尽可能快速地在指定时间内完成垃圾回收任务。</p><p>G1 收集器的运作步骤：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能够关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借助进行 Minor GC (新生代收集，指目标只是新生代的垃圾收集) 的时候同步进行的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</li><li>并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理 SATB (原始快照) 记录下的在并发时有引用变动的对象。</li><li>最终标记：对用户线程做另一个短暂停顿，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。</li><li>筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期待的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧的 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多调收集器线程并行完成的。</li></ul><p>从上面可以看出， G1 收集器除了并发标记外，其余阶段也是要完全暂停用户线程，换而言之，他并非纯粹地追求低延迟，官方目标：在延迟可控的情况下获得尽可能高的吞吐量。</p><p>G1 无论是为了垃圾回收产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。其中内存占用来说，G1 的卡表实现比CMS更加复杂，而且对重每个Region 都必须有一份卡表，这导致G1的记忆集可能占整个堆容量的20%乃至更多的内存空间。</p><p>目前在小内存应用上CMS的表现大概率仍然会优于G1，而在大内存上G1则大多能发挥其优势，这个优势的JAVA堆容量平衡点通常在6G ~ 8G之间，之前看到有人说，使用G1的话，最好&gt;=4G。</p><h3 id="低延迟垃圾收集器——Shenandoah-收集器"><a href="#低延迟垃圾收集器——Shenandoah-收集器" class="headerlink" title="低延迟垃圾收集器——Shenandoah 收集器"></a>低延迟垃圾收集器——Shenandoah 收集器</h3><p>Shenandoah 收集器是RedHat 开源给 OpenJDK 的，被Oracle 官方摒弃在 OracleJDK 外，所以在OracleJDK中是没法见到这款优秀的收集器的。</p><p>Shenandoah 也是基于 Region 的堆内存布局，同样有着用于存放大对象的 Humongous Region，默认的回收策略也同样是优先处理回收价值最大的 Region。</p><p>Shenandoah 支持并发的整理算法。Shenandoah 是默认不适用分代收集的。</p><p>Shenandoah 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”的全局数据结构来记录跨 Region 的引用，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</p><ul><li>初始标记：和 G1 一样，首先标记与 GC Roots 直接关联的对象，这个阶段仍是 STW，但停顿时间与堆大小无关，只与 GC Roots 的数量有关。</li><li>并发标记：与 G1 一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于对重存活对象的数量以及对象图的结构复杂程度。</li><li>最终标记：与 G1 一样，处理剩余的 STAB 扫描，并在这个阶段统计出回收价值最高的 Region，将这些 Region 构成一组回收集。最终标记阶段会有一小段短暂的停顿。</li><li>并发清理：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的 Region。</li><li>并发回收：在这个阶段，Shenandoah 要把回收集里面的存活对象先复制一份到其他未被使用的Region中。Shenandoah 通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。</li><li>初始引用更新：这个阶段需要把堆中所有指向旧对象的引用修正到复制后的新地址。</li><li>并发引用更新：真正开始进行引用更新操作，这个阶段是和用户线程一起并发的，时间长短取决于内存涉及的引用数量的多少。</li><li>最终引用更新：解决了堆中的引用更新后，还要修正存在与 GC Roots 中的引用。这个阶段还需要最后一次停顿。</li><li>并发清理：经过并发回收和引用更新后，整个回收集中所有的 Region 已再无存活对象了。</li></ul><h3 id="低延迟垃圾收集器——ZGC-收集器"><a href="#低延迟垃圾收集器——ZGC-收集器" class="headerlink" title="低延迟垃圾收集器——ZGC 收集器"></a>低延迟垃圾收集器——ZGC 收集器</h3><p>ZGC 是Oracle公司研发的一款低延迟垃圾收集器。ZGC 是一款基于 Region 内存布局的，(暂时)不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目的的一款垃圾收集器。</p><p>ZGC 的内存布局也是采用 Region 的堆内存布局，不过 ZGC 的 Region 具有动态性——动态创建和销毁，以及动态的区域容量大小。</p><ul><li>小型Region(Small Region)：容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型 Region(Medium Region)：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li><li>大型Region(Large Region)：容量固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。</li></ul><p>ZGC 的运作过程大致可划分一下四个大阶段。全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段。</p><ul><li>并发标记：并发标记是遍历对象图做可达性分析的阶段，会有一次短暂停顿。ZGC 的标记是在指针上而不是在对象上进行，标记阶段会更新染色指针的Marked 0、Marked 1 标志位。</li><li>并发预备重分配：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理那些Region，将这些Region组成重分配集。</li><li>并发重分配：重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集的每一个Region维护一个转发表，记录从旧对象到新对象的转向关系。</li><li>并发重映射：重映射所做的就是修正真个堆中指向重分配集中旧对象的所有引用。由于这一步不是很“迫切”，ZGC 把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成了。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第三版》</li><li><a href="https://juejin.im/post/5ae2fa25518825673d6d0e62">深入理解虚拟机之Java内存区域</a>   </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483949&idx=1&sn=8b69d833bbc805e63d5b2fa7c73655f5&chksm=ebf6da52dc815344add64af6fb78fee439c8c27b539b3c0e87d8f6861c8422144d516ae0a837&scene=21#wechat_redirect">jvm系列(二):JVM内存结构</a></li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c1ac861e6b434a57d066b4ef1c5da701.jpg" width = "200" height = "200" div align=center />]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC算法 </tag>
            
            <tag> 垃圾收集器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis —— 初识Redis</title>
      <link href="redis-basic-knowledge/"/>
      <url>redis-basic-knowledge/</url>
      
        <content type="html"><![CDATA[<p>Redis系列：</p><ul><li><a href="https://jlj98.top/redis-basic-knowledge/">Redis——初识Redis</a></li><li><a href="https://jlj98.top/redis-under-structure/">Redis——底层结构</a></li><li><a href="https://jlj98.top/redis-database/">Redis——数据库实现</a></li><li><a href="https://jlj98.top/redis-server-mater-salve/">Redis 服务集群</a></li></ul><p><a href="https://redis.io/">Redis官网</a><br><a href="http://www.redis.cn/">Redis中文官网</a></p><h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串（string）、散列（hash）、列表（list）、集合（set）、有序集合（sorted set）与范围查询、bitmaps、 hyperloglogs 和地理空间（geospatial） 索引半径查询。Redis内置了复制（replication），Lua脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence）， 并通过 Redis Sentinel 和自动 Redis Cluster 提供高可用性（high availability）。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h1><ul><li>性能极高：Redis能读的速度是110000次/s，写的速度是81000次/s </li><li>丰富的数据类型：Redis支持二进制案例的 Strings， Lists， Hashes， Sets 及 Ordered Sets 数据类型操作</li><li>原子：Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，但不保证原子性</li><li>丰富的特性：Redis还支持 publish/subscribe、通知、key 过期等特性</li></ul><h1 id="Redis-能做什么？"><a href="#Redis-能做什么？" class="headerlink" title="Redis 能做什么？"></a>Redis 能做什么？</h1><p>开发人员都只带Redis可以用来做缓存，除了缓存以外还可以做什么？<br>下面来自老钱的 <strong><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527">Redis 深度历险：核心原理与应用实践</a></strong></p><ul><li>记录帖子的点赞数、评论数和点击数 (hash)。</li><li>记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。</li><li>记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。</li><li>记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。</li><li>缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。</li><li>记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。</li><li>如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。</li><li>收藏集和帖子之间的关系 (zset)。</li><li>记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。</li><li>缓存用户行为历史，进行恶意行为过滤 (zset,hash)。</li></ul><h1 id="为什么-Redis是单线程模型，还会达到每秒万级别的处理能力？"><a href="#为什么-Redis是单线程模型，还会达到每秒万级别的处理能力？" class="headerlink" title="为什么 Redis是单线程模型，还会达到每秒万级别的处理能力？"></a>为什么 Redis是单线程模型，还会达到每秒万级别的处理能力？</h1><blockquote><p>1、内存访问，Redis 将所有数据放到内存中，内存的响应时长大约为100纳秒，这是 Redis 达到每秒万级别访问的重要基础；<br>2、非阻塞 I/O，Redis 使用 epoll 作为 I/O 多路复用技术的实现，再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转化为事件，不在网络 I/O 上浪费事件；</p><ul><li>阻塞 IO： 资源不可用时，IO 请求一直阻塞，直到反馈结果（有数据或超时）</li><li>非阻塞 IO：资源不可用时，IO 请求离开返回，返回数据标识资源不可用   </li></ul><p>3、单线程避免了线程切换和竞争产生的消耗。</p></blockquote><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><p>详细的教程这里就不写了，给篇 <strong><a href="https://blog.csdn.net/lc1010078424/article/details/78295482">参考文献</a></strong></p><h2 id="Redis基本类型"><a href="#Redis基本类型" class="headerlink" title="Redis基本类型"></a>Redis基本类型</h2><p>只讲一些常用的，详细的可以去官网查看。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>基本命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET key value  设置指定 key 的值</span><br><span class="line">GET key 获取指定 key 的值</span><br><span class="line">del key 删除指定key值</span><br><span class="line">GETRANGE key start end  返回 key 中字符串值的子字符</span><br></pre></td></tr></table></figure><p>对于字符串类型的保存，上面的知识简单的，如果你在终端中保存，它提示的命令其实不止是上面看到的。<code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code>，这才是它所提供全部的命令。不过从这个命令中可以看出，在后来版本的Redis中，基本上 <code>set </code>命令取代了 <code>setnx</code></p><ul><li>EX/PX： EX 指的是秒数；PX 指的是毫秒</li><li>NX/XX：NX 表示当key不存在时，创建保存；XX 表示当key存在时，保存value</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field1 [field2]  删除一个或多个哈希表字段</span><br><span class="line">HEXISTS key field  查看哈希表 key 中，指定的字段是否存在</span><br><span class="line">HGET key field 获取存储在哈希表中指定字段的值</span><br><span class="line">HGETALL key 获取在哈希表中指定 key 的所有字段和值</span><br><span class="line">HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中</span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序，元素可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index 通过索引获取列表中的元素</span><br><span class="line">LPOP key 移出并获取列表的第一个元素</span><br><span class="line">RPOP key 移除最先插入的元素</span><br><span class="line">LPUSH key value1 [value2]  将一个或多个值插入到列表头部</span><br><span class="line">LPUSHX key value  将一个值插入到已存在的列表头部</span><br></pre></td></tr></table></figure><ul><li>队列（lpop）：右边进左边出</li><li>栈（rpop）：右边进右边出</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/49ae97df965d7d24045df02da67447d9.jpg"></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 [member2] 向集合添加一个或多个成员</span><br><span class="line">SMEMBERS key 返回集合中的所有成员</span><br><span class="line">SPOP key  移除并返回集合中的一个随机元素</span><br></pre></td></tr></table></figure><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p>Redis 有序集合和集合一样也是 String 类型元素的集合，且不允许重复的成员。它是一个 Set，保证了内部 value 的唯一性，另一方面，它可以给每个 value 赋予一个 score，代表这个 value 的排序权重，在 score 相同的情况下，内部还会按照 value 的大小进行排序。它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数</span><br><span class="line">ZCARD key 获取有序集合的成员数</span><br><span class="line">ZRANK key member 获取成员位置</span><br></pre></td></tr></table></figure><h1 id="新增的一些新类型"><a href="#新增的一些新类型" class="headerlink" title="新增的一些新类型"></a>新增的一些新类型</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog 是用来做基数统计的。HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的，因此每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 264 个不同元素的基数。<br>HyperLogLog 提供了两个指令 <code>pfadd</code> 和 <code>pfcount</code>，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去。pfcount 和 scard 用法是一样的，直接获取计数值。<br>缺点：</p><ul><li>精确度。对于数据量大的时候，会出现精确度缺失。</li><li>HyperLogLog 这个数据结构不是免费的，不是说使用这个数据结构要花钱，它需要占据一定 12k 的存储空间，所以它不适合统计单个用户相关的数据。如果你的用户上亿，可以算算，这个空间成本是非常惊人的。但是相比 set 存储方案，HyperLogLog 所使用的空间那真是可以使用千斤对比四两来形容了。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...] //增加</span><br><span class="line"> pfcount key [key ...] //统计</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/dc7a84975378aa5831fad82f08bb32ee.jpg"></p><h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><p>Redis 在 3.2 版本以后增加了地理位置 GEO 模块，意味着我们可以使用 Redis 来实现摩拜单车「附近的 Mobike」、美团和饿了么「附近的餐馆」这样的功能了。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   //添加</span><br><span class="line">&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">&gt;  geoadd company 116.514203 39.905409 ireader</span><br><span class="line">   //计算距离，距离单位可以是 m、km、ml、ft，分别代表米、千米、英里和尺。</span><br><span class="line">&gt;  geodist company juejin ireader km </span><br><span class="line">   // 获取元素位置</span><br><span class="line">&gt; geopos company juejin</span><br><span class="line">   //获取元素的 <span class="built_in">hash</span> 值</span><br><span class="line">&gt; geohash key member</span><br></pre></td></tr></table></figure><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><h2 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h2><p>订阅发布功能</p><h2 id="Transaction（事务）"><a href="#Transaction（事务）" class="headerlink" title="Transaction（事务）"></a>Transaction（事务）</h2><p>Redis 事务功能</p><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>官网上推荐使用Jedis来操作Redis的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //连接本地的 Redis 服务</span><br><span class="line">    Jedis jedis = new Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">    //设置 redis 字符串数据</span><br><span class="line">    jedis.set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    // 获取存储的数据并输出</span><br><span class="line">    System.out.println(<span class="string">&quot;redis 存储的字符串为: &quot;</span>+ jedis.get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，在平时开发中，我们一般都会基于Spring提供的Redis操作进行Redis。我自己练习的时候<a href="https://github.com/tedburner/spring-boot-examples">源码</a>，有兴趣的话可以去下载来看看，这是一个基于springboot的项目，里面集成了很多东西。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 在 Docker 上部署</title>
      <link href="spring-boot-docker/"/>
      <url>spring-boot-docker/</url>
      
        <content type="html"><![CDATA[<p>最近在初步了解Docker，想把 Spring Boot 项目构建成镜像。先介绍下Docker的基本情况。</p><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>Docker是一种开源的应用引擎，使用Go语言开发的。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。<br>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><h2 id="Spring-Boot部署到docker"><a href="#Spring-Boot部署到docker" class="headerlink" title="Spring Boot部署到docker"></a>Spring Boot部署到docker</h2><h3 id="一个简单的springboot项目"><a href="#一个简单的springboot项目" class="headerlink" title="一个简单的springboot项目"></a>一个简单的springboot项目</h3><p>创建springboot项目可以去<a href="http://start.spring.io/">官网入口</a>上直接创建一个项目，或者在idea上面从创建，如果没有该选项，去idea设置里面插件里面去勾线，在重启idea。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/63e34fb739454c5030920d7ad4f33c14.jpg"></p><p>在pom.xml中添加web依赖的jar包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line"> &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个Controller.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/docker&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">docker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Docker!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目的启动项，在浏览器中访问：<code>http://localhost:8080/docker</code>，如果返回: <code>Hello Docker!</code> 则项目成功了。</p><h3 id="SpringBoot中添加Docker支持"><a href="#SpringBoot中添加Docker支持" class="headerlink" title="SpringBoot中添加Docker支持"></a>SpringBoot中添加Docker支持</h3><p>spring boot 支持两种打镜像的方式，一种是Dockerfile，另外一种是直接通过插件构建镜像。除了这两种方式，谷歌提供了一个插件： <a href="https://github.com/GoogleContainerTools/jib">jib</a>，这种方式也是直接通过插件构建镜像，不过这种方式自己还没构建成功过，看国内的教程比较少。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>在pom.xml文件中，新增docker的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;!-- Docker maven plugin --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;imageName&gt;<span class="variable">$&#123;docker.image.prefix&#125;</span>/<span class="variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;</span><br><span class="line">&lt;dockerDirectory&gt;<span class="variable">$&#123;project.basedir&#125;</span>/src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">&lt;directory&gt;<span class="variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;</span><br><span class="line">&lt;include&gt;<span class="variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;!-- Docker maven plugin --&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>添加Dockerfile，文件在main文件下面新增docker文件，入图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/9454d9682aa19fb9b583ff716d14931e.jpg"></p><p>在文件中添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD springboot-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">RUN bash -c <span class="string">&#x27;touch /app.jar&#x27;</span></span><br><span class="line">ENV JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;sh&quot;</span>， <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot;</span> ]</span><br></pre></td></tr></table></figure><p>简单解释下</p><ul><li>FROM，使用Java8为基础，如果本地没有镜像，就从DockerHub拉取</li><li>VOLUME，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录</li><li>ADD，拷贝文件并且重命名</li><li>ENTRYPOINT，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT</li></ul><blockquote><p>这样就把项目依赖Docker的配置弄完了。</p></blockquote><h4 id="直接插件构建镜像"><a href="#直接插件构建镜像" class="headerlink" title="直接插件构建镜像"></a>直接插件构建镜像</h4><p>这种是直接依赖pom.xml里面的插件，直接构建镜像的。jib 插件和这中方式类似，可以看它GitHub上的使用文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Docker maven plugin --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;imageName&gt;<span class="variable">$&#123;docker.image.prefix&#125;</span>/<span class="variable">$&#123;project.artifactId&#125;</span>&lt;/imageName&gt;</span><br><span class="line">        &lt;baseImage&gt;java:8&lt;/baseImage&gt;</span><br><span class="line">        &lt;entryPoint&gt;[<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/<span class="variable">$&#123;project.build.finalName&#125;</span>.jar&quot;</span>]&lt;/entryPoint&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">&lt;directory&gt;<span class="variable">$&#123;project.build.directory&#125;</span>&lt;/directory&gt;</span><br><span class="line">&lt;include&gt;<span class="variable">$&#123;project.build.finalName&#125;</span>.jar&lt;/include&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;!-- Docker maven plugin --&gt;</span><br></pre></td></tr></table></figure><p>这样就可以在本地docker 镜像里面看到这个新的镜像了，不过个人感觉在基于Java8为基础镜像打成的项目镜像，感觉镜像大小有点大，好几百M的大小。</p><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><h3 id="按照docker"><a href="#按照docker" class="headerlink" title="按照docker"></a>按照docker</h3><p>服务器需要先按照Java8，maven，然后下载docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install Docker</span><br></pre></td></tr></table></figure><p>按照后启动docker<code>service docker start</code></p><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>把项目拷贝到你的服务器上面，我是把本地项目上传到GitHub上面，服务器上直接拉取项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入项目</span></span><br><span class="line"><span class="built_in">cd</span> springboot</span><br><span class="line"><span class="comment">#打包</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">java -jar target/springboot-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>启动项目验证是否可以运行项目是否可以在服务器上面运行，然后使用dockerfile构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>构建成功后，使用<code>docker images</code>查看服务器上面是否有该镜像，最后运行镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8081:8081 -t springboot/springboot</span><br></pre></td></tr></table></figure><p>在浏览器上面访问地址就可以了。</p><h2 id="springboot部署到docker是遇到的问题"><a href="#springboot部署到docker是遇到的问题" class="headerlink" title="springboot部署到docker是遇到的问题"></a>springboot部署到docker是遇到的问题</h2><p>一开始我项目的名字是SpringBoot，在创建jar什么的时候都没有问题，但是在mvn clean package docker:build是就报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500 Internal Server Error</span><br></pre></td></tr></table></figure><p>网上找了下，感觉说的都是牛头不对马嘴，没有定位到什么问题，最后在GitHub上面找到了问题的原因，<a href="https://github.com/spotify/docker-maven-plugin#internalservererrorexception-http-500-internal-server-error">问题地址</a>，是说不支持项目的大小写，你需要是小写或者数字，而不是大写字母。原来高了老半天，是大小的问题，涨知识了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html">纯洁微笑</a><br><a href="https://docs.docker-cn.com/get-started/">Docker中国官网</a><br><a href="https://tech.meituan.com/docker_introduction.html">Docker系列之一：入门介绍</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/tedburner/spring-boot-examples">GitHub源码</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— HashMap</title>
      <link href="java-HashMap/"/>
      <url>java-HashMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8  </p></blockquote><p>HashMap 是我们平时开发过程中使用最多的 Java 集合框架之一，它继承 AbstractMap，实现 Map 接口，是一种 key-value，并允许使用空值和空键。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181106170503.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>，<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>从结构实现来讲，HashMap 是 <strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，相比于Java7，Node可以被扩展成TreeNode。</p><h2 id="HashMap类加载"><a href="#HashMap类加载" class="headerlink" title="HashMap类加载"></a>HashMap类加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量为16的大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大容量(1073741824)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//哈希表在其容量自动增加之前可以达到多满的一种尺度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//链表中数据的临界值，如果达到8，就进行resize扩展，如果数组大于64则转换为树.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//如果链表的数据小于6，则从树转换为链表.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//如果数组的size大于64，则把链表进行转化为树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//通过key计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于HashMap初始化的容量是16的原因，可以看<a href="https://juejin.im/post/5a215783f265da431d3c7bba">这里：漫画：什么是HashMap？</a>,<br>感觉讲的还是挺详细的。之所以选择 16 这个数字，是服务于从 key 映射到 index 的算法。index = HashCode(Key) &amp; (length - 1)， 如果 length 是2的幂的话，则 length - 1 就是全是 1的二进制数，比如  16 - 1 = 1111，这样相当于是坐落在长度为 length 的 hashMap 上的位置只和 HashCode 的后四位有关，这只要给出的 HashCode 算法本身分布均匀，算出的index就是分布均匀的。</p><p>可以了解下 <a href="https://juejin.im/post/5a224e1551882535c56cb940">漫画：高并发下的HashMap</a>，不过这里的代码比较老。HashMap 在高并发下出现死锁，主要发生在 rehash 时，链表出现环链了。不过在Java8 中，对于链表超过8时，转化为红黑树，这有效的防止这个问题。</p><h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法被调用的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**省略此处代码...**/</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实例化 HashMap 实例时，如果给定了 初始容量<code>initialCapacity</code>，由于 HashMap 的 capacity 都是 2 的幂，因此这个方法用于找到大于等于 <code>initialCapacity</code> 的最小的2的幂。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Java8中相对之前的版本增加了Node，从代码中可以看出，是一个哈希桶数组，实现<code>Map.Entry</code>接口，是一个键值对。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/563b349d11e9a18a55f91314b7423424.jpg"></p><h3 id="key-和-index"><a href="#key-和-index" class="headerlink" title="key 和 index"></a>key 和 index</h3><p>在 HashMap 中，下标的选择是计算key的hash值，具体公式是：(n - 1 ) &amp; hash 。其中 n 是 hashmap table[] 数组的长度，hash 是当前key的hash值。&amp; 是与运算，两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。详细的可以看之前的那篇链接。</p><h3 id="hasCode-和-equals"><a href="#hasCode-和-equals" class="headerlink" title="hasCode 和 equals"></a>hasCode 和 equals</h3><p>HashMap 重写了 hasCode 和 equals，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCod(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">            Objects.equals(value, e.getValue()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>HashMap 的 hash 计算方法。key的hash值高16位不变，低16位与高16位异或作为key的最终hash值。h&gt;&gt;&gt;16 无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变。异或位运算(0 ^ 1 得 1、1 ^ 1 得 0、0 ^ 0 得 0、1 ^ 0 得 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>HashMap提供三种初始化HashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化16，加载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给定容量，加载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用与指定的Map相同的映射构造一个新的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get相关"><a href="#get相关" class="headerlink" title="get相关"></a>get相关</h2><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//(n-1)&amp;hash 位置不为null</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//遍历红黑树，得到节点值</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//遍历链表，得到节点值，通过hash和equals(key)确认所查找元素。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>put函数是想HashMap中添加键值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table空||length为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;<span class="comment">// 分配空间，初始化</span></span><br><span class="line">    <span class="comment">//hash所在位置(第i个桶)为null，直接put</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//tab[i]有元素，则需要遍历结点后再添加</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// hash、key均等，说明待插入元素和第一个元素相等，直接更新</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//红黑树冲突插入</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;<span class="comment">//死循环，直到break</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//表尾仍没有key相同节点,新建节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//若链表数量大于阀值8【9个】，则调用treeifyBin方法，仅当tab.length大于64才将链表改为红黑树</span></span><br><span class="line">                    <span class="comment">// 如果tab.length&lt;64或table=null，则重构一下链表</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">//binCount&gt;=9则链表转树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">// hash、key均相等，说明此时的节点==待插入节点，更新</span></span><br><span class="line">                p = e;<span class="comment">//更新p指向下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点e = p.next不为null，即链表中原本存在了相同key，则返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//onlyIfAbsent值为false，参数主要决定当该键已经存在时，是否执行替换</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">//调用linkedHashMap,move node to last</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//++size后再检测是否到了阀值</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//调用linkedHashMap,true则possibly remove eldest</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 原hashMap中不存在相同key的键值对，则在插入键值对后，返回null。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//当tab长度小于64的时候，只是扩容，而不是转化成红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>先了解一些字段含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 加载因子实际大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">int</span> size;                 <span class="comment">//实际存在的键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> modCount; <span class="comment">// HashMap被改变的次数</span></span><br></pre></td></tr></table></figure><p>看下源码里面扩容的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table; <span class="comment">//赋值老的Node</span></span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//老的Node的大小</span></span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;  <span class="comment">//旧阀值</span></span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">// 新容量，新阀值</span></span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           <span class="comment">///修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             <span class="keyword">return</span> oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//大于初始容量，旧容量2倍小于最大容量</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//2倍</span></span><br><span class="line">     &#125;<span class="comment">// oldCap=0 ,oldThr&gt;0，threshold(新的扩容resize临界值)</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">         newCap = oldThr;<span class="comment">//新容量=旧阀值（扩容临界值）</span></span><br><span class="line">     <span class="keyword">else</span> &#123; <span class="comment">// oldCap=0 ,oldThr=0，调用默认值来初始化</span></span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//0.75*16</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//新阀值为0，则需要计算新的阀值</span></span><br><span class="line">          <span class="comment">//容量*加载因子</span></span><br><span class="line">         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">         <span class="comment">//新容量&lt;最大容量&amp;&amp;新阀值&lt;最大容量</span></span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr;<span class="comment">//设置新的阀值</span></span><br><span class="line">     <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//创建新的桶</span></span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="comment">// table初始化,bucket copy到新bucket，分链表和红黑树</span></span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 不为空则挨个copy，影响效率！！</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//先赋值再判断</span></span><br><span class="line">                 oldTab[j] = <span class="keyword">null</span>;<span class="comment">//置null，主动GC</span></span><br><span class="line">                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="comment">//1.6 的indexFor，计算key；tableSizeFor性能优化</span></span><br><span class="line">                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//hash&amp;(length-1)</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">//链表，preserve order保持顺序</span></span><br><span class="line">                   <span class="comment">//一个桶中有多个元素，遍历将它们移到新的bucket或原bucket</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//lo原bucket的链表指针</span></span><br><span class="line">                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//hi新bucket的链表指针</span></span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                         next = e.next;</span><br><span class="line">                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//还放在原来的桶</span></span><br><span class="line">                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;<span class="comment">//更新尾指针</span></span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span> &#123;<span class="comment">//放在新桶</span></span><br><span class="line">                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//原bucket位置的尾指针不为空(即还有node)</span></span><br><span class="line">                         loTail.next = <span class="keyword">null</span>;<span class="comment">//链表最后得有个null</span></span><br><span class="line">                         newTab[j] = loHead;<span class="comment">//链表头指针放在新桶的相同下标(j)处</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123; </span><br><span class="line">                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>put(K key, V value)的逻辑：</p><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为TreeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话，同时需要判断 table 数组大小是否大于64，如果只满足前一个条件，只进行扩容；若果两个条件都满足，把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h2 id="JDK7和JDK8之后，HashMap-的区别？"><a href="#JDK7和JDK8之后，HashMap-的区别？" class="headerlink" title="JDK7和JDK8之后，HashMap 的区别？"></a>JDK7和JDK8之后，HashMap 的区别？</h2><ul><li>1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，即在1.7中链表长度超过一定长度后就改成红黑树存储。 </li><li>1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。 </li><li>1.7是采用表头插入法插入链表，1.8采用的是尾部插入法。 </li></ul><p>在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题；在1.8中采用尾部插入法，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://yq.aliyun.com/articles/36812?spm=5176.10695662.1996646101.searchclickresult.5ebd1ca89Rx7bQ&accounttraceid=057ed635-ac64-4fb5-bbe1-f4c9fbc23838">HashMap源码分析（jdk1.8）</a></li><li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合框架 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解虚拟机 —— Java内存区域</title>
      <link href="jvm-memory-area/"/>
      <url>jvm-memory-area/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《深入理解Java虚拟机：JVM高级特性与最佳实践《第二版》读书笔记。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。<br>对于Java开发人员来说，不需要像C++程序员那样去管理内容回收的事情，Java虚拟机会干这些事情。</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。看下图：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20200312150748.png"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。  </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。  </p><p>程序计数器是唯一一个没有 OOM 问题的区域，生命周期随线程的创建而创建，随线程结束而结束。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>和程序计数器一样是<strong>线程私有</strong>的，生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于<strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。   </p><p>Java内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。局部变量表存放了<strong>编译期可知的各种基本数据类型</strong>( boolean、byte、char、 short、int、foat、long、 double)、<strong>对象引用</strong>( reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和 <strong>return Address 类型</strong>(指向了一条字节码指令的地址)。</p><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是已经确定的，在方法运行期间不会改变局部变量表的大小。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈所发挥的作用非常相似，它们之间的区别不过是虚拟机栈为虚拟机执行<strong>Java方法(也就是字节码)服务</strong>，而本地方法栈则为虚拟机使用到的<strong>Native方法服务</strong>。</p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>Java堆是Java虚拟机中管理内存最大的一块。Java堆是<strong>线程共享</strong>的。在虚拟机启动时创建，此内存的唯一目的是存放<strong>对象实例</strong>，几乎所有的对象实例都在这里分配内存。Java虚拟机中的 GC 算法也都在这个内存块。</p><p>堆内存是Java虚拟机中最大的一块有年轻代和老年代组成，年轻代和老年代比例按照1:2，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区(Method Area)与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚批机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap(非堆)，目的应该是与Java堆区分开来。</p><h3 id="永久代-PermGen"><a href="#永久代-PermGen" class="headerlink" title="永久代(PermGen)"></a>永久代(PermGen)</h3><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space” 这个异常。这里的 “PermGen space” 其实指的就是方法区。</p><p>方法区和 PermGen Space 又有本质的区别，前者是 JVM 规范，后者是JVM 规范的一种实现，并且只有 HotSpot 才有 PermGen Space。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。不过在 JDK8 中， HotSpot JVM 将移除永久区。</p><h3 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h3><p>JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称为：<strong>元空间（Metaspace）</strong>。</p><p>方法区是 JVM 的规范，PermGen Space 是JVM规范的一种实现。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间和永久代之间最大的区别：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。元空间的最大可分配空间就是系统可用内存空间。因此，一般不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区的情况。如果不对元空间设置一个可用空间最大值，JVM 会自动根据类的元素大小增加元空间容量。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池存储：</p><ul><li>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法去，此时 HotSpot 虚拟机堆方法区的实现为永久代</li><li>JDK1.7 字符串常量池被从方法区拿到了对重，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区中，也就是 HotSpot 中的永久代</li><li>JDK1.8 HotSpot 用元空间取代永久代，这是字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。  </p><p>本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h1 id="Hotspot-虚拟机对象探秘"><a href="#Hotspot-虚拟机对象探秘" class="headerlink" title="Hotspot 虚拟机对象探秘"></a>Hotspot 虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/9ab0e040567ef22859afaf7146d0402b.jpg"></p><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<a href="https://jlj98.top/jvm-classloader">类的加载</a></p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><p>分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p>为了保证虚拟机指针指向位置的线程安全，有两种可选方案：一种是虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时，才需要同步锁定，可以使用 -XX:+/-UseTLAB参数来设定。</p><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息存放在对象头中，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。new指令执行完后，再按照程序员的意愿执行init方法后，一个真正可用的对象才诞生。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在Hotspot虚拟机中，对象在内存中的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希吗、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 </p><p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。   </p><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的 Reference 数据来操作堆上的具体对象。由于 Reference 类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。日前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><h3 id="句柄池"><a href="#句柄池" class="headerlink" title="句柄池"></a>句柄池</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，Reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/d781e08c95e584fb17b9a89d6db699f0.jpg"></p><h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>如果使用直接指针访问，那么Java堆对像的布局中就必须考虑如何防止访问类型数据的相关信息，Reference 中存储的直接就是对象的地址。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/cd78351b169140932891f4698666d571.jpg"></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版》</li><li><a href="https://juejin.im/post/5ae2fa25518825673d6d0e62">深入理解虚拟机之Java内存区域</a>   </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483949&idx=1&sn=8b69d833bbc805e63d5b2fa7c73655f5&chksm=ebf6da52dc815344add64af6fb78fee439c8c27b539b3c0e87d8f6861c8422144d516ae0a837&scene=21#wechat_redirect">jvm系列(二):JVM内存结构</a></li></ul><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c1ac861e6b434a57d066b4ef1c5da701.jpg" width = "200" height = "200" div align=center />]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架 —— ArrayList 和 LinkedList 的区别</title>
      <link href="java-ArrayList-LinkedList/"/>
      <url>java-ArrayList-LinkedList/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8</p></blockquote><p>先看下List在Collection中的框架图：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/fa325f07dc07c6a16dc557064600fe21.png"></p><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><p>大家基本都知道ArrayList的底层是数组的数据结构，下面来看下它的随机访问、删除等的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//初始容量为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//ArrayList扩容函数方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算当前ArrayList大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//这里我们可以看出，ArrayList每次扩容是增加50%，oldCapacity &gt;&gt; 1是指往左移一位，也就是除以2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据下标index获取元素值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查小标是否越界</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将index位置的值设为element，并返回原来的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向数组中末尾增加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向指定位置index处增加element</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//将index以及index之后的数据复制到index+1的位置往后，即从index开始向后挪了一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据指定的index，删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><p>来看下LinkedList的部分源码，底层是基于双向链表的数据结构。<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//如果index&lt;(size/2),则从前找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则从末尾往前找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接删除某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据下标查询某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//检查下标是否越界</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;<span class="comment">//可以看第一个node的方法，其中有查询</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置index位置处的值为element</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标index位置处新增element</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//index是末尾，则在末尾新增一个</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//这里的插入需要先去查询相应的位置，这会导致性能降低</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><p>平时在看博客的时候，网上很多博客都说，ArrayList基于数组的数据机构，LinkedList是基于链表的数据结构，所以有以下几种特性：<br>1、对于随机查询，ArrayList比LinkedList快<br>2、对于插入或者删除，LinkedList由于是链表，所以是比ArrayList性能更好。<br>通过两者的源码比较，我们发现对于随机查找，ArrayList直接根据下标index查询相对于的值，而LinkedList虽然源码对其做了部分优化，index小于（size/2）,从前往后找，否则从后往前找，即使这样，还是ArrayList比LinkedList快。<br>下面通过实际代码来看下插入的性能比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; linked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//首先分别给两者插入10000条数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        array.add(i);</span><br><span class="line">        linked.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得两者随机访问的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;array get cost time:&quot;</span> + getTime(array));</span><br><span class="line">    System.out.println(<span class="string">&quot;linked get cost time:&quot;</span> + getTime(linked));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得在中间插入数据的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;array insert in first cost time:&quot;</span> + insertArrayListAtFirstTime(array));</span><br><span class="line">    System.out.println(<span class="string">&quot;linked insert cost in first time:&quot;</span> + insertLinkedListAtFirstTime(linked));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得在中间插入数据的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;array insert in middle cost time:&quot;</span> + insertInMiddleTime(array));</span><br><span class="line">    System.out.println(<span class="string">&quot;linked insert cost in middle time:&quot;</span> + insertInMiddleTime(linked));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得尾部插入数据的时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;array insert at last cost time:&quot;</span> + insertAtLastTime(array));</span><br><span class="line">    System.out.println(<span class="string">&quot;linked insert cost at last time:&quot;</span> + insertAtLastTime(linked));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">insertArrayListAtFirstTime</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        list.add(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">insertLinkedListAtFirstTime</span><span class="params">(LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        list.addFirst(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">insertInMiddleTime</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10000000</span>; <span class="comment">//表示要插入的数据量</span></span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        list.add(list.size() &gt;&gt; <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">insertAtLastTime</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1000000</span>; <span class="comment">//表示要插入的数据量</span></span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = Collections.binarySearch(list, list.get(i));</span><br><span class="line">        <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是运行时间:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array get cost time:6</span><br><span class="line">linked get cost time:4170</span><br><span class="line"></span><br><span class="line">array insert <span class="keyword">in</span> first cost time:2927</span><br><span class="line">linked insert cost <span class="keyword">in</span> first time:4</span><br><span class="line"></span><br><span class="line">array insert <span class="keyword">in</span> middle cost time:1887</span><br><span class="line">linked insert cost <span class="keyword">in</span> middle time:124</span><br><span class="line"></span><br><span class="line">array insert at last cost time:23</span><br><span class="line">linked insert cost at last time:92</span><br></pre></td></tr></table></figure><p>这里我们可以看出，对于大数据的随机查询，ArrayList比较快。对于插入，需要区分头插、中间插入和尾插的区别：</p><ul><li>头插：ArrayList 需要做大量的位移和复制操作，而LinkedList的优势就体现出来了，耗时只是实例化一个对象，相对来说，LinkedList 在大量插入的情况下，相对较快。</li><li>中间插入：ArrayList 中间插入，首先我们知道他的定位时间复杂度是O(1)，比较耗时的点在于数据迁移和容量不足的时候扩容。LinkedList 中间插入，链表的数据实际插入时候并不会怎么耗时，但是它定位的元素的时间复杂度是O(n)，所以这部分以及元素的实例化比较耗时。</li><li>尾插：ArrayList 不需要做位移拷贝也就不那么耗时了，而 LinkedList 则需要创建大量的对象。所以这里ArrayList尾插的效果更好一些。</li></ul><p>不过我们从源码比较知道LinkedList性能比较差的原因是因为在中间插入的时候，性能耗在了查询相应的位置上面了，如果只是直接在首插入的话，性能还是ArrayList快。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://segmentfault.com/a/1190000023826724">面经手册 · 第8篇《LinkedList插入速度比ArrayList快？你确定吗？》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> LinkedList </tag>
            
            <tag> Java集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GET、POST、PUT、DELETE的区别</title>
      <link href="net-get-post-put-delete/"/>
      <url>net-get-post-put-delete/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎指正。</p></blockquote><p>今天看到GET/POST/PUT，就想了解下这些的区别。HTTP方法有这几种：GET，POST，PUT和DELETE。</p><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>获取信息。GET请求必须是安全且幂等的，这意味着无论使用相同参数重复多少次，结果都是一样的。对于网上说的，GET请求有长度限制，其实，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。对GET的URL长度限制的是浏览器，这里的限制是URL，而不是参数的限制。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>请求URL中的资源对提供的实体执行某些操作。POST通常用于创建或者更新实体。POST把提交的数据则放置在是HTTP包的包体中。</p><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>将实体存储在URL中。PUT更新现有的实体，或者新增指定的资源(如果id不存在，新增一个含id资源)。PUT请求是幂等的。幂等性是PUT期望与POST请求之间的主要区别。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>请求移除资源; 但是，资源不必立即删除。它可能是一个异步或长时间运行的请求。</p><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>post和get的安全性在传输的层面上区别不大，但是采用url提交数据的get方式容易被人肉眼看到，或者出现在历史纪录里，还是可能被肉眼看到，都是一些本地的问题。</p><h1 id="HTTP-status-codes"><a href="#HTTP-status-codes" class="headerlink" title="HTTP status codes"></a>HTTP status codes</h1><p>查看<a href="https://spring.io/understanding/REST#http-status-codes">spring官网</a>，可以看到这些状态码。</p><ul><li>1XX：informational</li><li>2XX：success：成功信息</li><li>3XX：redirection：重定向问题</li><li>4XX：client error：客户端问题</li><li>5XX：server error：服务端问题</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/25028045">听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？</a></li><li><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/">HTTP协议中GET和POST方法的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String，StringBuilder，StringBuffer 源码分析</title>
      <link href="java-string-source/"/>
      <url>java-string-source/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8</p></blockquote><p>在Java中，对于字符串的操作有这三种：String、StringBuilder、StringBuffer。这三者的效率是：StringBuilder &gt; StringBuffer &gt; String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a = a + <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(builder);</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>先来看下String的源码，如图所示：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/c78a9b82baa1655ad8e9e04c3c1ad686.jpg"></p><p>从图中我们可以看出，<code>String</code> 是由 <code>char</code> 数组构成的，而且有 <code>final</code> 关键字修饰，这说明 <code>String</code> 类型的对象是不可以改变的。那么，平时我们使用“+”来拼接字符串是什么实现的？   </p><p>如上面的代码，首先创建一个 <code>String</code> 对象 <code>a</code>，再把“abc”赋值给它，后面Java虚拟机又创建了一个 <code>String</code> 对象 <code>a</code>，然后再把原来的 <code>a</code> 的值和 “d” 加起来再赋值给新的 <code>a</code>，而原来的<code>a</code> 就会被Java虚拟机的垃圾回收机制（GC）给回收掉了，所以，<code>a</code> 实际上并没有被更改，也就是前面说的 <code>String</code> 对象一旦创建之后就不可更改了。从这里可以看出，对于频繁操作的字符串，不建议使用 <code>String</code> 类型，这将会是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p><p>对于 <code>String</code> 类型对象的“+”操作，通过在 <code>StringBuilder</code> 的 append 方法上面打断点，可以发现对于String的操作，其实是使用了 <code>StringBuilder</code> 的 <code>append</code> 操作，这个不是线程安全。详细可以看下面关于  <code>StringBuilder</code> 的源码。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181120163329.png"></p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181120163349.png"></p><p><code>String</code> 的性能差，主要是对于频繁操作的字符串，不断的创建和销毁对象，对于程序性能有很大的影响。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/bd4156463bd0d33006577d37befd352a.jpg"></p><p>从源码中我们可以看出，对 <code>StringBuffer</code> 来说，底层也是 char 数组。<code>StringBuffer</code> 默认初始空间是16。对于 <code>StringBuffer</code> 的扩容，从下面的这张图上面可以看出，是在旧的数组的2倍上面，再加2进行扩容。  </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/39b7b480af3f3862dfc203102c793a12.jpg">  </p><p>下面我们在来看下 <code>StringBuffer</code> 的操作函数<code>append</code>，<code>append</code> 方法是由 <code>synchronized</code> 修饰的，是线程安全的。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/732cb5d485beefc6ad6c36353d78e73d.jpg"></p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>通过和 <code>StringBuffer</code> 的源码比较，我们发现，底层也是char数组，初始空间也是16。<code>StringBuilder</code> 和 <code>StringBuffer</code> 都是从 <code>AbstractStringBuilder</code> 继承来的，所以对于其初始空间和扩容都是相同的。  </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/0e0a1b93bbc2f10b050b5406afb21e09.jpg"></p><p>对于 <code>StringBuilder</code> 和 <code>StringBuffer</code> 的区别可以从下面的这张图片上看出，对于append()方法，缺少了<code>synchronized</code> 修饰，这使得 <code>StringBuilder</code> 不是一个线程安全。  </p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/84a05816bf159e873f00720901b33ea6.jpg"></p><h2 id="三者性能比较"><a href="#三者性能比较" class="headerlink" title="三者性能比较"></a>三者性能比较</h2><p>我做了个测试，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10000</span>;</span><br><span class="line">    String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        a = a + i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - time);</span><br><span class="line">    <span class="keyword">long</span> time1 = System.currentTimeMillis();</span><br><span class="line">    StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        buffer.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - time1);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">long</span> time2 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        builder.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - time2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下运行的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">405</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>从运行结果，我们可以非常明显的看出这三者的性能比较。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String 长度大小不可变<br>StringBuffer 和 StringBuilder 长度可变<br>StringBuffer 线程安全 StringBuilder 线程不安全<br>因此：<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> StringBuilder </tag>
            
            <tag> StringBuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Java 笔记三</title>
      <link href="read-effective-java-3/"/>
      <url>read-effective-java-3/</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="检查参数的有效性"><a href="#检查参数的有效性" class="headerlink" title="检查参数的有效性"></a>检查参数的有效性</h2><p>绝大多数方法和构造器对于传递给它们的参数值都会有某些限制。例如，索引值必须是非负数，对象引用不能为null，等等，这些都是很常见的。对于参数的校验，可以使用 @NotNull</p><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><p>在Java中，参数类型或者个数不一样，对返回参数没有要求，叫做重载。</p><h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><p>可变参数如下代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int sum(int... args) &#123;</span><br><span class="line">   int sum = 0;</span><br><span class="line">   <span class="keyword">for</span> (int arg : args) &#123;</span><br><span class="line">       sum += arg;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。</p><h2 id="返回零长度的数组或者集合，而不是null"><a href="#返回零长度的数组或者集合，而不是null" class="headerlink" title="返回零长度的数组或者集合，而不是null"></a>返回零长度的数组或者集合，而不是null</h2><p>返回类型为数组或集合的方法没理由返回null，而不是返回一个零长度的数组或者集合。</p><h2 id="为所有导出的API元素编写文档注释"><a href="#为所有导出的API元素编写文档注释" class="headerlink" title="为所有导出的API元素编写文档注释"></a>为所有导出的API元素编写文档注释</h2><p>方便后来者阅读以及使用 API 的用户使用。</p><h1 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h1><h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p>要使局部变量的作用域最小化，最有利的方法就是在第一次使用它的地方声明。如果变量在使用之前声明，这只会造成混乱——对于试图理解程序功能的读者来说，多了一种分散注意力的因素。等到用到该变量的时候，读者可能已经记不起该变量的类型或者初始值了。</p><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><p>这个就是推荐使用下面这种循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Element e: elements)&#123;</span><br><span class="line">doSomething (e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种循环，它的性能比传统的循环，性能更好。for-each循环在简洁性和预防Bug方面有着传统的for循环无法比拟的优势，并且没有性能损失。应该尽可能地使用for-each循环。不过在Java8中，stream 有一种foreach功能，可以试试使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.forEach(input-&gt;&#123;</span><br><span class="line">    //对数组的操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="了解和使用类库"><a href="#了解和使用类库" class="headerlink" title="了解和使用类库"></a>了解和使用类库</h2><p>Java提供了很多的标准库，我们在平时使用的时候，不需要再去造轮子了，可以直接使用，但是在使用的时候，需要注意这些类库的一些使用情况。 </p><h2 id="如果需要精确的答案，请避免使用-float和-double"><a href="#如果需要精确的答案，请避免使用-float和-double" class="headerlink" title="如果需要精确的答案，请避免使用 float和 double"></a>如果需要精确的答案，请避免使用 float和 double</h2><p>如果性能非常关键，并且你又不介意自己记录十进制小数点，而且所涉及的数值又不太大，就可以使用int或者long。如果数值范围没有超过9位十进制数字，就可以使用int;如果不超过18位数字，就可以使用long。如果数值可能超过18位数字，就必须使用 BigDecimal。</p><p>进行货币计算，正确的办法是使用 BigDecimal、int 或者 long。</p><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>基本类型简单，在运行的时候，速度更加快。装箱基本类型在创建的时候，初始是null。</p><h2 id="如果其他类型更适合，则尽量避免使用字符串"><a href="#如果其他类型更适合，则尽量避免使用字符串" class="headerlink" title="如果其他类型更适合，则尽量避免使用字符串"></a>如果其他类型更适合，则尽量避免使用字符串</h2><ul><li>字符串不适合替代其他的值类型</li><li>字符串不适合替代枚举类型</li><li>字符串不适合替代聚合类型</li><li>字符串不适合替代能力表</li></ul><h2 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h2><p>可以查看<a href="https://jlj98.top/java-String-source/">String，StringBuilder，StringBuffer源码分析</a>。</p><h2 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h2><h2 id="接口优先于反射机制"><a href="#接口优先于反射机制" class="headerlink" title="接口优先于反射机制"></a>接口优先于反射机制</h2><h2 id="谨慎地使用本地方法"><a href="#谨慎地使用本地方法" class="headerlink" title="谨慎地使用本地方法"></a>谨慎地使用本地方法</h2><p>本地方法（native method），指的是用本地程序设计语言（比如 C 或者 C++）来编写的特殊方法，有 native 修饰的。</p><h2 id="谨慎地进行优化"><a href="#谨慎地进行优化" class="headerlink" title="谨慎地进行优化"></a>谨慎地进行优化</h2><h2 id="遵守普遍接受的命名惯例"><a href="#遵守普遍接受的命名惯例" class="headerlink" title="遵守普遍接受的命名惯例"></a>遵守普遍接受的命名惯例</h2><p><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/Java_1512024443940.pdf">可以参考阿里巴巴的Java手册</a>。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h2><p>对于程序，能够通过代码解决的问题，不要丢给异常来处理。</p><h2 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><h2 id="避免不必要地使用受检的异常"><a href="#避免不必要地使用受检的异常" class="headerlink" title="避免不必要地使用受检的异常"></a>避免不必要地使用受检的异常</h2><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/60b96ac2d795023302ab8e8ecf56c543.jpg"></p><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><h2 id="每个方法抛出的异常都要有文档"><a href="#每个方法抛出的异常都要有文档" class="headerlink" title="每个方法抛出的异常都要有文档"></a>每个方法抛出的异常都要有文档</h2><p>使用 Javadoc 的 @throws 标签记录下一个方法可能拋出的每个未受检异常，但是不要使用 throws 关键字将未受检的异常包含在方法的声明中。</p><h2 id="在细节消息中包含能捕获失败的信息"><a href="#在细节消息中包含能捕获失败的信息" class="headerlink" title="在细节消息中包含能捕获失败的信息"></a>在细节消息中包含能捕获失败的信息</h2><h2 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h2><h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><p>对于异常，需要解决。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><p>这会导致程序整体性能下降。为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽量限制同步区域内部的工作量。当你在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。在现在现在多核的时代，这比永远不要过度同步来得更重要。</p><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><p>使用线程池。<a href="https://jlj98.top/java-thread-pool/">多线程编程 —— 线程池</a></p><h2 id="并发工具优先于-wait-和-notify"><a href="#并发工具优先于-wait-和-notify" class="headerlink" title="并发工具优先于 wait 和 notify"></a>并发工具优先于 wait 和 notify</h2><p>在 <code>java.util.concurrent</code> 工具包下，提供了一些并发工具类，比如 CountDownLatch 和 Semaphore。可以参考<a href="https://jlj98.top/java-CyclicBarrier-CountDownLatch/">CyclicBarrier、CountDownLatch 和 Semaphore 的比较</a></p><h2 id="线程安全性的文档化"><a href="#线程安全性的文档化" class="headerlink" title="线程安全性的文档化"></a>线程安全性的文档化</h2><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><h2 id="避免使用线程组"><a href="#避免使用线程组" class="headerlink" title="避免使用线程组"></a>避免使用线程组</h2><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="谨慎地实现-Serializable-接口"><a href="#谨慎地实现-Serializable-接口" class="headerlink" title="谨慎地实现 Serializable 接口"></a>谨慎地实现 Serializable 接口</h2><p>实现 Serializable 接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。如果一个类实现 Serializable 接口，它的字节流编码就变成了它的导出 API 的一部分。如果使用这个类，就必须支持这种序列化。</p><p>第二个代价是增加了出现 Bug 和安全漏洞的可能性。</p><p>第三个代价是随着类的发行新的版本，相关的测试负担也增加了。</p><p>PS：对于这一点，不是很明白。</p><h2 id="考虑使用自定义的序列化形式"><a href="#考虑使用自定义的序列化形式" class="headerlink" title="考虑使用自定义的序列化形式"></a>考虑使用自定义的序列化形式</h2><h2 id="保护性地编写-readobject-方法"><a href="#保护性地编写-readobject-方法" class="headerlink" title="保护性地编写 readobject 方法"></a>保护性地编写 readobject 方法</h2><h2 id="对于实例控制，枚举类型优先于-readResolve"><a href="#对于实例控制，枚举类型优先于-readResolve" class="headerlink" title="对于实例控制，枚举类型优先于 readResolve"></a>对于实例控制，枚举类型优先于 readResolve</h2><h2 id="考虑用序列化代理代替序列化实例"><a href="#考虑用序列化代理代替序列化实例" class="headerlink" title="考虑用序列化代理代替序列化实例"></a>考虑用序列化代理代替序列化实例</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Java 笔记二</title>
      <link href="read-effective-java-2/"/>
      <url>read-effective-java-2/</url>
      
        <content type="html"><![CDATA[<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><p>1、尽可能地使每个类或者成员不被外界访问。换句话说，应该使用与你正在编写的软件的对应功能相一致的、尽可能最小的访问级别。例如，想在实体类的中，使用private定义属性值。</p><h2 id="在公有类中使用访问方法而非公有域"><a href="#在公有类中使用访问方法而非公有域" class="headerlink" title="在公有类中使用访问方法而非公有域"></a>在公有类中使用访问方法而非公有域</h2><h2 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h2><h3 id="不要提供任何会修改对象状态的方法-也称为-mutator"><a href="#不要提供任何会修改对象状态的方法-也称为-mutator" class="headerlink" title="不要提供任何会修改对象状态的方法(也称为 mutator)"></a>不要提供任何会修改对象状态的方法(也称为 mutator)</h3><h3 id="保证类不会被扩展。"><a href="#保证类不会被扩展。" class="headerlink" title="保证类不会被扩展。"></a>保证类不会被扩展。</h3><p>这样可以防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法是使这个类成为 final的，但是后面我们还会讨论到其他的做法。</p><h3 id="使所有的域都是final的。"><a href="#使所有的域都是final的。" class="headerlink" title="使所有的域都是final的。"></a>使所有的域都是final的。</h3><p>通过系统的强制方式，这可以清楚地表明你的意图。而且，如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必需确保正确的行为，正如内存模型( memory model)中所述。</p><h3 id="使所有的域都成为私有的。"><a href="#使所有的域都成为私有的。" class="headerlink" title="使所有的域都成为私有的。"></a>使所有的域都成为私有的。</h3><p>这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。虽然从技术上讲，允许不可变的类具有公有的 final域，只要这些域包含基本类型的值或者指向不可变对象的引1用，但是不建议这样做，因为这样会使得在以后的版本中无法再改变内部的表示法(见第13条)。</p><h3 id="确保对于任何可变组件的互斥访问。"><a href="#确保对于任何可变组件的互斥访问。" class="headerlink" title="确保对于任何可变组件的互斥访问。"></a>确保对于任何可变组件的互斥访问。</h3><p>如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法( accessor)中返回该对象引用。在构造器、访问方法和readobject方法(见第76条)中请使用保护性拷贝( defensive copy)技术(见第39条)。</p><h2 id="复合优先于继承"><a href="#复合优先于继承" class="headerlink" title="复合优先于继承"></a>复合优先于继承</h2><p>不要出现跨包继承。</p><h2 id="要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="要么为继承而设计，并提供文档说明，要么就禁止继承"></a>要么为继承而设计，并提供文档说明，要么就禁止继承</h2><h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><p>通过 implements 来实现接口，可以多实现。</p><h2 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h2><h2 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h2><h2 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h2><h2 id="优先考虑静态成员类"><a href="#优先考虑静态成员类" class="headerlink" title="优先考虑静态成员类"></a>优先考虑静态成员类</h2><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="请不要在新代码中使用原生态类型"><a href="#请不要在新代码中使用原生态类型" class="headerlink" title="请不要在新代码中使用原生态类型"></a>请不要在新代码中使用原生态类型</h2><p>每个泛型都定义一个原生态类型(raw type)，即不带任何实际类型参数的泛型名称。例如，与List<E>相对应的原生态类型是List。原生态类型就像从类型声明中删除了所有泛型信息一样。实际上，原生态类型List与Java平台没有泛型之前的接口类型List完全一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Object o = new Object();</span><br><span class="line">list.add(o);//这里会报错</span><br></pre></td></tr></table></figure><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/f417ecefc97980c424ab3458b0002df5.jpg"></p><h2 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h2><p>尽可能的消除代码中的警告信息。如果无法消除警告，同时可以证明引起警告的代码是类型安全的，(只有在这种情况下才)可以用一个@ SuppressWarnings(“unchecked”)注解来禁止这条警告。</p><h2 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h2><h2 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h2><h2 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h2><h2 id="利用有限制通配符来提升AP的灵活性"><a href="#利用有限制通配符来提升AP的灵活性" class="headerlink" title="利用有限制通配符来提升AP的灵活性"></a>利用有限制通配符来提升AP的灵活性</h2><h2 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h2><h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h2><p>很多常亮不需要定义一大推，只需要使用枚举，定义一个就好了。</p><h2 id="用-EnumSet代替位域"><a href="#用-EnumSet代替位域" class="headerlink" title="用 EnumSet代替位域"></a>用 EnumSet代替位域</h2><h2 id="用接口模拟可伸缩的枚举"><a href="#用接口模拟可伸缩的枚举" class="headerlink" title="用接口模拟可伸缩的枚举"></a>用接口模拟可伸缩的枚举</h2><h2 id="用标记接囗定义类型"><a href="#用标记接囗定义类型" class="headerlink" title="用标记接囗定义类型"></a>用标记接囗定义类型</h2><p>标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定。如果注解类型利用@Target( ElementType.TYPE)声明，它就可以被应用到任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它将唯一的接口扩展成它适用的接口。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Java 笔记一</title>
      <link href="read-effective-java-1/"/>
      <url>read-effective-java-1/</url>
      
        <content type="html"><![CDATA[<p>最近比较空，就抽时间看了《Efffectice Java》这本书，虽然这本书的第二版和现在的Java版本有点老了，但是看了一遍后，感觉，其中的一些思想，平时写代码的时候需要注意的地方，还是讲的不错的。</p><h2 id="用静态工厂方法代替构造器"><a href="#用静态工厂方法代替构造器" class="headerlink" title="用静态工厂方法代替构造器"></a>用静态工厂方法代替构造器</h2><p>对于Map的new，在Java的后面的版本中，已经修改了，不需要如书上说的创建一个newMap的静态工厂类，可以如下进行创建一个新的Map:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><h3 id="重叠构造器模式"><a href="#重叠构造器模式" class="headerlink" title="重叠构造器模式"></a>重叠构造器模式</h3><p>这种模式就是利用重载，不断调用构造函数，生成需要的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="comment">//必要的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> one;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> two;</span><br><span class="line">    <span class="comment">//可选的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> three;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> four;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass1</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(one,two,three,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> three,<span class="keyword">int</span> four)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.one=one;</span><br><span class="line">        <span class="keyword">this</span>.two=two;</span><br><span class="line">        <span class="keyword">this</span>.three=three;</span><br><span class="line">        <span class="keyword">this</span>.four=four;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; one=&quot;</span>+<span class="keyword">this</span>.one+<span class="string">&quot; two=&quot;</span>+<span class="keyword">this</span>.two+<span class="string">&quot; three=&quot;</span>+<span class="keyword">this</span>.three+<span class="string">&quot; four=&quot;</span>+<span class="keyword">this</span>.four;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这代代码可以看出，这种写法有点复杂，个人觉得实际开发中，不会去使用</p><h3 id="JavaB-ean"><a href="#JavaB-ean" class="headerlink" title="JavaB ean"></a>JavaB ean</h3><p>使用创建对象，通过set来设置参数，这种也是在实际开发中，使用最多的。但是如果存在很多歌参数需要set，那就有点麻烦了，所以推荐builder模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.setNation(<span class="string">&quot;China&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用builder模式"><a href="#使用builder模式" class="headerlink" title="使用builder模式"></a>使用builder模式</h3><p>在编辑器idea中，提供了丰富的插件，其中有一款Builder Generator的插件，提供了builder模式。这种生成的对象，可以选择参数。如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builder模式就是种不错的选择，特别是当大多数参数都是可选的时候。这种模式结合了重叠和JavaBeans的模式，在开发中可以使用。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/19d5913a6ce2ea1603ab8e3cedcc46f1.jpg"></p><p>使用builder模式的时候，只要如下代码使用就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDTO builder = SimpleDTO.SimpleDTOBuilder.aSimpleDTO()</span><br><span class="line">                .withId(<span class="number">1</span>)</span><br><span class="line">                .withName(<span class="string">&quot;金华市&quot;</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h2><p>Singleton在设计模式中，指的是单例模式。只需要初始化一次，之后就不需要再创建对象了。</p><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在项目中，对于String的属性，若改变量存在频繁的操作，就选择StringBuilder或者StringBuffer这两个。因为String定义的变量是不可变的，在执行+来修改变量的时候，String变量重新new一个String对象实例。<a href="https://jlj98.top/java-String-source/">详情</a>。</p><h3 id="使用静态工厂方法"><a href="#使用静态工厂方法" class="headerlink" title="使用静态工厂方法"></a>使用静态工厂方法</h3><p>对于同时提供了静态工厂方法(见第1条)和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如，静态工厂方法 Boolean. valueof( String)几乎总是优先于构造器 Boolean( String)。构造器在每次被调用的时候都会创建一个新的对象，而静态工厂方法则从来不要求这样做，实际上也不会这样做。</p><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><p>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。类型对象需要不断的创建。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/e14ba87db4b431332b52c0007f29059c.jpg"></p><h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><h2 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h2><p>终结方法( finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。当然，终结方法也有其可用之处，但是根据经验，应该避免使用终结方法。</p><h2 id="覆盖-equals时请遵守通用约定"><a href="#覆盖-equals时请遵守通用约定" class="headerlink" title="覆盖 equals时请遵守通用约定"></a>覆盖 equals时请遵守通用约定</h2><h2 id="覆盖-equals时总要覆盖-hashCode"><a href="#覆盖-equals时总要覆盖-hashCode" class="headerlink" title="覆盖 equals时总要覆盖 hashCode"></a>覆盖 equals时总要覆盖 hashCode</h2><h2 id="始终要覆盖-toString"><a href="#始终要覆盖-toString" class="headerlink" title="始终要覆盖 toString"></a>始终要覆盖 toString</h2><p>在实体类的创建的时候，记得覆盖 toString，这样在打印日志什么的时候，就可以在日志中看到实体类中的具体数据了，而不是出现“实体类@163b91”这种日志了。</p><h2 id="谨慎地覆盖clone"><a href="#谨慎地覆盖clone" class="headerlink" title="谨慎地覆盖clone"></a>谨慎地覆盖clone</h2><p>这个clone还没使用过，这几天详细的去看下。</p><h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2><p>在Java8中的Stream中，新增了一些排序的功能，<a href="http://jlj98.top/Java-Stream/">详情</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream的介绍</title>
      <link href="java-stream/"/>
      <url>java-stream/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文使用JDK1.8</p></blockquote><p>Java8提供了丰富的lambda的API。今天我们来讲讲关于其中的stream（流的操作）。对于List集合，有了stream的流操作，感觉如虎添翼。</p><h2 id="生成一个List"><a href="#生成一个List" class="headerlink" title="生成一个List"></a>生成一个List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;1,2,3,4,10,11,9,66,222,12&quot;</span>;</span><br><span class="line">List&lt;Integer&gt; list = Stream.of(str.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .map(Integer::valueOf)</span><br><span class="line">                .filter(x-&gt; !Objects.equals(x,<span class="number">3</span>))</span><br><span class="line">                .sorted(Comparator.reverseOrder())</span><br><span class="line">                .limit(<span class="number">4</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上面的代码Stream.of 为我们生成了一个List<String>，但是我们需要的Integer，所以我们还需要使用<strong>map</strong>来转换类型。然后对于生成的列表，我们不想要其中的3，于是我们使用<strong>filter</strong>来过滤掉列表中的3。对于现在列表我们又想是倒序后的列表的前四条数据，于是我们在使用<strong>sorted</strong>来对列表来进行倒序后，再使用<strong>limit</strong>取前四条。顺便说一句，对于比较，推荐使用Objects.equals(a,b).<br>下面来简单的介绍下stream。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map：对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素<br>map方法是对列表里面的对象的转换，比如上面的map的功能是吧String转换成Integer。除了这样的转换，你也可以对对象进行你需要的操作。比如现在有一个对象ListDTO:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDTO</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListDTO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListDTO</span><span class="params">(Integer id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这么一个List<ListDTO>，你现在只想得到这个列表中ListDTO对象里面的id，现在你就可以这样操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = beans.stream().map(ListDTO::getId).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>如果你想要得到name的列表，也可以进行上面类似的操作。下面对List列表的元素先转换成大写，在用逗号把元素拼接起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串换成大写并用逗号拼接起来</span></span><br><span class="line">List&lt;String&gt; G7 = Arrays.asList(<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;France&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;Italy&quot;</span>, <span class="string">&quot;U.K.&quot;</span>,<span class="string">&quot;Canada&quot;</span>);</span><br><span class="line">String G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(G7Countries);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>类似于map，但是flatMap是对Stream之间的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[][] data = <span class="keyword">new</span> String[][]&#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;, &#123;<span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;&#125;;</span><br><span class="line">Stream&lt;String[]&gt; temp = Arrays.stream(data);</span><br><span class="line">Stream&lt;String[]&gt; stream = temp.filter(x -&gt; <span class="string">&quot;a&quot;</span>.equals(x.toString()));</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count()是对列表的聚合，统计列表的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long count = list.stream().count();</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>distinct是对stream里面的元素进行去重，有点类似于SQL里面的distinct去重</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素</p><h2 id="stream-生成-map"><a href="#stream-生成-map" class="headerlink" title="stream 生成 map"></a>stream 生成 map</h2><p>上面我们介绍了stream里面的toList()，下面我们来介绍下如何使用stream直接生成map，而不是像以前一样，需要循环后再一个一个的put进map。虽然我们也可以第三方的jar生成Map，比如Google的某些jar，使用里面的Maps.uniqueIndex()也可以直接把List转换成Map。</p><h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><p>利用Collectors里面的toMap对List列表转换Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种toMap，当出现Key相同时，会出现 Duplicate key 问题</span></span><br><span class="line">Map&lt;Integer,String&gt; beanMap = beans.stream()</span><br><span class="line">                .collect(Collectors.toMap(x-&gt;x.getId(), m-&gt;m.getName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决key冲突问题，使用新的value替换原来的value</span></span><br><span class="line">Map&lt;Integer, String&gt; map = beans.stream()</span><br><span class="line">    .collect(Collectors.toMap(SimpleDTO::getId, SimpleDTO::getName, (v1, v2) -&gt; v2));</span><br></pre></td></tr></table></figure><p>前者的toMap使用的是 throwingMerger，在出现key相同时，抛出异常；后者的toMap使用的是mergeFunction，如示例中，如果出现key相同的元素，新的key能覆盖旧的。</p><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><p>利用Collectors里面的groupingBy，可以对列表进行分组，总和和排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; items = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;papaya&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Long&gt; result = items</span><br><span class="line">            .stream()</span><br><span class="line">            .collect(Collectors</span><br><span class="line">                    .groupingBy(Function.identity(), Collectors.counting()));</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    Map&lt;String, Long&gt; finalMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//sort a map and add to finalMap</span></span><br><span class="line">    result.entrySet().stream()</span><br><span class="line">            .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue()</span><br><span class="line">                    .reversed()).forEachOrdered(e -&gt; finalMap.put(e.getKey(), e.getValue()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据value 倒叙</span></span><br><span class="line">    Map&lt;String, SimpleDTO&gt; sampleMap = BeanData.getDataList()</span><br><span class="line">            .stream().collect(Collectors.toMap(SimpleDTO::getName, m-&gt;m));</span><br><span class="line">    Map&lt;String, SimpleDTO&gt; newMap = sampleMap.entrySet().stream()</span><br><span class="line">            .sorted(Map.Entry.comparingByValue((o1, o2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getAge() &gt; o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (o1.getAge() &lt; o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;)).collect(Collectors.toMap(</span><br><span class="line">                    Map.Entry::getKey,</span><br><span class="line">                    Map.Entry::getValue,</span><br><span class="line">                    (o1, o2) -&gt; o1,</span><br><span class="line">                    LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(newMap);</span><br><span class="line">    <span class="comment">// map 根据key正序排列</span></span><br><span class="line">    Map&lt;String, SimpleDTO&gt; keyMap = sampleMap.entrySet().stream()</span><br><span class="line">            .sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(</span><br><span class="line">                    Map.Entry::getKey,</span><br><span class="line">                    Map.Entry::getValue,</span><br><span class="line">                    (o1, o2) -&gt; o1,</span><br><span class="line">                    LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(keyMap);</span><br><span class="line"></span><br><span class="line">    System.out.println(finalMap);</span><br><span class="line">    <span class="comment">//数据统计</span></span><br><span class="line">    List&lt;SimpleDTO&gt; beans = BeanData.getBeanDataList();</span><br><span class="line">    Map&lt;Integer, Long&gt; countMap = beans</span><br><span class="line">            .stream().collect(</span><br><span class="line">                    Collectors.groupingBy(SimpleDTO::getId, Collectors.counting()));</span><br><span class="line">    System.out.println(countMap);</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;SimpleDTO&gt;&gt; listMap = beans.stream().collect(</span><br><span class="line">            Collectors.groupingBy(SimpleDTO::getId));</span><br><span class="line">    System.out.println(JSON.toJSON(listMap));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Map 的value值自行聚合</span></span><br><span class="line">    Map&lt;Integer, Set&lt;String&gt;&gt; setMap = beans.stream().collect(</span><br><span class="line">            Collectors.groupingBy(SimpleDTO::getId, Collectors.mapping(SimpleDTO::getName, Collectors.toSet()))</span><br><span class="line">    );</span><br><span class="line">    System.out.println(JSON.toJSON(setMap));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Map的value重新聚合一个新的对象</span></span><br><span class="line">    Map&lt;Integer, List&lt;UserDTO&gt;&gt; collectMap = beans.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(SimpleDTO::getId,</span><br><span class="line">                    Collectors.collectingAndThen(Collectors.toList(), input -&gt; input.stream()</span><br><span class="line">                            .map(m -&gt; &#123;</span><br><span class="line">                                UserDTO user = <span class="keyword">new</span> UserDTO();</span><br><span class="line">                                user.setId(m.getId());</span><br><span class="line">                                user.setUsername(m.getName());</span><br><span class="line">                                <span class="keyword">return</span> user;</span><br><span class="line">                            &#125;).collect(Collectors.toList())</span><br><span class="line">                    )));</span><br><span class="line">    System.out.println(JSON.toJSON(collectMap));</span><br><span class="line"></span><br><span class="line">    SimpleDTO dto1 = <span class="keyword">new</span> SimpleDTO(<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    SimpleDTO dto2 = <span class="keyword">new</span> SimpleDTO(<span class="number">2</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    SimpleDTO dto3 = <span class="keyword">new</span> SimpleDTO(<span class="number">3</span>, <span class="string">&quot;Hangzhou&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    SimpleDTO dto4 = <span class="keyword">new</span> SimpleDTO(<span class="number">3</span>, <span class="string">&quot;Hangzhou&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">    List&lt;SimpleDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(dto1);</span><br><span class="line">    list.add(dto2);</span><br><span class="line">    list.add(dto3);</span><br><span class="line">    list.add(dto4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自行拼接KEY</span></span><br><span class="line">    Map&lt;String, List&lt;SimpleDTO&gt;&gt; mapKey = list.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(e -&gt; fetchGroupKey(e)));</span><br><span class="line">    System.out.println(mapKey);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">fetchGroupKey</span><span class="params">(SimpleDTO dto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dto.getId() + <span class="string">&quot;_&quot;</span> + dto.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总和"><a href="#总和" class="headerlink" title="总和"></a>总和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; items = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;papaya&quot;</span>);</span><br><span class="line">Map&lt;String,Long&gt; result = items.stream()</span><br><span class="line">                                .collect(Collectors</span><br><span class="line">                                .groupingBy(Function.identity(),Collectors.counting()));</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;papaya=1, banana=1, orange=2, Apple=3&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; finalMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//Sort a map and add to finalMap</span></span><br><span class="line">        result.entrySet().stream()</span><br><span class="line">                .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue()</span><br><span class="line">                        .reversed()).forEachOrdered(e -&gt; finalMap.put(e.getKey(), e.getValue()));</span><br><span class="line">System.out.println(finalMap);</span><br></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>现在有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ListDTO&gt; <span class="title">getBeanDataList</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;ListDTO&gt; listDTOS = Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> ListDTO(<span class="number">1</span>,<span class="string">&quot;孙博&quot;</span>), <span class="keyword">new</span> ListDTO(<span class="number">1</span>,<span class="string">&quot;二代&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">1</span>,<span class="string">&quot;孙博&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> ListDTO(<span class="number">2</span>,<span class="string">&quot;戴硕&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">2</span>,<span class="string">&quot;戴硕&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">2</span>,<span class="string">&quot;赛克&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> ListDTO(<span class="number">3</span>,<span class="string">&quot;二代&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">3</span>,<span class="string">&quot;路痴&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">3</span>,<span class="string">&quot;路痴&quot;</span>),</span><br><span class="line">      <span class="keyword">new</span> ListDTO(<span class="number">4</span>,<span class="string">&quot;赛克&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">4</span>,<span class="string">&quot;二代&quot;</span>),<span class="keyword">new</span> ListDTO(<span class="number">4</span>,<span class="string">&quot;路痴&quot;</span>)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>下面更加其中的ID作为Map的key，对上面的List进行Map.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,List&lt;ListDTO&gt;&gt; listMap = beans.stream().collect(</span><br><span class="line">                Collectors.groupingBy(ListDTO::getId));</span><br></pre></td></tr></table></figure><p>把对象中的name取出并塞到一个Set中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Set&lt;String&gt;&gt; setMap = beans.stream().collect(</span><br><span class="line">Collectors.groupingBy(ListDTO::getId,Collectors.mapping(ListDTO::getName,Collectors.toSet()))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>现在需要对上面的集合，根据ID，对数据进行统计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Long&gt; countMap = beans</span><br><span class="line">                .stream().collect(</span><br><span class="line">          Collectors.groupingBy(ListDTO::getId,Collectors.counting())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Stream-和-parallelStream"><a href="#Stream-和-parallelStream" class="headerlink" title="Stream 和 parallelStream"></a>Stream 和 parallelStream</h2><p><code>Stream</code> 是普通的对流操作，而 <code>parallelStream</code> 是对集合进行并发操作，看下面的对两者的简单比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        SimpleDTO dto = <span class="keyword">new</span> SimpleDTO();</span><br><span class="line">        dto.setId(i);</span><br><span class="line">        dto.setName(<span class="string">&quot;测试员&quot;</span> + i + <span class="string">&quot;号&quot;</span>);</span><br><span class="line">        dto.setContent(<span class="string">&quot;Stream 测试普通和并行的效率&quot;</span>);</span><br><span class="line">        list.add(dto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;SimpleDTO&gt; testList = list;</span><br><span class="line"></span><br><span class="line">    Long stattTime = System.currentTimeMillis();</span><br><span class="line">    List&lt;String&gt; list1 = list.stream()</span><br><span class="line">            .filter(x -&gt; x.getId() &gt; <span class="number">1000</span>)</span><br><span class="line">            .map(SimpleDTO::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    Long endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;stream 耗时：&quot;</span> + (endTime - stattTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list2 = testList.parallelStream()</span><br><span class="line">            .filter(x -&gt; x.getId() &gt; <span class="number">1000</span>)</span><br><span class="line">            .map(SimpleDTO::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    Long endTime1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream 耗时：&quot;</span> + (endTime1 - endTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream 耗时：77ms</span><br><span class="line">parallelStream 耗时：19ms</span><br></pre></td></tr></table></figure><p>从最终的耗时可以看出，对于 <code>parallelStream</code> 处理大量数据的时候，效率还是有很大的提升的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上面安装Python3</title>
      <link href="mac-homebrew-python/"/>
      <url>mac-homebrew-python/</url>
      
        <content type="html"><![CDATA[<p>之前Mac上面使用Python都是使用系统自带的Python，哈哈。。。使用Mac的知道，Mac上面已经安装了Python2.7，这个是Mac系统需要的。现在Python有两个版本，2.x和3.x。Python2.7支持延迟时间是到2020年，2.7是2.x系列的最后一个版本，之后将不再更新了。虽然这两个版本很相似，只是语法上面有点差别。所有，如果现在学Python的话，还是下载Python3来学习吧。</p><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>在Mac上面安装一些软件，还是在Homebrew下面安装吧，像Git，mysql，node.js等，都可以在homebrew里面安装，这样安装卸载都方便，只需要brew install/uninstall &lt;软件名字&gt;</p><h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><p>安装Homebrew之前，需要安装Xcode，这个可以到APP Store里面去下载。</p><h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><p>1.到<a href="https://brew.sh/index_zh-tw.html">Homebrew</a>官网去下载<br>2.在命令终端里面下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><p>homebrew的一些基本命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brew search &lt;pkg_name&gt; <span class="comment">#查找软件包</span></span><br><span class="line">$ brew install &lt;pkg_name&gt; <span class="comment">#安装软件包</span></span><br><span class="line">$ brew list <span class="comment">#列出软件包</span></span><br><span class="line">$ brew uninstall &lt;pkg_name&gt; <span class="comment">#卸载软件包</span></span><br><span class="line">$ brew info &lt;pkg_name&gt; <span class="comment">#查看软件包的基本资料</span></span><br><span class="line">$ brew update <span class="comment"># 更新 Homebrew 的信息</span></span><br><span class="line">$ brew outdated <span class="comment"># 看一下哪些软件可以升级</span></span><br><span class="line">$ brew upgrade &lt;xxx&gt; <span class="comment"># 如果不是所有的都要升级，那就这样升级指定的</span></span><br><span class="line">$ brew upgrade; brew cleanup <span class="comment"># 如果都要升级，直接升级完然后清理干净</span></span><br></pre></td></tr></table></figure><p>查询homebrew下的Python</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search Python</span><br></pre></td></tr></table></figure><p>安装Python</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install Python3</span><br></pre></td></tr></table></figure><p>安装后的Python3在/usr/local/Cellar/python3/3.6.3</p><h2 id="安装Python3时碰到的问题"><a href="#安装Python3时碰到的问题" class="headerlink" title="安装Python3时碰到的问题"></a>安装Python3时碰到的问题</h2><p>我在安装的时候碰到了 <code>Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks</code> 的问题。看着好像是在安装Python3的时候，因为权限问题，不能创建Frameworks文件夹。于是我去GitHub上面的HomeBrew上面去找问题。<a href="https://github.com/Homebrew/homebrew-core/issues/20985">网址</a>上面有类似的答案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/Frameworks</span><br><span class="line">sudo chown -R $(whoami) /usr/<span class="built_in">local</span>/*</span><br></pre></td></tr></table></figure><p>然后在使用 <code>brew install python3</code> 安装。然后使用which python3 查看是否安装。<br>如果使用PyCharm的话，需要自己去找你安装Python3目录下的python3文件。</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8中的时间</title>
      <link href="java-time/"/>
      <url>java-time/</url>
      
        <content type="html"><![CDATA[<p>相比较于之前的版本之前的版本，增加了很大新特性，其中关于时间多了很多功能：LocalDateTime，LocalDate，LocalTime。</p><h2 id="时间介绍"><a href="#时间介绍" class="headerlink" title="时间介绍"></a>时间介绍</h2><p>LocalDate是年月日；LocalTime是时分秒；LocalDateTime则是两者的合并，可以通过下面得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure><p>Java8对这几个时间提供了丰富的时间计算接口。<br>关于Date和String之间的转化，我这里就不多说了</p><h3 id="String-–-gt-LocalDate-LocalTime-LocalDateTime"><a href="#String-–-gt-LocalDate-LocalTime-LocalDateTime" class="headerlink" title="String –&gt; LocalDate/LocalTime/LocalDateTime"></a>String –&gt; LocalDate/LocalTime/LocalDateTime</h3><p>String类型转化新特性时间可以使用 DateTimeFormatter 功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateformatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">LocalDate ld = LocalDate.parse(<span class="string">&quot;2017-08-01&quot;</span>, dateformatter);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">LocalDateTime ldt = LocalDateTime.parse(<span class="string">&quot;2017-09-22 11:30:10&quot;</span>, df);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String time = <span class="string">&quot;11:30:10&quot;</span>;</span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">LocalTime lt = LocalTime.parse(time,df);</span><br></pre></td></tr></table></figure><p>但是在转化的时候要注意了，你不能把“2017-08-01”的String转化成LocalDateTime/LocalTime，不然会报错，需要他们代表时间的范围。</p><h3 id="Date-–-gt-LocalDate-LocalTime-LocalDateTime"><a href="#Date-–-gt-LocalDate-LocalTime-LocalDateTime" class="headerlink" title="Date –&gt;  LocalDate/LocalTime/LocalDateTime"></a>Date –&gt;  LocalDate/LocalTime/LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">Instant instant = date.toInstant();</span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);<span class="comment">//转化成LocalDateTime</span></span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate();<span class="comment">//转化成LocalDate</span></span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();<span class="comment">//转化成LocalTime</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-LocalTime-LocalDateTime-–-gt-Date"><a href="#LocalDate-LocalTime-LocalDateTime-–-gt-Date" class="headerlink" title="LocalDate/LocalTime/LocalDateTime –&gt; Date"></a>LocalDate/LocalTime/LocalDateTime –&gt; Date</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">Date date = Date.from(instant);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">Instant instant = localDate.atStartOfDay().atZone(zone).toInstant();</span><br><span class="line">Date date = Date.from(instant);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.now();</span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">Date date = Date.from(instant);</span><br></pre></td></tr></table></figure><h2 id="计算两个时间差"><a href="#计算两个时间差" class="headerlink" title="计算两个时间差"></a>计算两个时间差</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">LocalDateTime start = now.minusDays(<span class="number">5</span>);</span><br><span class="line">Duration duration = Duration.between(start,now);</span><br><span class="line">System.out.println(duration.toDays());</span><br></pre></td></tr></table></figure><h2 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h2><p>Instant代表某个时间，类似于<code>java.util.Date</code>，它是精确到纳秒的（而不是象旧版本的Date精确到毫秒）。如果使用Long去表示，其中的存储空间是不够的，不能像data那样直接使用一个long类型表示时间戳。其实在Instant中，它的源码就是分成两部分组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Instant</span><span class="params">(<span class="keyword">long</span> epochSecond, <span class="keyword">int</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.seconds = epochSecond;</span><br><span class="line">    <span class="keyword">this</span>.nanos = nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instant和上面介绍的时间类一样，提供了很多的方法。简单的介绍点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(instant);</span><br><span class="line">    <span class="comment">//将java.util.Date转换为Instant</span></span><br><span class="line">    Instant time = Instant.ofEpochMilli(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">    <span class="comment">//从字符串类型中创建Instant类型的时间</span></span><br><span class="line">    instant = Instant.parse(<span class="string">&quot;1995-10-23T10:12:35Z&quot;</span>);</span><br><span class="line">    <span class="comment">//将现在的时间加上5个小时4分钟</span></span><br><span class="line">    instant.plus(Duration.ofHours(<span class="number">5</span>).plusMinutes(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">java8 doc DateTimeFormatter</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客</title>
      <link href="hexo-instructions/"/>
      <url>hexo-instructions/</url>
      
        <content type="html"><![CDATA[<p>最近想自己搭建一个个人博客，就去网上去看下有没有开源的代码可以拿来使用，在比较了网上一些开源的博客后，选择了Hexo。主要自己想在平时学习积累的时候，有个地方记录下自己的学习，嗯，还有一个和重要的的因素，那就是顺便装个B。</p><h1 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h1><p><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>安装hexo之前先安装 Node.js 和 Git，之后使用npm下载hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>参考官网<a href="https://hexo.io/zh-cn/docs/deployment">Hexo</a>的技术文档。服务器可以选择 coding 和 GitHub Page，他们都有免费的静态博客服务器提供，基本上满足了自己的需求。</p><h2 id="域名的绑定"><a href="#域名的绑定" class="headerlink" title="域名的绑定"></a>域名的绑定</h2><p>本人实在阿里云上面买的域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">source</span></span><br><span class="line">touch CNAME</span><br></pre></td></tr></table></figure><ul><li>并在文件中写上你的域名，比如：example.com。如果想在国内走coding，国外走GitHub，那些在阿里云上面设置域名解析。<br><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/90ec15fefdc96bb3317f73d06a6fc446.jpg"></li></ul><p>并在coding page上，进行域名绑定，可以开启HTTPS。GitHub上面现在不支持自定义域名绑定的HTTPS。   </p><ul><li>不过GitHub page已经支持HTTPS认证了，直接在域名解析中，如下图使用就OK了，顺便再GitHub上面勾选<code>Enforce Https</code>:</li></ul><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/Qiniu/259dab614632a55721d27042f795454a.jpg"></p><h2 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h2><p>Hexo提供了很多种部署，可以如前面一样选择部署到coding page或者GitHub page上面，也可以部署到服务器上面，<a href="#%E9%83%A8%E7%BD%B2">部署详情</a>。</p><p>本人选择的喜欢捣鼓，就想把hexo部署到阿里云服务器上面，<a href="https://segmentfault.com/a/1190000009723457">参考资料1</a>，<a href="https://segmentfault.com/a/1190000005723321">参考资料2</a><br>部署完成，发现Nginx访问403，看了下日志，好像是文件权限问题，于是就使用ll命令查看了下文件，发现hexo文件是git用户的，Nginx是root用户在访问这个文件夹，使用chown -R root:root &lt;文件夹名&gt;，把hexo文件夹权限改为root的，再次访问就可以了。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>启动本地服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>部署到GitHub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h2 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h2><p>一开始使用的主题是indigo，但是在使用的过程中，虽然自己是一只程序猿，但是对前端的内容只能看个基本的，所以对于自己的一些前端修改，很怕。最近，在逛hexo主题的时候，发现了一款非常不错的主题<a href="https://github.com/iissnan/hexo-theme-next/">next</a>。反正我在使用之后，发现是个不错的主题，它对很多第三方插件，有了很好的集成，你是要改下配置，基本上就满足你的需求。详情可以查看它的<a href="http://theme-next.iissnan.com/">next主题官网</a>，上面有很多的介绍，可以自己进行定制，而且页面也比较简洁。</p><h2 id="开启版权声明"><a href="#开启版权声明" class="headerlink" title="开启版权声明"></a>开启版权声明</h2><p>把其中的enable设置为true：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line">post_copyright:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></pre></td></tr></table></figure><h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>打开 themes/next/layout/_macro/post.swig 文件，搜索 rel=”tag”&gt;# ，将 # 换成 <i class="fa fa-tag"></i></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;post-tags&quot;</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> tag <span class="keyword">in</span> post.tags %&#125;</span><br><span class="line">       &lt;a href=<span class="string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> rel=<span class="string">&quot;tag&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-tag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><p>先使用下面命令生成博客模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure><p>之后就可以使用编译器进行编写了。Hexo博客的编写是使用Markdown的。查看<a href="https://www.zybuluo.com/mdeditor#%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8-cmd-markdown-%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8">Markdown</a>的详细语言。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>可以现在本地看下自己的编写情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>可以边修改便查看。好了之后就可以发布到自己的Coding page和GitHub page上面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>在编写博客的时候，我们难免会使用到图片，那是把图片放在hexo本地呢？还是放在服务器上呢？为什么删除七牛云，因为七牛云因为有人使用它的域名，进行非法事件，域名被查封了，于是出现了测试域名回收事件，域名只有30天有效时间，除非你自己绑定域名，而且需要备案过的。对于自己简单的博客，不想搞了，于是去找别家的对象存储，发现腾讯云和网易云的对象存储有免费的，对于一个网站图床来说感觉够用了。本人最后选择的是腾讯云，因为我之前在活动期间买了服务器，不想东一家西一家了。</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20181123160641.png"></p><p><del>这个时候我就推荐七牛云了，这个在我之前的工作中也在使用，发现还挺方便的。免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这个对于个人来说已经够用了，如果你想使用七牛云，可以走这个<a href="https://portal.qiniu.com/signup?code=3lpwng1uo5jki">通道</a>，这样，我就可以每个月多得5G的下载流量了。</del></p><h2 id="七牛云-Alfred-插件组合"><a href="#七牛云-Alfred-插件组合" class="headerlink" title="七牛云+Alfred+插件组合"></a>七牛云+Alfred+插件组合</h2><p><del>本人图床使用的是七牛云+Alfred+插件组合使用的，使用快捷键，就可以直接上传到七牛云，返回一个MarkDown的图片路径，<a href="https://github.com/jiwenxing/qiniu-image-tool">插件源码</a>，上面有比较详细的安装过程，声明一点Alfed这款软件只在Mac有。</del>  </p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>上面只能再Mac上使用，发现了另外一款图床软件<a href="https://github.com/Molunerfinn/picgo/releases">PicGo</a>，支持Mac和Windows，在他的介绍上，除了七牛云、GitHub图床、腾讯云等。</p><h2 id="live2"><a href="#live2" class="headerlink" title="live2"></a>live2</h2><p>今天看到别人关于介绍给博客添加个萌娘，给自己的博客增彩。效果如下：</p><p><img src="https://hexo-1252893039.cos.ap-shanghai.myqcloud.com/20191011154725.gif"></p><p>live2 完美兼容 Hexo，对Hexo 的支持非常友好。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>使用 npm 在 hexo 下安装 hexo-helper-live2d，它将 live2d-widget.js 与 hexo 进行了整合，使得我们只需要通过简单的配置，即可生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 live2 插件</span></span><br><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line"><span class="comment"># 安装人物模型 https://github.com/xiazeyu/live2d-widget-models</span></span><br><span class="line">npm install live2d-widget-model-z16</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在Hexo 的 _config.yml 文件中添加配置，同时在根目录下添加 1live2dw` 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  scriptFrom: <span class="built_in">local</span> <span class="comment"># 默认 </span></span><br><span class="line">  pluginRootPath: live2dw/  <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  pluginJsPath: lib/    <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  pluginModelPath: assets/    <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  tagMode: <span class="literal">false</span>     <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  debug: <span class="literal">false</span>       <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko   <span class="comment"># npm-module package name</span></span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
